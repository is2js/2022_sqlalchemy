

### 재직상태변경(휴직)처리

#### 퇴사일처럼 빈 휴직일 칼럼도 정해져있어야, 근무일을 휴직을 today_date(end_date)로 계산할 수 있다. 추가로 복직일도 있어야 복직일~today_date까지 계산할 수 있다.



![image-20230113212813986](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230113212813986.png)



#### 01 휴직일 복직일 칼럼 추가



```python
class EmployeeDepartment(BaseModel):
    # 2. 고용일과 퇴직일은 없을 수 있다?! (퇴직일만 nullable=True인듯)
    employment_date = Column(Date, nullable=False, comment='입사일과 다른, 부임일')
    dismissal_date = Column(Date, nullable=True)
    # 휴직처리를 위한 휴직일과 복직일 칼럼 추가
    leave_date = Column(Date, nullable=True)
    reinstatement_date = Column(Date, nullable=True)
```



#### 02 재직상태 변경 -> 휴직 으로 변경시 (job_status + (x퇴직일할당) + (x default role x) +  취임정보 해임일 대신 휴직일 기록만 한다

```python
    ### with other entity
    @classmethod
    def change_job_status(cls, emp_id: int, job_status: int):
        #### 휴직은 job_status만 변경(퇴직일X, ROLE변화X)
        #### emp_dept에 휴직일 기입
        elif job_status == JobStatusType.휴직:
            with DBConnectionHandler() as db:
                emp: Employee = cls.get_by_id(emp_id)

                emp.job_status = job_status
                
                emp.reference = f'휴직일:{format_date(datetime.date.today())}'

                db.session.add(emp)

                emp_dept_list: list = EmployeeDepartment.get_by_emp_id(emp.id)
                for emp_dept in emp_dept_list:
                    emp_dept.leave_date = datetime.date.today()

                db.session.add_all(emp_dept_list)
                db.session.commit()

                return emp
```

![image-20230113222725343](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230113222725343.png)

- **role은 그대로 있고 휴직상태로 변경**  되었다

![image-20230113222901711](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230113222901711.png)

- 휴직시 휴일정보가 기입된다.



#### 04 재직상태변경에서 퇴사자 => [재직]으로 변경은 불가하다(직원초대로만) [재직]대신 [복직]을 넣어서 재직상태로 돌리되, 비고에 복직을 입력하자.

```python
#### 재직상태변경 modal 속 select option 추가로 내려보내기
job_status_list = JobStatusType.choices()
# print(job_status_list)
# [(1, '재직'), (2, '휴직'), (3, '퇴사')]
#### => 여기서만 재직 = 1을 복직으로 변경해서 내려주자. (form에서는 재직으로?)
job_status_list = job_status_list[1:] + [(1, '복직')]

```



![image-20230113224208144](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230113224208144.png)





#### 05 복직은 휴직자만 가능하도록 조건 먼저 걸기

```python
        if not employee.role.is_under(g.user.role):
            flash('자신보다 하위 직위의 직원만 수정할 수 있습니다.', category='is-danger')
            return redirect(redirect_url())

        #### 퇴사자는 재직상태 변경 못하고, 직원초대로만 가능하도록 early return
        if employee.job_status == JobStatusType.퇴사:
            flash(f'퇴사자는 재직상태변경이 불가하며 User관리에서 직원초대로 새로 입사해야합니다. ', category='is-danger')
            return redirect(redirect_url())

        #### 복직은 휴직자만 가능하도록 걸기========================
        if job_status == JobStatusType.재직 and employee.job_status != JobStatusType.휴직:
            flash(f'복직은 휴직자만 선택할 수 있습니다. ', category='is-danger')
            return redirect(redirect_url())

        #### 이미 해당 재직상태인데 같은 것으로 변경하는 것을 막기 위한 처리문
        # => 이것을 처리해줘야 emp.user.role  <-> Role.get_by_name('USER')시 session내 같은 객체 조회를 막을 수 있다
        if employee.job_status == job_status:
            flash(f'같은 상태로 변경할 수 없습니다. ', category='is-danger')
            return redirect(redirect_url())
```

![image-20230113224710259](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230113224710259.png)

### 재작상태변경(복직) 처리

- 기존 부서 그대로 복직하게 둔다.

  ```python
          #### 복직처리 => 기존 부서 그대로 복직한다. 필요하면 해임하고, 부서변경해야한다.
          elif job_status == JobStatusType.재직:
              with DBConnectionHandler() as db:
                  emp: Employee = cls.get_by_id(emp_id)
  
                  emp.job_status = job_status
                  
                  emp.reference = f'복직일:{format_date(datetime.date.today())}'
  
  
                  db.session.add(emp)
  
                  emp_dept_list: list = EmployeeDepartment.get_by_emp_id(emp.id)
                  for emp_dept in emp_dept_list:
                      emp_dept.reinstatement_date = datetime.date.today()
  
                  db.session.add_all(emp_dept_list)
                  db.session.commit()
  
                  return emp
  ```

  ![image-20230113231803196](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230113231803196.png)





### 재직상태변경시마다 reference에 `<br/> => front |safe`으로 이어서 추가하고, 직원관리에서는 tooltip으로 보이게 하기

- 기존내용을 뒤로, 새로운 내용을 앞으로 append해나간다

```python
    def update_reference(self, text):
        if not self.reference:
            self.reference = text
        else:
            self.reference = text + '<br/>' + self.reference
```

```python
# emp.reference = f'휴직({format_date(datetime.date.today())})'
emp.update_reference(f'휴직({format_date(datetime.date.today())})')
```

```html
<td>
    {% if employee.reference %}
    <b-tooltip
               position="is-right"
               type="is-dark"
               >
        <template v-slot:content>
            <span class="is-size-7">
                {{ employee.reference | safe }}
            </span>
        </template>

        <span class="has-text-dark">참고사항</span>
    </b-tooltip>

    {% else %}
    -
    {% endif %}
</td>
```



![image-20230113233757218](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230113233757218.png)

![image-20230113235340561](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230113235340561.png)



### 직원초대 로직 개선 + form에 기존 직원정보 있을 때, 주민번호 중복 검사 피하도록 수정하기

- session중복을 피하기 위해, 매번 찾아서 처리하기

- EmployeeForm(UserInfo)에 들어있는 `self.user`객체로 **기존 직원 정보 있는지 확인 property**

  ```python
  class User(BaseModel):
      #...
      @hybrid_property
      def has_employee_history(self):
          with DBConnectionHandler() as db:
              stmt = (
                  exists()
                  .where(Employee.user_id == self.id)
                  .select()
              )
              return db.session.scalar(stmt)
  ```

- EmployeeForm(UserInfo)에 들어있는 `self.user`객체로 **기존 직원정보가 있을 경우, 주민번호 중복검사 피하도록(수정때 처럼)**

```python
    def validate_birth(self, field):
        if self.employee:  # 수정시 자신의 제외하고 데이터 중복 검사
            condition = and_(Employee.id != self.employee.id, Employee.birth == field.data)
        else:  # 생성시 자신의 데이터를 중복검사
            condition = Employee.birth == field.data

        #### 재입사로서 self.user => Employee에 정보가 있을 경우, 해당 데이터 제외하고 검사
        # print(self.user, self.user.has_employee_history)
        # User[id=32] True
        if self.user and self.user.has_employee_history:
            condition = and_(Employee.user_id != self.user.id, Employee.birth == field.data)

        with DBConnectionHandler() as db:
            is_exists = db.session.scalar(
                exists().where(condition).select()
            )


            if is_exists:
                raise ValidationError('이미 존재하는 주민등록번호 입니다')

```



### 기존 입사 정보가 있는 사람이 초대받았다면, 그 정보도 form에 미리 채워놓기

```python
class EmployeeForm(UserInfoForm):
    def __init__(self, user,
                 employer=None, role=None, # 직원전환시 상사객체 OR 직원초대시, role객체 =>  role을 선택할 수 있거나 role을 미리 채운다
                 employee=None, # 수정을 위한 미리생성된 user의 employee객체
                 *args, **kwargs):
        #...
        
        #### 재입사시, 기존 직원들 정보로 미리 채우는 것 추가
        if self.user and self.user.has_employee_history:
            prev_emp: Employee = Employee.get_by_user_id(self.user.id)
            if not prev_emp:
                return
            self.name.data = prev_emp.name
            self.sub_name.data = prev_emp.sub_name
            self.birth.data = prev_emp.birth
```



![image-20230114024740920](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230114024740920.png)



### 입사일/퇴직일 외 휴직일 칼럼을 추가해서, 휴직상태 - [최종]휴직일을 근무일 계산 [마지막 날짜]으로 활용할 수 있게 하자

- 중간에 휴직-복직을 할 수 있으며, 그 정보는 부서취임정보에서 얻을 수 있지만, **현재 휴직상태 => 최종 휴직일**을 알면, 근무일의 마지막일을 빠르게 알 수 있다.
  - 근무 마지막일을 알고서, 중간에 퇴사-재입사 / 휴직-복직 날짜들을 빼 줄 수 있다?
- `nullable + 입력없이 코드에서 채워주는 칼럼`은, form에서 받을 필요없어서 작성안해도 된다.

![image-20230114212700480](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230114212700480.png)

```python
class Employee(BaseModel):
    __tablename__ = 'employees'
    #...
    
    # job_status가 User에서 신청한 대기 Employee(role이 아직 User)를 검색해서 대기중인 Employee데이터를 골라낼 수도 있다.
    # - 예약시에는 reserve_status가 대기 중인 것을 골라낼 것이다.
    job_status = Column(IntEnum(JobStatusType), default=JobStatusType.재직, nullable=False, index=True)
    resign_date = Column(Date, nullable=True)
    # new : 휴직 상태의 최종휴직일을 알도록 칼럼을 추가한다
    leave_date = Column(Date, nullable=True)

    #...
```

- 현재 휴직상태(2)의 employee에게 휴직날짜를 임으로 배정해준다.

  ![image-20230114213900296](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230114213900296.png)

#### Employee 재직상태 변경시, 휴직이면 휴직일을 채워주고 => 재입사일 경우, 퇴직일 이외에 휴직일도 비워줘야한다

```python
class Employee(BaseModel):
    __tablename__ = 'employees'
    
    #...
    
    @classmethod
    def change_job_status(cls, emp_id: int, job_status: int):
        
        # ...
        
        elif job_status == JobStatusType.휴직:
            with DBConnectionHandler() as db:
                emp: Employee = cls.get_by_id(emp_id)

                emp.job_status = job_status
                #### 휴직시, 최종 휴직일칼럼도 채운다 like 퇴직
                emp.leave_date = datetime.date.today()
```



#### 직원초대 수락 route 에서 재입사에 대한 처리시, 재직상태로 변경이니, 퇴직일 이외에 휴직일도 비워줘야한다

```python
@auth_bp.route('/invite/employee/accept/<int:id>/', methods=['GET', 'POST'])
@login_required
def employee_invite_accept(id):
    #...
    with DBConnectionHandler() as db:
        #...
    if form.validate_on_submit():
            if prev_employee:
            #### 재입사라서 기존 정보가 있으면 그것만 업데이트하자
            #### => 대신 [reference는 기존 것 유지 + 해고일 + 휴직일 None으로 비어야한다.]
                #### 이미 user의 관계필드에 해당객체를 가지고 있는 상태에서 처리하면 session 이미 가지고 있다고 나온다.
                prev_employee.update(
                    #### 재입사시 달라지는 부분 2
                    #### =>관계필드로 이미 해당유저를 가지고 있기 때문에, 같은 user를 할당시 에러난다
                    # user=invitee_user,
                    user_id=invitee_user.id,
                    name=form.name.data,
                    sub_name=form.sub_name.data,
                    birth=form.birth.data,
                    join_date=form.join_date.data,
                    job_status=form.job_status.data,
                    # 재입사해도 유지되는 부분
                    # reference=reference,
                    # 재입사시 달라지는 부분 => 재직상태변경으로 퇴직일/휴직일 비우기
                    resign_date=None,
                    # 휴직일
                    leave_date=None,
                )
```



#### emp의 근무마지막날짜를 파악하기 위해 재직상태 조회 property 구현

```python

    @hybrid_property
    def is_pending(self):
        return self.job_status == JobStatusType.대기

    @is_pending.expression
    def is_pending(cls):
        return cls.job_status == JobStatusType.대기
    
    @hybrid_property
    def is_active(self):
        return self.job_status == JobStatusType.재직

    @is_active.expression
    def is_active(cls):
        return cls.job_status == JobStatusType.재직


    @hybrid_property
    def is_leaved(self):
        return self.job_status == JobStatusType.휴직

    @is_leaved.expression
    def is_leaved(cls):
        return cls.job_status == JobStatusType.휴직

    @hybrid_property
    def is_resigned(self):
        return self.job_status == JobStatusType.퇴사

    @is_resigned.expression
    def is_resigned(cls):
        return cls.job_status == JobStatusType.퇴사

```



#### 재직상태에 따른 마지막 근무일 property로 구현

```python
    # 재직상태에 따라 근무의 마지막일 찾기
    @property
    def last_working_date(self):
        # => 그림1: https://raw.githubusercontent.com/is3js/screenshots/main/image-20230114212700480.png
        #### 이 사람이 퇴사한 상태라면, 퇴사일을 마지막으로 기준으로 근무 개월수를 세어야한다
        if self.is_resigned:

            # end_date = self.resign_date
            #### 퇴직일이 해당일이라면, 하루 전이 마지막 근무일이다.
            end_date = self.resign_date - relativedelta(days=1)
        #### 이 사람이 휴직 상태라면, 부서취임정보에서 휴직일을 들고와야한다?
        #### => 어차피 나중에 부서취임을 필수로 해서, 중간휴직-중간복직이 나올 것이기 때문에
        ####    최종휴직일(nullable)칼럼을 만들고, 휴직상태시 최종 휴직날짜를 알게 한다
        elif self.is_leaved:
            #### 휴직일이 해당일이라면, 그 전날까지가 근무일이다.
            end_date = self.leave_date - relativedelta(days=1)
        # 재직이나 대기상태 => 해당일도 근무일이다.
        else:
            end_date = datetime.date.today()
        return end_date
```





#### 근무 마지막날짜를 재직상태에 따라서, 해당날짜로 확인

```python
    ## self.join_date + relativedelta(months=1) 는 정확히 다음달 같은 일을 나타낸다
    # - 2월1일(join) 입사했으면, 3월1일(today)에 연차가 생기도록, (딱 1달이 되는날)
    # - 차이가 1달이라는 말은, 시작일제외하고 [시작일로부터 차이가 한달]이 지났다는 말이다.
    #    3-1 = 시작일 빼고 2일,   차이6 => 시작일포함 7일, 시작일 제외 시작일부터 6일지남
    # - 계산기준일에 relativedelta를 끼워서 계산하도록 한다.
    # - 월차휴가 계산과 동일하며, 월차는 연도제한 + 연차도 계산해야한다.
	def calc_complete_month_and_days(self, start_date, end_date):
        months = 0
        while end_date >= start_date + relativedelta(months=1):
            end_date -= relativedelta(months=1)
            months += 1
        # 사실상 1개월만근이후 남은 days은 [월차]계산시 필요없다.
        days = (end_date - start_date).days  # timedelta.days   not int()

        return months, days


    # 근무개월 수 (다음달 해당일시 차이가 1달로 +1)
    # 연차휴가 참고식: https://www.acmicpc.net/problem/23628
    # https://www.saramin.co.kr/zf_user/tools/holi-calculator
    @property
    def complete_working_months_and_days(self):
        # 재직상태에 따라 근무의 마지막일 찾기
        end_date = self.last_working_date

        months, days = self.calc_complete_month_and_days(self.join_date, end_date)

        return months, days
```

![image-20230114220302312](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230114220302312.png)

![image-20230114220905368](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230114220905368.png)

- 입사일은 동일한 3명이
  - 퇴사 12일
  - 휴직 13일
  - 오늘 14일 때, 1일씩 차이나도록 근무되는 것을 확인할 수 있다.
    - 다음날이면  오늘만 15일이 되어, 조이현만 증가할 것이다.



### 기존 취임정보에 휴직일/복직일을 덮어쓰기하면, 2번이상 반복시 덮어쓰기되서 날아간다. => 복직 확정순간에 history테이블에 남기며, 새 휴직 발생시마다 시 최종복직일을 비운다.

- **현재 1개의 취임정보에  휴직일/복직일을 찍으며 재사용**하고 있다  => **휴직/복직을 2번이상하면 덮어쓰기 당해서 휴직/복직 정보가 사라진다**

  ![image-20230115155910525](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230115155910525.png)

  

#### 취임정보 중 휴직~복직 완성 정보가 있다면, 중간에 catch해야한다.  해임정보(퇴사)는 상관없다.  해임되면 끝임.  휴직정보중에서 복직일이 없는 현재 휴직(Emp.job_status 휴직)도 마찬가지 상관없다.  =>마지막날짜로 잡히니,  중요한 것은 [복직일이 찍힌] 휴~복직 기간의 기록인데, 휴직~복직 정보만 추출해야한다. 또한 여러부서에 속한 경우 중복도 제거해야한다.

![image-20230115154030277](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230115154030277.png)

#### 취임정보에 휴직/복직정보는 1번밖에 못남기니, 복직이 찍히는 순간 history로 남기자.



- 휴직시 **if 취임정보에 새로운 데이터로 기록하면?**
  - 해고일 <-> 휴직일/복직일을 **제외하고 다 중복**되고, 기존 조회메서드들이 타격을 입을 수 있다.
  - **취임정보 조회**시 `해고일 없는 정보만 조회`하는데, **휴직~복직만 찍힌 새 취임정보도 제외시켜야한다**
  - 취임정보는, 입/퇴사 정보만 남아야하는데, 휴직~복직정보들이 중복되서 생긴다면 복잡해진다.

![image-20230115161642659](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230115161642659.png)

- **기존 취임정보에 휴직일**을 찍되 =>  **기존 복직일이 있을 수 있으므로 항상 None 할당**
- **기존 취임정보에 복직일을 찍는 순간 휴~복직 기간 완성으로 => `emp_leave_history 새 테이블`에 record기록**
  - emp_leave_history 테이블에 휴직일~복직일 정보를 누적
  - 기존 취임정보가 다시 휴직을 할땐, 복직일이 남아있다면 None으로 비워



#### class EmployeeLeaveHistory

![image-20230115164248471](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230115164248471.png)

```python
class EmployeeLeaveHistory(BaseModel):
    __tablename__ = 'employee_leave_histories'

    id = Column(BigInteger().with_variant(Integer, "sqlite"), primary_key=True)

    employee_id = Column(Integer, ForeignKey('employees.id'),
                         nullable=False, index=True)

    #### 원래는 직원별, 부서별, 휴~복직 정보를 모으려고 했는데
    #### => 어차피 내가 속한 부서들 다 가져와서 한번에 처리하므로
    #### => 아예 부서정보를 빼고 1번만 생성되도록 한다면, 나중에 중복제거를 안해도 된다.
    #### => 그렇다면, 취임정보(employee_departments)테이블과 무관하게 생성해도 된다.
    #### => 직원이 휴직하면 소속부서 전체가 휴직정보를 남기지만,
    ####    복직시 history는 직원단위로 1개만 남기게 한다?!
    # department_id = Column(Integer, ForeignKey('employee_departments.department_id'),
    #                        nullable=False, index=True)
    #### 부서정보가 빠지면, EmpDept가 아닌 Emp와 1:M의 관계로서, 반대로 관계객체도 만들 수 있다?!
    employee = relationship("Employee", backref="employee_leave_histories", foreign_keys=[employee_id],
                            )

    leave_date = Column(Date, nullable=False)
    reinstatement_date = Column(Date, nullable=False)

    def __repr__(self):
        info: str = f"{self.__class__.__name__}" \
                    f"[직원id={self.employee_id!r}," \
                    f" 휴직={self.leave_date!r} ~ 복직={self.reinstatement_date!r}]"
        return info
```



#### 재직상태변경(Employee.change_job_status(employee_id, job_status)) 휴직시에는 최종 복직일 비우기 / 복직시에는 LeaveHistory 남기기

- 휴직시  취임정보에서 기존 최종복직일을 비운다.
  - **근데 작성하다보니, 취임정보에서 휴직일을 안가져가고, emp에서 휴직일을 가져간다면, 취임정보에는 휴직일/복직일 정보가 딱히 필요없다?! => 나중에 휴직자 제외 필터링에나 쓰이려나?**
    - emp에서는 최종복직일을 기록하지 않으니 안비워도 된다?!

```python
        elif job_status == JobStatusType.휴직:
            with DBConnectionHandler() as db:
                emp: Employee = cls.get_by_id(emp_id)

                emp.job_status = job_status
                emp.leave_date = datetime.date.today()
                

                emp.update_reference(f'휴직({format_date(datetime.date.today())})')

                db.session.add(emp)

                emp_dept_list: list = EmployeeDepartment.get_by_emp_id(emp.id)
                for emp_dept in emp_dept_list:
                    emp_dept.leave_date = datetime.date.today()
                    ####  new) for leave history => 휴직시, 최종복직일을 비우는 로직 추가
                    emp_dept.reinstatement_date = None

                db.session.add_all(emp_dept_list)
                db.session.commit()

                return emp
```

![image-20230115165750603](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230115165750603.png)

- **복직시, leave_history 데이터를 만든다.**
  - 취임정보에서 최종휴직일을 쓰려고 했으나, **emp에 이미 최종휴직일 칼럼이 있으니, 그것을 갖다 쓴다. 복직일은 오늘이므로 today로 씀.**
  - 원래 최종복직일 정보는 today로서 취임정보에서 가져올 필요없으므로 취임정보에서 나중엔 삭제할 것 같다??

```python
        #### 복직처리 => 기존 부서 그대로 복직한다. 필요하면 해임하고, 부서변경해야한다.
        elif job_status == JobStatusType.재직:
            with DBConnectionHandler() as db:
                emp: Employee = cls.get_by_id(emp_id)

                emp.job_status = job_status

                emp.update_reference(f'복직({format_date(datetime.date.today())})')

                db.session.add(emp)

                
                emp_dept_list: list = EmployeeDepartment.get_by_emp_id(emp.id)
                for emp_dept in emp_dept_list:
                    emp_dept.reinstatement_date = datetime.date.today()
                
                db.session.add_all(emp_dept_list)
                
                #### new) 복직시, 휴-복직일이 완성되어, leave_history를 남긴다
                leave_history = EmployeeLeaveHistory(employee=emp,
                                               # 휴직일을, 내가속한부서들에서 가져오지말고, emp에 만들어준 최종휴직일을 써보자.
                                               leave_date=emp.leave_date,
                                               # 복직일은, 당일이므로 toady를 취임정보에 넣듯이 today로 처리해보자.
                                               reinstatement_date=datetime.date.today(),
                                               )
                db.session.add(leave_history)

                db.session.commit()

                return emp
```

![image-20230115165809444](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230115165809444.png)

![image-20230115165821785](https://raw.githubusercontent.com/is3js/screenshots/main/image-20230115165821785.png)



### 만근개월 연차 계산시, 입사일 - last_working_Date 사이에 휴-복직(leave_history)가 있으면, 각각 파트를 나누어서 카운팅하기

#### emp.get_leave_history() => all()로 가져와서 없으면 []

```python
    #### with other entity
    def get_leave_history(self):
        with DBConnectionHandler() as db:
            stmt = (
                select(EmployeeLeaveHistory)
                .where(EmployeeLeaveHistory.employee_id == self.id)  # 있다는 말은 이미 휴직/복직 set완성
                .order_by(EmployeeLeaveHistory.add_date)  # 시간순으로 가져오기
            )

            return db.session.scalars(stmt).all()
```



#### grouped 유틸메서드를 만들어, 입사-퇴직 + 중간휴-복직 set들을 정렬한 것을 2개씩 tuple짝지은 list로 반환하여, 매번 만근개월수를 계산한다

```python
import itertools


def grouped(iterable, n, strict=False, fill_value=None):
    if strict and len(iterable) % n != 0:
        raise ValueError('그룹별 갯수가 정확하지 않습니다.')

    # 1) zip에 iter()로 만든 것을 그룹내갯수만큼 zip 집어넣으면, 1개씩 빠져서 조합되어
    #    group이 형성된다. 그 갯수만큼 list로 복사한 뒤, -> zip()괄호안에 *args로 풀어준다.
    #    -> 왜냐면 zip은 콤마로 그 인자들을 받는 메서드이므로
    args = [iter(iterable)] * n
    # 2) 나누어떨어지는 경우, zip에다가 iter를 그룹화갯수만큼 comma로 연결한다.
    if strict:
        return zip(*args)
    # 3) 나누어떨어지지 않는 경우 .itertools.zip_longest에 넣어준다.
    else:
        return itertools.zip_longest(*args, fillvalue=fill_value)

```



### 연차발생 테스트는 휴직처리후, leave_date를 마지막근무일+1로 DB조정하면서 연차계산기와  테스트해보기

- 참고
  - 휴직일/퇴직일 - 1 = 마지막 근무일
  - 마지막 근무일이 `발생지점인 입사일`과 같아질 때, 해당월의 월차 발생
  - **`휴직일/퇴직일은 입사일(발생지점)보다 날짜가 하루 더 지나야한다.`**
    - 휴직일 11 => 입사일 11 : 발생안함
    - 휴직일 12 => 입사일 11 : 발생함
    - **재직일** 11 => 입사일 11 : 발생함.

- `2022-01-14` => 1년미만 마지막인 11개 발생지점(02.14~12.14) : `2022-12-14`

  1. 10개 발생지점(`2022-11-14`)보다 1일 적게 일한 경우, 연차9개가 떠야한다

     - 즉, 휴직일/퇴직일은, 발생지점(입사일)보다 1일 더 지난 상태로 설정해야 월차가 발생한다.

     ![image-20230116220009488](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116220009488.png)

     ![image-20230116220038361](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116220038361.png)

     ![image-20230116220031704](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116220031704.png)

  2. 10개 발생지점(11-14)까지 일하는 경우 -> 휴직일 2022-11-15

     ![image-20230116222253504](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116222253504.png)

     ![image-20230116222246996](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116222246996.png)

     ![image-20230116222318575](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116222318575.png)

  3. 11개 발생지점 (12-14)일까지 일하는 경우 => 휴직일 12-15 => 연차 11개

     ![image-20230116222545597](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116222545597.png)

  4. **12개 발생지점(다음해 1-14)까지 일하는 경우 => 휴직일 다음해 1-15 => `월차 11개`  + `연차 15개`**

     ![image-20230116222728350](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116222728350.png)

     ![image-20230116222804776](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116222804776.png)

  5. **중간에 1개월 휴직하되, 휴직을 중간 딱 1달만 만근 안채워지도록 하면 => 월차 10개 + 연차 15개**

     - 2022-01-14 입사
     - 2022-02-14까지 일하여 `월차 1개 발생` 후
       - 발생지점+1일인 02-15부터
       - 다음달 발생지점이자 1년 채울시 손해 안보도록 **03-14일(발생지점, 입사일)에 복직하여 근무 시작 => `1년미만 마지막 구간 12-14 ~ 1-13`을 채워서, 1-14에 도달한다면다면?**
         - **`만약, 복직을 입사일보다 뒤에` 한다면,  12-15에 해서, `2년차 진입지점인 입사1년지점인 1-14에 도착했을 때,  마지막 구간이 12-15~1-13으로 계산` => 1년안에서의  마지막 달에서 1달 못채우고 `다음해로 넘어가서 연차발생 1개 손해` => 발생 안함.**
         - 휴직없을 시: 2,3,4,5, ~ 12 까지 최대 11개 얻음. 
           - 다음해 1월-14일은 월차발생 없이 직전연도 출근율에 80% 이상인 경우, 연차 주어짐.
         - 휴직을 입사일+1시작(2022-02-15), 다음달 입사일(`2022-03-14`)에 맞춰서 복직한 경우: 
           - 2 + 4,5,6,7,8,9,10,11,12 + `1(원래는 카운팅안되던 12.14~1.13 만근`) => 똑같이 11개
     - **발생지점 14일 초과하여 휴직 시작 => 1달이하로 쉬고 14일이내에 복직을 한다고 한다면 => `12개 발생지점에서도 11개가 발생될 수 있다.`**
       - 12개 발생지점을 방지하기 위해 `마지막 근무일 => 2년차 시작일 -1일`로 옮기던 것을
       - **12개 발생지점까지 가능하도록 `마지막 근무일 => 2년차 시작일`로 옮겨 12개 발생은 가능하되**
         - **11개 넘으면 누적 금지**
         - **아직 11개 안됬다면, 12개 발생지점에서 11개까지 발생 가능**
       - 하도록 수정했다.

#### 테스트하며 calc_complete_month_and_days (self, start_date, end_date)모듈 수정

```python
    def calc_complete_month_and_days(self, start_date, end_date):
        #### 시작일이 2년차 시작일을 넘어가면 월차계산을 할 필요가 없다.
        #### 또는 srt는 1년만인데, end가 1년을 넘어가면 또 계산안한다.
        # 참고(연차휴가 퇴직정산): https://www.nodong.kr/AnnuaVacationComparison
        # 참고(만 1년(365일) 근무 후 퇴직시 연차휴가 발생 여부): https://www.nodong.kr/holyday/2265906

        next_year_start_date = self.join_date + relativedelta(years=1)
        if start_date >= next_year_start_date:
            # print(f'시작일{start_date}가 입사1년(2년차시작, 12개째 발생지점){next_year_start_date}을 넘어서는 순간 월차계산은 0으로 return된다')
            return 0, 0

        #### (start가 월차발생지점보다 작은데)
        #### 마지막 근무일이 2년차 시작일(deadline_date)보다 큰 경우,
        #### 월차 11개의 미자믹은, 1.1입사 -> 2.1부터 12.1까지만 판단하므로
        #### => 다음해 1.1은 계산시 사용되면 안된다.
        ####    월차발생기준일은 2.1등 +1달한 것의 기준인데, 12개발생하는 기준점인 다음해 1.1을 제외시켜 자제적으로 계산 안되게 한다

        # if end_date >= next_year_start_date:
        #     12개 발생 기준점을 없애버리자.=> 계산식을 안고쳐도 된다?!
        # print(f'마지막 근무일{end_date}가 입사후1년 == 12번째 월차발생지점{next_year_start_date}을 넘어서는 순간 마지막 근무일 대신 deadline_date - 1로 end_date를 바꿔서 일을 빼서, 발생못하게 막는다(최대 1년마지막날)')
        # end_date = next_year_start_date - relativedelta(days=1)
        
        # end_date = min(end_date, next_year_start_date - relativedelta(days=1))

        #### end_date를 12개 발생지점(2년차 시작일)이 안되도록 -1로 계산되게 하여 11개로 제한했지만,
        #### => 중간에 맞춰서  1달 쉰사람은, 11개 발생지점이 되기도 한다.
        #### => end_date를 12개 발생지점(2년차 시작일, 다음해 입사일)까지 허용하되
        ####   반복문에서 1달씩 누적시, 11개를 넘지 못하도록 한다.
        end_date = min(end_date, next_year_start_date)

        months = 0
        while end_date >= start_date + relativedelta(months=1):
            end_date -= relativedelta(months=1)
            # months += 1
            #### 원래는 각 구간별 11개 이하가 아니라, 바깥에서 누적되는 것이 11개 이하가 되도록 유지해야하지만
            #### 1) 휴직없이 풀로 일한다 => 누적없이 이 메서드 1번만 타서 전체가 11개이하가 된다.
            #### 2) 중간에 휴직을 짧게 했다 => 직전 누적월차를 고려해서 11개 이하가 되도록 유지해야하지만
            ####    => 휴직을 1번이라도 한 이상, 이미 1개를 놓치기 때문에, 12개발생지점까지 카운팅한다손 치더라도,
            ####       최대 12개 발생가능 중에 1개는 무조건 깍여서 최대 11개가 된다.
            if months < 11:
                months += 1


        # 사실상 1개월만근이후 남은 days은 [월차]계산시 필요없다.
        days = (end_date - start_date).days  # timedelta.days   not int()

        return months, days
```



#### emp.vacations => vacations_with_description연차는 tooltip용 도움말과 함꼐 반환하도록  수정

```python
    #### with other entity
    @property
    def vacations_with_description(self):
        # 1) 입사1년차(1년미만 근무)인 경우, 만근 개월 수 => [1년미만만 알아서 계산하는 월차]를 그대로 반환한다
        complete_months, _ = self.complete_working_months_and_last_month_days
        if self.years_from_join < 2:
            # print('1년차 미만이시네요. 월차만 계산합니다.')
            return complete_months, f"{complete_months}(1년미만)"
        # 2) 입사2년차부터는 입사1년차동안 출근율 80%이상 출근시, 2년차 1일차에 [연차]가 15개가 공짜로 생긴다
        #    기존 1년차 최대 11개에서 + 2~3년차는 매년 +15개씩, 3~4년차는 16개씩 증가한다
        #   => 그렇다면, [월차]계산은 1년차까지만 하고 나머지는 숫자로 누적해얗나다.
        #   => 월차계산시, end_date를 최대 1년으로 계산해야한다.
        #   => srt, end 계산하기 전에, dates목록에서 1년차를 넘어간 것들은 빼야한다?!

        # (2년차 이상) => 2년차 시작일로부터 1년씩 더해가면서, 발생시점을 넘기면 +15,+15, +16, +16
        if self.years_from_join < 4:
            # print('2~3년차시네요. 1년간 월차 + 매년 15개씩 만 계산합니다.')
            # 2, 3년차에는 각각 1*15 , 2* 15를 더한다.
            return complete_months + (
                        self.years_from_join - 1) * 15, f"{complete_months}(1년미만)+15*{(self.years_from_join - 1)}(2~3년차)"
        # (4년차 이상부터) 2개(2,3년차)를 15, 나머지는 16을 더한다.
        else:
            # print('4년차이상이시네요. 1년간 월차 + 2년간(2,3년차) 15개씩 + 4년차부터 16개씩')
            return complete_months + 2 * 15 + (
                        self.years_from_join - 3) * 16, f"{complete_months}(1년미만)+15*{(self.years_from_join - 1)}(2~3년차) + 16*{(self.years_from_join - 3)}(4년차이후)"



```



#### 직원관리에 tooltip으로 연차 설명 추가

```html
<td><span>
    <b-tooltip
               position="is-right"
               type="is-dark"
               >
        <template v-slot:content>
            <span class="is-size-7">
                {{ employee.vacations_with_description[1] }}
            </span>
        </template>

        <span class="has-text-dark">
            <small>
                {{employee.years_from_join}}년차(연차: {{ employee.vacations_with_description[0]}})
            </small>
        </span>
    </b-tooltip>
    </span>
</td>
```

![image-20230116235151879](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230116235151879.png)