### 지금까지

#### 스크립트: flask 실행 환경변수 -> OS에 세기고 -> flask run:실행

##### (1)  run.ps1 / run.cmd 실행 -> 가상환경에서 flask run

```ini
$env:FLASK_APP='manage.py'
#$env:FLASK_ENV='development'
#$env:FLASK_DEBUG='true'
# development /testing / production / default
$env:APP_CONFIG='production'
$env:FLASK_RUN_HOST='localhost'
$env:FLASK_RUN_PORT='5001'
```

```ini
set FLASK_APP='manage.py'
#set FLASK_ENV='development'
#set FLASK_DEBUG='true'
set APP_CONFIG='development'
set FLASK_RUN_HOST='localhost'
set FLASK_RUN_PORT='5000'
```

```shell
.\run.ps1
.\venv\Scripts\activate

flask run
```



- 파워셸 환경변수 확인 -> **`Get-childitem ENV:`의 약어**

  - [참고 블로그](https://wednesday1304.tistory.com/entry/PowerShell-%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%ED%99%95%EC%9D%B8-cmd)

  ```powershell
  gci env:
  ```

  

##### (2) 또는 flask run --host=localhost --port=5000 등 지정 실행

```shell
flask run --host=localhost --port=5000
```



##### FLASK_ENV 및 _DEBUG설정 대신 새로운 APP_CONFIG 환경변수를 새로 파서 -> 프로젝트 내부 settings.py에서 한다

- production이 선택되면, 내부에서 `ENV`와 `DEBUG`가 자동 설정되게 한다.
- 공통 설정 + 각 mode별 클래스를 만들어, 상속된 것을 선택해서 가져간다
- 

```python
# settings.py

#...

class FlaskConfig:
    # CORS
    SECRET_KEY = os.getenv("SECRET_KEY") or 'hard to guess string'

    # @staticmethod
    # def init_app(app: Flask):
    #     pass

    # 나는 app객체에 class를 넘기는게 아니라 객체를 넘겨서 import되어 사용될 예정이므로
    # self를 단 인스턴스 메서드를 작성한다?!
    def init_app(self, app: Flask):
        pass


class FlaskDevConfig(FlaskConfig):
    DEBUG = True 


class FlaskTestingConfig(FlaskConfig):
    TESTING = True


class FlaskProdConfig(FlaskConfig):
    ENV = 'production'
    DEBUG = False

    
app_config = {
    'development': FlaskDevConfig,
    'testing': FlaskTestingConfig,
    'production': FlaskProdConfig,
    'default': FlaskDevConfig,
}

app_config = app_config[os.getenv('APP_CONFIG') or 'default']()
#...
```



- init.py

```python
from src.config import app_config

#...
def create_app(config_name):
	#...
    print("config_name>>>", config_name)

    app = Flask(__name__,
                template_folder=template_dir,
                static_folder=static_dir)
    
    app.config.from_object(app_config)
```





#### FLASK_APP 모듈(manage.py)은 내부 create_app메서드로 app객체를 만든다.

##### 이 때, DB객체 및,, model을 import해서 `dict로 싸서 반환`해주면, flask shell에서 활용할 수 있다.

- **manage.py**

  ```python
  import os
  
  from src.infra.config.connection import DBConnectionHandler
  from src.infra.tutorial3 import User, Role
  from src.main.config import create_app
  
  app = create_app(os.getenv('APP_CONFIG') or 'default')
  
  
  # flask shell에 객체들을 미리 던져놓는다.
  @app.shell_context_processor
  def make_shell_context():
      return dict(db=DBConnectionHandler(), User=User, Role=Role)
  
  ```

  ```shell
  flask shell
  
  
  >>> db
  <src.infra.config.connection.DBConnectionHandler object at 0x00000212135FA5C0>
  >>> User
  <class 'src.infra.tutorial3.auth.users.User'>
  >>> Role
  <class 'src.infra.tutorial3.auth.users.Role'>
  >>>
  
  ```

  



##### 팩토리 메서드 create_app()은 src.main.config의 `init.py`에 만들어, from config패키지 import create_app 메서드만 가져오면 된다. 

![image-20230206235214521](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230206235214521.png)

1. **create_app 팩토리 메서드를 정의하는 init.py**에는

   1. 프로젝트 자체설정 `src.config` / db객체 / 모델들 / extenstions 들 / **Flask**  모듈을 import하며
   2. **커스텀 template/static폴더 지정**하여 **app객체 생성**시 입력된다.
   3. 각종 extension으로 app객체를 초기화한다.
   4. **jinja필터 추가**
   5. **bp추가**
   6. **add_url_rule 추가 url추가**
   7. **`항상 떠있을 데이터 inject메서드 정의 및 context_processor로 등록`**
   8. **`app객체 반환`**

   ```python
   # from .app import app
   
   import datetime
   from pathlib import Path
   
   from flask import Flask
   from flask_cors import CORS
   from sqlalchemy import select
   
   from src.config import app_config
   
   from src.infra.config.connection import DBConnectionHandler
   from src.infra.tutorial3 import Category, Setting, Permission, Roles
   
   ## Path.cwd()는 실행파일(root의 run.py)의 위치가 찍힌다 -> root부터 경로잡기
   # -> path는 joinpath시 끝이 디렉토리라면 / 까지 넣어줘야한다.
   
   template_dir = str(Path.cwd().joinpath('src/main/templates/'))
   static_dir = str(Path.cwd().joinpath('src/main/static/'))
   print(f"template_dir: {template_dir}\n"
         f"static_dir: {static_dir}")
   
   ## 추가 extenstion객체 생성
   # migrate = Migrate()
   # moment = Moment()
   # pagedown = PageDown()
   
   def create_app(config_name):
   
       print("config_name>>>", config_name)
   
       app = Flask(__name__,
                   template_folder=template_dir,
                   static_folder=static_dir)
   
       ## db환경변수를 개별로 넣지않고 config object로 넣는다.
       # app.config["SECRET_KEY"] = app_config.SECRET_KEY
       # app_config.init_app(app)
       app.config.from_object(app_config)
       # print(app.config)
   
       ## extension객체들로 app객체 초기화
       CORS(app)
   
       ## 필터 추가
       from src.main.templates.filters import feed_datetime, join_phone, join_birth, format_date, format_datetime, format_timedelta
       app.jinja_env.filters["feed_datetime"] = feed_datetime
       app.jinja_env.filters["join_phone"] = join_phone
       app.jinja_env.filters["join_birth"] = join_birth
       app.jinja_env.filters["format_date"] = format_date
       app.jinja_env.filters["format_datetime"] = format_datetime
       app.jinja_env.filters["format_timedelta"] = format_timedelta
   
   
       ## bp아닌 것들은 add_url_rule용
       from src.main.routes import (
           main_bp, index,
           api_routes_bp, auth_bp,
           admin_bp,
           util_bp,
           dept_bp,
       )
   
       app.register_blueprint(main_bp)
       app.register_blueprint(api_routes_bp)
       app.register_blueprint(auth_bp)
       app.register_blueprint(admin_bp)
       app.register_blueprint(util_bp)
       app.register_blueprint(dept_bp)
   
       # 기본 / url 지정 in route.py의 function
       app.add_url_rule('/', endpoint='index', view_func=index)
       from ..utils.upload_utils import download_file
       app.add_url_rule('/uploads/<path:filename>', endpoint='download_file', view_func=download_file)
   
       ## app context단위로 항상 떠있는 entity 객체value의 dict 반환 method 주입
       app.context_processor(inject_category_and_settings)
       app.context_processor(inject_today_date)
       # app.context_processor(inject_permission_and_roles)
       app.context_processor(inject_permission)
   
       ## [flask xxxx] 명령어 추가
       from src.main.utils import init_script
       init_script(app)
   
       return app
   
   
   def inject_category_and_settings():
       with DBConnectionHandler() as db:
           categories = db.session.scalars(
               select(Category)
               .order_by(Category.id.asc())
           ).all()
   
           settings = Setting.to_dict()
   
       return dict(
           categories=categories,
           settings=settings,
       )
   
   
   def inject_today_date():
       return {'today_date': datetime.date.today}
   
   
   # def inject_permission_and_roles():
   ## role Roles이넘을 이용해 user객체의 hybrid_property로 다 정해줌
   def inject_permission():
       return dict(
           Permission=Permission,
           # Roles=Roles,
       )
   
   ```

   



#### 프로젝트 환경변수 .env -> OS에 안세기고,  settings.py에서 load_dotenv로 꺼내먹기

- `.env`

  ```ini
  #### 비워둘거면 아예 주석처리해야 빈문자열이 안가서 python내부 default값이 적용된다.
  
  #### project####  
  # = upload_path를 비워두면, base + 'uploads/'를 업로드 폴더로 간주한다.
  # PROJECT_NAME=
  # PROJECT_VERSION=
  ADMIN_EMAIL='tingstyle1@gmail.com'
  # UPLOAD_PATH=
  
  
  
  #### DB #### 
  # = dev) DEV_DATABASE_URL을 따로 지정하지 않으면, base + DB_NAME or (DB_NAME주석처리시)data-dev.sqlite
  # = testing) TEST_DATABASE_URL 따로 지정하지 않으면, sqlite:///:memory:로 작동한다 
  # = prod) DB_CONNECTION를 주석처리시, base + DB_NAME or (DB_NAME주석처리시)data.sqlite
  # POST_PER_PAGE = 10
  # COMMENTS_PER_PAGE = 10
  
  # DEV_DATABASE_URL= # 생략시 base+ [DB_NAME.db or data-dev.sqlite]
  DB_NAME=tutorial3 # 생략시 base + data-dev.sqlite or data.sqlite 
  
  #### production + RDB적용시 #### 
  # DB_CONNECTION=mysql+pymysql # 생략시 sqlite로 돌아가며, base+ [DB_NAME.db or data-dev.sqlite]
  # DB_USER=root
  # DB_PASSWORD=564123
  # DB_HOST=0.0.0.0
  # DB_PORT=3306
  
  #### FLASK #### 
  SECRET_KEY = 'secret-key'
  
  
  #### jwt #### 
  # TOKEN_KEY=
  # EXP_TIME_MIN=
  # REFRESH_TIME_MIN
  ```

  

- settings.py

  ```python
  
  from dotenv import load_dotenv
  from flask import Flask
  
  dotenv_path = Path("./.env")
  load_dotenv(dotenv_path=dotenv_path)
  
  BASE_FOLDER = Path(__file__).resolve().parent.parent.parent  # root
  
  
  # fastapi 세팅 참고
  # https://github.com/heumsi/python-rest-api-server-101/blob/main/project/src/config.py
  class Project:
      # project
      PROJECT_NAME: str = os.getenv("PROJECT_NAME")
      PROJECT_VERSION: str = os.getenv("PROJECT_VERSION")
      # user생성시 role안넣은 상태에서, email이 정해진 email이면, 관리자 Role을 넣어준다.
      ADMIN_EMAIL: str = os.getenv("ADMIN_EMAIL")
  
  
  # path로 join만 하면 [마지막을 파일명으로 취급]하여 '/'가 없다.
  # -> 뒤에 개별폴더명이 붙을 joinpath라면 + '마지막 폴더명/'을 붙여서 연결하여, 다음엔 '/'없이 파일명 or 개별폴더명/파일명만 올 수 있도록 만든다.
  # UPLOAD_FOLDER = BASE_FOLDER.joinpath('uploads/')
  class ProjectDevConfig(Project):
      UPLOAD_FOLDER = BASE_FOLDER.joinpath('uploads/')
  
  
  class ProjectTestingConfig(Project):
      UPLOAD_FOLDER = BASE_FOLDER.joinpath('uploads/')
  
  
  class ProjectProdConfig(Project):
      UPLOAD_FOLDER = os.getenv('UPLOAD_FOLDER') \
                      or BASE_FOLDER.joinpath('uploads/')
  
  
  project_config = {
      'development': ProjectDevConfig,
      'testing': ProjectTestingConfig,
      'production': ProjectProdConfig,
  
      'default': ProjectDevConfig
  }
  project_config = project_config[os.getenv('APP_CONFIG') or 'default']()
  
  
  class DB:
      POST_PER_PAGE = int(os.getenv("POST_PER_PAGE", "10"))
      COMMENTS_PER_PAGE = int(os.getenv("COMMENTS_PER_PAGE", "20"))
  
  
  class DBDevConfig(DB):
      DATABASE_URL = os.environ.get('DEV_DATABASE_URL') or \
                     'sqlite:///' + os.path.join(BASE_FOLDER, f'{os.getenv("DB_NAME")}-dev.db' or "data-dev.sqlite")
  
  
  class DBTestingConfig(DB):
      DATABASE_URL = os.environ.get('TEST_DATABASE_URL') or \
                     'sqlite:///:memory:'
  
  
  class DBProductionConfig(DB):
      if os.getenv("DB_CONNECTION"):
          DB_CONNECTION = os.getenv("DB_CONNECTION").lower()
          DB_USER: str = os.getenv("DB_USER", "root")
          DB_PASSWORD = os.getenv("DB_PASSWORD", "root")
          DB_HOST = os.getenv("DB_HOST", "localhost")
          DB_PORT: str = os.getenv("DB_PORT", "3306")
          DB_NAME: str = os.getenv("DB_NAME", "test")
  
          DATABASE_URL = f"{DB_CONNECTION}://" \
                         f"{DB_USER}:{DB_PASSWORD}@" \
                         f"{DB_HOST}:{DB_PORT}/" \
                         f"{DB_NAME}"
      else:
          DATABASE_URL = 'sqlite:///' + os.path.join(BASE_FOLDER, f'{os.getenv("DB_NAME")}.db' or "data.sqlite")
  
  
  db_config = {
      'development': DBDevConfig,
      'testing': DBTestingConfig,
      'production': DBProductionConfig,
  
      'default': DBDevConfig
  }
  db_config = db_config[os.getenv('APP_CONFIG') or 'default']()
  
  #...
  ```





### 라이트세일 사용 및 pycharm 접속

1. 한국어로 바꾸기

   ![image-20230207010848918](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207010848918.png)

2. OS전용 ubuntu 20.04 LTS 선택

3. 월 5달러, 1GB 메모리를 선택

4. 네트워킹 > **고정IP(탄력적IP) 생성** > 인스턴스 연결

   1. 3달간 무료로 사용할 수 있고 이후엔 비용이 발생한다. 이를 원치 않는다면 인스턴스와 고정 IP를 삭제해야 한다. 인스턴스는 다음처럼 AWS 라이트세일 홈페이지 화면의 [인스턴스] 탭에서 삭제할 수 있다
   2. 고정 IP는 다음처럼 [네트워킹] 탭에서 삭제할 수 있다.

5. 80번, 22번외 포트(flask 5000) 방화벽 해제

   1. 인스턴스 선택 > 네트워킹 > 규칙 추가 > 5000번 생성

6. key 페어 다운로드

   1. 계정 > 계정지원 > SSH 키 > 하단에 다운로드

      ![image-20230207011957479](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207011957479.png)

      ![image-20230207012007577](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207012007577.png)

   2. **프로젝트명.pem**으로 파일명 변경 후 > `C:\Users\{계정명}\.ssh`에 옮겨준다

      ![image-20230207012202157](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207012202157.png)

   3. pycharm에서 SSH로 접속하기(**putty는 pem -> .ppk로 generate과정 필요**)

      1. 설정 > SSH configurations

      2. Host에는 ip입력 / port는 22 그대로

      3. Username: 운영체제계정명 `ubuntu`

      4. 인증타입 : Key pair

      5. Private key file : `c:\Users\{계정명}\.ssh\`

      6. test Connection 성공후 이름바꿔주기

         ![image-20230207012924993](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207012924993.png)

      7. Tools > new SSH connection으로 실행 or `화살표 2개의 new predefined session`에서 실행

         ![image-20230207013655333](C:\Users\is2js\AppData\Roaming\Typora\typora-user-images\image-20230207013655333.png)

         ![image-20230207013537745](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207013537745.png)



#### ubuntu 초기 설정

##### hostname 변경

1. host명을 ip대신 다른 것으로 변경하기

   ```shell
   sudo hostnamectl set-hostname chojaeseong
   
   sudo reboot
   ```

   ```shell
   ubuntu@chojaeseong:~$ hostname
   
   chojaeseong
   ```

   



##### 서버 시간(localtime) 설정

- [ln관련 블로그](https://leechwin.tistory.com/entry/Ubuntu-ln-%EB%AA%85%EB%A0%B9%EC%9C%BC%EB%A1%9C-%EB%A7%81%ED%81%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0)

- ln `-s`(심볼릭not하드링크)`f`(foce, remove 기존 목적지파일) 

  - 서버의 로컬타임을 담당하는 link인 `/etc/localtime`은 **원본을 /UTC로 보고있다**

    ```shell
    ll /etc/localtime
    
    lrwxrwxrwx 1 root root 27 Jul 16  2020 /etc/localtime -> /usr/share/zoneinfo/Etc/UTC
    ```

    ```shell
    date
    
    Mon Feb  6 16:56:07 UTC 2023
    ```

  - **/etc/localtime의 링크를 Asia/Seoul로 걸어주면, `date(서버 localtime)`이 아시아로 바뀐다.**

    ```shell
    sudo ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime
    ```

    ```shell
    ll /etc/localtime
    
    lrwxrwxrwx 1 root root 30 Feb  7 01:56 /etc/localtime -> /usr/share/zoneinfo/Asia/Seoul
    ```

    ```shell
    date
    
    Tue Feb  7 01:57:04 KST 2023
    ```

    

##### python설치 확인

```shell
ubuntu@chojaeseong:~$ python

ubuntu@chojaeseong:~$ python3

ubuntu@chojaeseong:~$ python3 --version
Python 3.8.2
```





##### root용 가상환경 패키지 설치

1. 우분투 패키지 업데이트

   ```shell
   sudo apt update
   ```

   

2. 가상환경 생성 패키지(`python3-venv`)를 우분투 apt install로 설치

   ```shell
   sudo apt install python3-venv
   ```

   



#### 소스폴더 vs 가사환경폴더 분리해서 가상환경 생성하기

- 소스폴더 : `~/projects`

- 가상환경폴더 : `~/venvs`

  ```shell
  ubuntu@chojaeseong:~$ mkdir projects
  ubuntu@chojaeseong:~$ mkdir venvs
  ubuntu@chojaeseong:~$ ls
  projects  venvs
  
  ```

  

##### venvs에 프로젝트명으로 가상환경 생성 및 활성화

```shell
ubuntu@chojaeseong:~/venvs$ python3 -m venv sqlalchemy
ubuntu@chojaeseong:~/venvs$ ls
sqlalchemy


 . ~/venvs/sqlalchemy/bin/activate
 # 혹은
 source ~/venvs/sqlalchemy/bin/activate
```



###### 가상환경에 오류방지 wheel 패키지 설치

```shell
pip install wheel
```





### projects폴더에 git clone(SSH)하기

#### ubunut sshkey 생성 후 -> github 계정 설정에 ssh key 등록하기

1. `cd ~/.ssh`로 이동

   ```shell
   cd ~/.ssh
   ```

2. ssh-keygen 명령어를 -t -b 알고리즘 옵션과 함께 -C 커맨트에 github 메일을 입력한다

   ```shell
   ssh-keygen -t rsa -b 4096 -C "tingstyle1@gmail.com"
   ```

3. 생성된 `id_rsa.pub` 버플릭키를 `cat`명령어로 터미널에 찍어 복붙 준비를 한다.

   ```shell
   cat cd ~/.ssh/id_rsa.pub
   ```

4. **github 계정의 settings** > SSH and GPG keys > `New SSH key`에 생성한 키를 등록한다.

   ![image-20230207042350187](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207042350187.png)

   ![image-20230207042413978](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207042413978.png)



#### ssh기반으로 repo clone하기

1. 프로젝트 폴더로 이동

   ```shell
   cd ~/projects
   ```

   

2. github repo **SSH clone**을 하며 **git clone [ssh주소] `[gitrepo명 대신 new 폴더명]`를 반드시 추가한다.**

   - projects/ `생성폴더`/ 소스코드들

   ```shell
   git clone git@github.com:is2js/2022_sqlalchemy.git sqlalchemy
   
   (sqlalchemy) ubuntu@chojaeseong:~/projects$ ls
   sqlalchemy
   
   
   cd sqlalchemy/
   ls
   ```





##### clone후 초기작업 requirements.txt 설치하기 -> install전에 pip install로 pip도 업그레이드

```shell
pip install --upgrade pip
pip install -r requirements.txt
```



- `pywin32==400`설치 오류 -> **윈도우 관련모듈이므로 주석처리했다.**



#### flask 실행환경변수 직접 입력 + flask create_db 후 --host/--port는 옵션으로 실행

```shell
export FLASK_APP=manage.py
export FLASK_DEBUG=true

flask create_db
```

- DB_NAME 환경변수가 없는 개발모드는 `data-dev.db`라는 sqlite DB를 만든다.

```shell
ls -rlt

-rw-r--r-- 1 ubuntu ubuntu 176128 Feb  7 04:56 data-dev.db
```

- 참고) flask-sqlalchemy + flask-migrate로 진행했다면

  ```python
  flask db init
  flask db migrate
  flask db upgrade
  ```

  

- flask 실행

  - `--host=0.0.0.0` 옵션 없으면, local내부에서만 접속이라, **외부공인ip:5000으로 접속불가**

  ```shell
  (sqlalchemy) ubuntu@chojaeseong:~/projects/sqlalchemy$ flask run
   * Serving Flask app "manage.py" (lazy loading)
   * Environment: development
   * Debug mode: on
   * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
   * Restarting with stat
  
  ```

  - **--host + --port 옵션주고 실행**

  ```shell
  (sqlalchemy) ubuntu@chojaeseong:~/projects/sqlalchemy$ flask run --host=0.0.0.0 --port=5000
   * Serving Flask app "manage.py" (lazy loading)
   * Environment: development
   * Debug mode: on
   * Running on all addresses.
     WARNING: This is a development server. Do not use it in a production deployment.
   * Running on http://172.26.7.177:5000/ (Press CTRL+C to quit)
   * Restarting with stat
  
  
  template_dir: /home/ubuntu/projects/sqlalchemy/src/main/templates
  static_dir: /home/ubuntu/projects/sqlalchemy/src/main/static
  config_name>>> default
   * Debugger is active!
   * Debugger PIN: 803-290-657
  template_dir: /home/ubuntu/projects/sqlalchemy/src/main/templates
  static_dir: /home/ubuntu/projects/sqlalchemy/src/main/static
  config_name>>> default
  
  ```

  - 환경변수에 APP_CONFIG를 지정안해줘서, default -> development 모드로 돌아간다
  - template과 static 폴더의 경로를 찍어놔서 나중에 배포설정에서 활용하면 좋을 듯 하다.





##### flask create_db 이외에, 기본 DB(Role 및 관리자 계정) 생성 하기

- 실행된 flask를 접속했더니 role 기본 DB가 없다고 나온다.

  ![image-20230207051850319](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207051850319.png)

- 관리자 계정도 없을 것이다.

```shell
(sqlalchemy) ubuntu@chojaeseong:~/projects/sqlalchemy$ flask create_role
template_dir: /home/ubuntu/projects/sqlalchemy/src/main/templates
static_dir: /home/ubuntu/projects/sqlalchemy/src/main/static
config_name>>> default
기본 Role들을 python으로 생성합니다.
초기 Role 테이블 데이터들이 생성되었습니다.


(sqlalchemy) ubuntu@chojaeseong:~/projects/sqlalchemy$ flask create_admin_user
template_dir: /home/ubuntu/projects/sqlalchemy/src/main/templates
static_dir: /home/ubuntu/projects/sqlalchemy/src/main/static
config_name>>> default
Username: admin
Password: 
Repeat for confirmation: 
관리자 계정을 생성합니다.
관리자 계정 [admin]이 성공적으로 생성되었습니다.
(sqlalchemy) ubuntu@chojaeseong:~/projects/sqlalchemy$ 

```



- 다시 띄운 뒤 관리자 계정으로 접속하기

```flask shell
 flask run --host=0.0.0.0 --port=5000
```





##### 오류 수정: pychart에서, user가 없을 때, user정보로 그래프 그리는 부분



![image-20230207052431254](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207052431254.png)

- **각 chart가 None으로 인식되는 것 같아서, 일단 옵션 제거함.**



##### 오류 체크

- ~~leader도 .avatar가 존재할 때, 이미지 보이게 하기~~

  - 조건문 추가해서 해결

  ![image-20230207054633419](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207054633419.png)

  

- ~~setting_form에 default 색 흰색말고 다른 색으로~~

  ```js
  app._data.selectedColor = "{{ form.theme_color.data or '#ffffff'}}"
  
  //#7957d5으로 변경
  ```

  

- ~~기본로고 지정해놓기?~~

  - base.html에서 settings.logo가 없으면, statiac 기본 logo.png를 우아한 한의원 로고 지정해놓기

- this.depts빼기

  - ~~부서장 해임시 this.depts에 반영되어야.. 부서 삭제가 된다.~~

    - 부서장 해임시 **this.selectedDept.has_direct_leader = false;** 추가하여 해결

    ![image-20230208155102373](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208155102373.png)

- 카테고리 -> 게시판으로 바꾸기

- 

  



#### flask 실행환경변수 + 가상환경 실행까지 포함하는 배치파일 만들어, flask run으로만 실행하게 하기

##### flask실행 환경변수 관련

1. app.config안에 있는 `ENV` 속성은 from_object로 안바꿔진다.
   - 끽해야 `DEBUG` , `TESTING` 정도만 조절된다
   - **wsgi실행시 필욘 없지만, `APP_CONFIG` for 프로젝트 환경변수의 값을 그대로 이어받아 `FLASK_APP`에도 넣어주도록 설정한다.**



##### OS별 환경변수 

1. `ps1`과 달리 `cmd`배치파일은 문자열`''`따옴표를 안받는다.
   - **환경변수 선언**
     - ps1: `export $env:{변수}={'값'}`
     - cmd: `set {변수}={값}`
     - sh: `export {변수}={값}`
   - **환경변수 사용**
     - ps1: `$env:{변수}`
     - cmd: `%{변수}%`
       - `echo %{변수}%`
     - sh: `${변수}`
       - `$echo ${변수}`
   - **환경변수 list 보기**
     - ps1 : `gci env:` `gci env:{*flask*}` `gci env: | ? Name -match "flask" | sort Name`
     - cmd: `set` `set | findstr /i {flask}`
     - sh: `export` `env`  `printenv` `printenv | grep -i {flask}`
   - **환경변수 제거**
     - ps1: `ri env:/{변수명}`
     - cmd: `set {변수명}=` 
       - 빈값으로 null을 주면 지워진다.
     - sh: `unset {변수명}`

##### 로컬용 .cmd / .ps1 by development

- 로컬에서는 가상환경이 바로 해당 폴더에 있으니, cd 없이 가상환경 실행만 한다

  - `run.cmd`

  ```shell
  @echo off
  
  :: development / testing / production / default
  set APP_CONFIG=production
  set FLASK_APP=manage.py
  
  set FLASK_ENV=%APP_CONFIG%
  set FLASK_RUN_HOST=localhost
  set FLASK_RUN_PORT=5000
  
  .\venv\Scripts\activate
  ```

  - `run.ps1`

  ```shell
  # development / testing / production / default
  $env:APP_CONFIG='development'
  $env:FLASK_APP='manage.py'
  
  $env:FLASK_ENV=$env:APP_CONFIG
  $env:FLASK_RUN_HOST='localhost'
  $env:FLASK_RUN_PORT='5000'
  
  ./venv/Scripts/activate
  ```

  

##### 서버용 .sh by production

- `run.sh`

  ```shell
  #!/bin/bash
  
  # 프로젝트 폴더로 이동
  cd ~/projects/sqlalchemy
  
  # development / testing / production / default
  export APP_CONFIG=production
  export FLASK_APP=manage.py
  
  export FLASK_ENV=$APP_CONFIG
  export FLASK_RUN_HOST=0.0.0.0
  export FLASK_RUN_PORT=5000
  
  # 가상환경 위치 + 실행까지
  . ~/venvs/sqlalchemy/bin/activate
  ```





##### mac이라면 .sh대신 alias로 처리한다

```shell
[파일명: /Users/pahkey/.zshrc]

alias {프로젝트명}='export FLASK_APP=pybo;export FLASK_DEBUG=true;export APP_CONFIG=ㅇdevelopment;cd /Users/pahkey/projects/myproject;. /Users/pahkey/venvs/myproject/bin/activate'
```





##### 스크립트 실행후 flask run만

- 로컬

  ```shell
  (venv) PS C:\Users\is2js\pythonProject\2022_sqlalchemy> .\run.ps1
  
  (venv) PS C:\Users\is2js\pythonProject\2022_sqlalchemy> flask run
  ```

- 서버

  ```shell
  (sqlalchemy) ubuntu@chojaeseong:~/projects/sqlalchemy$ git pull
  
  (sqlalchemy) ubuntu@chojaeseong:~/projects/sqlalchemy$ deactivate
  # . run.sh  OR source run.sh
  ubuntu@chojaeseong:~/projects/sqlalchemy$ . run.sh 
  (sqlalchemy) ubuntu@chojaeseong:~/projects/sqlalchemy$ flask run
  
  ```

  



### 서버에서 wsgi 적용

#### 개념

- `flask run`은 내장서버 실행

- `.js` `.css` `.이미지파일들`은 모두 정적 페이지 요청

- DB의 내용에 따라 수시로 바뀌는 동적 페이지 요청

  - 웹 서버에 정적 페이지 요청을 하면 단순히 정적 파일을 찾아 응답하면 되지만, 동적 페이지 요청은 조금 복잡한 과정을 거쳐 응답한다.

- **동적 페이지 요청을 완벽하게 처리하려면 `웹 서버`와 `WSGI 서버`가 필요하다**

  - 대부분의 **웹 서버(nginx)는 어떻게 파이썬 프로그램을 호출해야 하는지 모르**므로 파이썬 프로그램을 호출하지 못한다. 
  - 이런 경우에는 **파이썬 프로그램을 호출하는 WSGI**(web server gateway interface) 서버가 필요하다. 웹 서버는 WSGI 서버를 호출하고, WSGI 서버는 파이썬 프로그램을 호출하여 동적 페이지 요청을 처리하는 것
    - WSGI는 위스키라고 읽는다

- **WSGI 서버**에는 여러 종류가 있지만 `Gunicorn`과 `uwsgi`를 가장 많이 사용한다.  Gunicorn을 사용할 것이다.

  - **웹 서버로 들어온 동적 페이지 요청**은 **WSGI 서버를 호출**한다. 그리고 **WSGI 서버는 WSGI 애플리케이션을 호출**하여 동적 페이지 요청을 처리한다. 어떻게 보면 동적 페이지 요청은 결국 WSGI 애플리케이션이 처리하는 것이다. **WSGI 애플리케이션에는 장고, 플라스크** 등이 있다.

    - WSGI 서버는 웹 서버와 WSGI 애플리케이션 중간에 위치한다. 그래서 **WSGI 서버는 WSGI 미들웨어(middleware) 또는 WSGI 컨테이너(container)**라고도 한다.

    ![image-20230207171208528](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207171208528.png)

  - **웹 브라우저의 정적 페이지 요청은 웹 서버**가, **동적 페이지 요청은 `[WSGI서버 > WSGI 애플리케이션]`이 처리**한다. 



#### wsgi Gunicorn 설치 및 port로 실행

1. 가상환경에서 pip로 설치

   ```python
   pip install gunicorn
   ```

2. **프로젝트의 root폴더(sqlalchemy)로 가서, 실행**

   - **실행 전, 최초 production모드면, 그에 따른 db를 생성하고 가야한다.**

     ```python
     flask create_db
     flask create_role
     flask create_admin_user
     ```

     

   - 실행시 `--bind 0:5000`에서 5000이 flask의 접속port

   - 실행시 문자열로 `"{FLASK_APP모듈명}:{app객체생성팩토리메서드}"`를 입력하는데 **우리는 팩토리메서드에 동작환경을 인자로 명시해서 썼다**

     ```python
     app = create_app(os.getenv('APP_CONFIG') or 'default')
     ```

   ```shell
   cd ~/projects/sqlalchemy/
   
   gunicorn --bind 0:5000 "manage:create_app('production')"
   ```

   

##### 파이썬 프로그램 실행용 미들웨어 wsgi(gunicorn)의 한계

- 다시 말하지만 **Gunicorn은 파이썬 프로그램을 실행하는 WSGI 서버**이다. 그래서 **정적 파일을 처리하는 데는 적합하지 않다**.  `bootstrap.min.css`, `bootstrap.min.js`, `style.css`와 같은 정적 파일들이 있다. **정적 파일을 효과적으로 처리하는 웹 서버**가 필요하다. 아무튼 Gunicorn이 정상으로 동작하는 것을 확인했으므로 `<Ctrl>+C`를 눌러 Gunicorn을 종료하자.



#### wsgi gunicorn 유닉스 sock으로 실행

- Gunicorn은 앞에서 본 것처럼 포트를 이용하여 서버를 띄운다. 하지만 Unix 계열 시스템에서는 포트로 서비스하기보다는 유**닉스 소켓(Unix Socket)을 사용하는 것이 빠르고 효율적**이다. 이번에는 Gunicorn을 유닉스 소켓으로 서비스하는 방법을 알아보자

  -  **즉, `--bind unix:/tmp/myproject.sock` 부분이 다르다. 기존에는 `--bind 0:5000`와 같이 입력했지만 유닉스 소켓 방식은 `--bind unix:/tmp/{프로젝트명}.sock`와 같이 입력했다.**

  ```shell
  gunicorn --bind unix:/tmp/sqlalchemy.sock  "manage:create_app('production')"
  ```

- **실행은 되지만 접속은 안된다. port를 bind 하지 않고 있기 때문에, 브라우저 :5000접속을 받아주지 못한다.**

![image-20230207173709928](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207173709928.png)

##### wsgi 소켓실행시, 웹서버(nginx)가 port를 열고, 해당 소켓으로 연결해줘야 접속할 수 있다.

- **유닉스 소켓 방식으로 Gunicorn 서버를 실행하면 단독으로 Gunicorn 서버에 접속하여 실행해 볼 수 없다.** **유닉스 소켓 방식으로 실행한 Gunicorn 서버는 Nginx와 같은 웹 서버에서 유닉스 소켓으로 WSGI 서버에 접속하도록 설정**해야 한다.

- 유닉스 소켓으로 실행시에만 해당 소켓파일을 **또다른 터미널로 열어서 확인할 수 있다.**

  ```shell
  ubuntu@chojaeseong:~$ ls -rlt /tmp
  total 20
  #...
  srwxrwxrwx 1 ubuntu ubuntu    0 Feb  7 17:38 sqlalchemy.sock
  
  ```

  



#### wsgi를 서버 서비스로 등록하기

- 서비스로 등록헤야 **Gunicorn의 시작, 중지를 쉽게 하고 또 AWS 서버를 다시 시작할 때 Gunicorn을 자동으로 실행**하기 위해서이다. Gunicorn을 **서비스로 등록하려면 `(.sh로 실행환경변수 입력이 아닌) 실행환경 변수 파일(.env)`과 `서비스 파일`을 작성**해야 한다.
  - 나는 환경변수를 이미 팩토리메서드에 입력하면, 알아서 되도록 작성해놔서 지금 안해도 된다.



##### [서버전용] (.sh -> flask run용)이 아닌, [gunicorn실행시 설정파일에 연동될 flask실행환경변수 파일] {프로젝트명.env} 파일 만들기

- **기존 `run.sh(프로젝트폴더 이동 + flask실행환경변수 + 가상환경 실행)` + `flask run`의 과정을**
  - **`flask실행환경변수.env파일` + `gunicorn 서비스파일(flask 실행환경변수 적용 + 가상환경의 gunicorn으로 flask run대체)`로 바뀐다.**
    - **FLASK_RUN_HOST와 FLASK_RUN_PORT가 unix소켓제공으로 빠지게 된다.**

1. **venvs폴더로 가서, `프로젝트명.env`를 만들고 , flask_run_host, flask_run_port를 제외한 `APP_CONFIG`(for default), `FLASK_APP` , `FLASK_ENV`를 기입한다**

   ```shell
   (sqlalchemy) ubuntu@chojaeseong:~/projects/sqlalchemy$ cd ~/venvs/
   (sqlalchemy) ubuntu@chojaeseong:~/venvs$ ls
   
   sqlalchemy
   ```

   - `sqlalchemy.env`

   ```shell
   APP_CONFIG=production
   FLASK_APP=manage.py
   
   FLASK_ENV=production
   ```

   ```shell
   (sqlalchemy) ubuntu@chojaeseong:~/venvs$ ls
   sqlalchemy  sqlalchemy.env
   
   ```

##### 서비스 파일 작성하기 in /etc/systemd/system/프로젝트명.service

- 프로세스를 2개로 지정한 이유는 여러분이 선택한 `월 사용료 5달러` 사양의 서버에는 프로세스 개수가 이 정도가 적당하기 때문이다.

```shell
ls  /etc/systemd/system/
```

![image-20230207195056716](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207195056716.png)

```shell
sudo nano  /etc/systemd/system/sqlalchemy.service
```



- `sqlalchemy.service`

  - **ExecStart에 실행명령어를 `gunicorn이 설치된 가상경로의 절대경로 실행`해주면 된다.**
    - 프로세스를 2개로 지정한 이유는 여러분이 선택한 `월 사용료 5달러` 사양의 서버에는 프로세스 개수가 이 정도가 적당하기 때문이다.

  ```ini
  [Unit]
  Description=gunicorn daemon
  After=network.target
  
  [Service]
  User=ubuntu
  Group=ubuntu
  WorkingDirectory=/home/ubuntu/projects/sqlalchemy
  EnvironmentFile=/home/ubuntu/venvs/sqlalchemy.env
  ExecStart=/home/ubuntu/venvs/sqlalchemy/bin/gunicorn \
          --workers 2 \
          --bind unix:/tmp/sqlalchemy.sock \
          "manage:create_app('production')"
  
  [Install]
  WantedBy=multi-user.target
  
  ```



##### 서비스 실행 및 명령어

1. 서비스 파일 존재 확인

   - 서비스 파일들은 `/etc/systemd/system`에 `.service`파일로 작성해놓는다.

   ```shell
   ls  /etc/systemd/system/
   ```

2. 서비스 일반 실행

   ```shell
   sudo systemctl start sqlalchemy.service
   ```

3. 서비스 오류시 서비스 로그 확인

   - 서비스의 에러들은 `/var/log/syslog`에 찍히나보다.

   ```shell
   tail -f /var/log/syslog 
   ```

4. 서비스 실행 상태 확인

   ```shell
   sudo systemctl status sqlalchemy.service
   ```

5. 서비스 종료

   ```shell
   sudo systemctl stop sqlalchemy.service
   ```

6. 서비스 재부팅시 매번 재실행

   ```shell
   sudo systemctl enable sqlalchemy.service
   ```

   

### 서버에서 nginx(웹서버) 적용

1. 설치

   ```shell
   sudo apt install nginx
   ```



#### 설정 파일 경로 확인 및 생성

1. **설정파일 생성 경로 확인 및 생성**

   - nginx설정파일은 `/etc/nginx/sites-available/`에 생성해놓는다.
   - 최초에는 `default` 파일 밖이며 **파일들의 확장자는 없다.**

   ```shell
   ls /etc/nginx/sites-available/
   ```



2. **확장자 없는 `sqlalchemy` 설정 파일 생성**

   ```shell
   sudo vi /etc/nginx/sites-available/sqlalchemy
   ```

   

3. `sqlalchemy` 파일 작성

   - wsgi(gunicorn)+ wsgi 어플리케이션(flask)은 소켓으로만 돌아가고 **nginx가 80번 포트로 받아 동적웹페이지 요청을 `/`으로 받아준다.**
     - **location `/`에 더 위에 작성한 `/static`을 제외한 `모든 요청`을 `소켓에 연결된 wsgi unicorn으로 요청을 넘긴다`는 의미이다**
       - **`proxy_pass`에 `http://`를 붙인 `wsgi로 돌아가는 sock을 연결`해준다.**
     - **nginx는 사실상 `location /static`만 처리한다**
   - **`server_name`에는 host_name인 `고정ip`를 프로토콜 없이 입력해준다.**
   - `/static`에는 `alias`로서 **절대경로 프로젝트의 static폴더까지 입력해준다.**
     - **nginx가 처리해야할 모든 static요청을 `location /static`블럭에 기입해준다**
       - `/static` 요청은 Nginx가 처리(정적 요청)
       - **`/static` 요청 이외의 요청은 모두 Gunicorn이 처리(동적 요청)**

   ```ini
   server {
           listen 80;
           server_name 52.79.232.206;
   
           location = /favicon.ico { access_log off; log_not_found off; }
   
           location /static {
                   alias /home/ubuntu/projects/sqlalchemy/src/main/static;
           }
   
           location / {
                   include proxy_params;
                   proxy_pass http://unix:/tmp/sqlalchemy.sock;
           }
   }
   
   ```



#### site-available에 작성한 설정파일들중, site-enabled(링크 관리 디렉터리)에서 링크 활성화하여 설정 선택하기

1. **avalable안에 있는 설정파일을 `site-enabled`디렉토리로 ln -s 심볼릭링크를 걸어야하므로, 걸어줄 위치를 생략하기 위해 `site-enabled`폴더로 이동한다**

   - sites-enabled 디렉터리는 **site-available 디렉터리에 있는 설정 파일 중에서 활성화하고 싶은 것을 링크로 관리하는 디렉터리**이다.

   ```shell
   cd /etc/nginx/sites-enabled/
   ls 
   
   sudo ln -s /etc/nginx/sites-available/sqlalchemy 
   ```

   ```shell
   ubuntu@chojaeseong:/etc/nginx/sites-enabled$ ls
   default  sqlalchemy
   ```

2. **기존 기본설정 활성화 링크 삭제** 

   ```shell
   sudo rm default
   
   ubuntu@chojaeseong:/etc/nginx/sites-enabled$ ls
   sqlalchemy
   ```

3. **nginx 서비스 재시작**

   - 설치하면 기본적으로 서비스가 실행되어있음

   ```shell
   ubuntu@chojaeseong:/etc/nginx/sites-enabled$ sudo systemctl restart nginx
   ```

4. **nginx 세팅확인 `-t`**

   ```shell
   ubuntu@chojaeseong:/etc/nginx/sites-enabled$ sudo nginx -t
   
   nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
   nginx: configuration file /etc/nginx/nginx.conf test is successful
   ```

5. 포트80 생략하고 접속해보기

6. nginx 서비스 상태확인 / stop / 시작

   ```shell
   sudo systemctl status nginx
   sudo systemctl stop nginx
   sudo systemctl start nginx
   ```





### Prod 모드일때의 debug를 위한 오류페이지/로깅

#### HTTP ERROR 핸들링 in local to server

1. local에서 서버 실행

   ```powershell
   (venv) PS C:\Users\is2js\pythonProject\2022_sqlalchemy> .\run.ps1
   (venv) PS C:\Users\is2js\pythonProject\2022_sqlalchemy> flask run
   ```

2. 없는 route로 입장

   http://127.0.0.1:5000/asdf

   ![image-20230207211845347](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207211845347.png)

3. **팩토리메서드 or app객체를 가진  `config/__init__.py`에서**

   1. 해당 not found 에러에 대한 **render_template(''), status_code**를 **return해주는 메서드**를 정의한다

      - **이 때, 2번째 반환 status_code가 반드시 전달되어야지, app객체 등록 register_error_handler( , method) 전달시 200코드가 아닌 404코드로 간다.**

      ```python
      # config/__init__.py
      
      #...
      from flask import Flask, render_template
      #...
      
      # 에러 핸들링
      def page_not_found(e):
          return render_template('404.html'), 404
      
      def create_app(config_name='default'):
      
      ```

   2. **tempalte폴더 하위에 erros를 만들고, 404.html페이지를 추가한다.**

      ![image-20230207212501533](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207212501533.png)

      - **base.html을 상속하여 not found 페이지를 만든다.**

      ```html
      {% extends 'base.html' %}
      
      {% block title %}
      페이지를 찾을 수 없습니다
      {% endblock title %}
      
      {% block hero %}
      {% endblock hero %}
      
      {% block box %}
      <div class="container">
          <div class="columns is-flex is-justify-content-center">
              <div class="is-12 has-text-centered">
                  <span class="is-block mt-6 is-size-3">404 Error !!</span>
                  <div class="m-4 is-size-6">페이지를 찾을 수 없습니다.</div>
                  <a href="/" class="tag m-6">홈으로 돌아가기</a>
              </div>
          </div>
      </div>
      {% endblock box %}
      
      ```

      

   3. **app객체의 `.register_error_handler( code, function )`으로 등록해준다.**

      ```python
      ## 오류페이지 등록
      app.register_error_handler(404, page_not_found)
      
      return app
      ```

   4. **통합해서, 에러코드마다, .code, .description을 template에 반환하도록 처리해보기**

      ```python
      ## 에러 핸들링
      # def page_not_found(e):
      def render_error(e):
          # print(dir(e))
          # 'args', 'code', 'description', 'get_body', 'get_description', 'get_headers', 'get_response', 'name', 'response', 'with_traceback', 'wrap']
          # print(e.code) # 404
          # print(e.description) # The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.
      
          return render_template(
              'errors/http_errors.html',
              status_code=e.code,
              description=e.description), e.code
      ```

      ```python
          ## 오류페이지 등록
          app.register_error_handler(404, render_error)
          app.register_error_handler(500, render_error)
      
          return app
      ```

      ![image-20230207214316657](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207214316657.png)

   5. 만약, jsonify 등 커스텀한다면 [여길 참고](https://stackoverflow.com/questions/70277729/registered-error-handler-in-python-flask-application-does-not-work)

   6. **서버에 push한 뒤, pull해서 반영하기**

      1. **git pull이후에는 `wsgi(Gunicorn) 서비스만 재시작`하면 된다.**

      ```shell
      git pull
      
      sudo systemctl restart sqlalchemy.service
      ```

      

      ![image-20230207214618592](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207214618592.png)

#### 예상치 못한 not http ERROR 발생시켜서 확인해보기

##### local에선 DEBUG=True시 브라우저에서 오류가 확인되지만, server DEBUG=False에선 Internal Server Error로 예상치 못한 Error의 확인 불가

1. local main_route.py의 index에 ZeroDivision에러를 내보자

   ```python
   @main_bp.route("/")
   def index():
       # 예상치못한 not http error
       3/0 # 강제 에러 발생
       #...
   ```

   - 로컬시 에러

     ![image-20230207231019988](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207231019988.png)

   - 서버에 push-pull에서 확인

     ```shell
     git pull
     sudo systemctl restart sqlalchemy.service
     ```

     ![image-20230207231140367](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207231140367.png)



##### 서버에서 예상치못한 not http error 때문에 DEBUG=True로 돌릴 수도 없다 ->로그 파일로 확인한다.

- **"Internal Server Error"가 표시되면 어떤 오류가 발생한 것인지 알 수 없다**. 

  - 그렇다고 해서 오류를 화면에 표시하기 위해 플라스크 설정을 `FLASK_DEBUG=true`로 변경할 수도 없는 노릇이다.

  > 앞에서 우리는 보안 문제 때문에 FLASK_DEBUG를 운영 환경에 맞도록 설정했다.

- **이런 상황에서 구세주는 로그 파일**이다. "그냥 화면에 정확한 오류를 출력하면 되지 않을까?"라고 생각할 수도 있다. 하지만 **운영 환경은 여러 사람이 사용하므로 화면에 오류를 보여 주는 방법은 적당하지 않다.** **만약 A의 오류내용을 확인하려면 운영자가 A로 로그인한 다음 같은 방법으로(오류가 발생했던 방법으로) 사용**해야 하는데, **이 역시 적당하지 않기 때문**이다. 그래서 보통 **운영 환경에서는 오류 식별을 위해 로그 파일을 생성하여 확인하는 방법**을 사용한다. 여기서는 운영 환경에서 오류가 발생하면 특정 파일에 로그를 기록하는 방법을 알아본다.



#### Flask Prod환경에 대해서 로그 파일저장을 위한 logging 적용하기

##### local의 run.ps1을 production으로 바꿔서 설정 시작하기

1. `run.ps1`

   ```ini
   # development / testing / production / default
   $env:APP_CONFIG='production'
   #...
   ```

2. prod에 따른 db / role객체 / adminuser만들어야 접속됨

   ```shell
   flask create_db
   flask create_role
   flask create_admin_user
   ```



##### src/config/settings.py에  prod일 때만, loggin에 설정하기

```python
# src/config/settings.py

#...


if os.getenv('APP_CONFIG') == 'production':
    # Prod 환경일때만, 로깅 폴더 만들고 적용하기
    # 1) Prod에서 로그폴더 자동 생성
    LOG_FOLDER = os.path.join(BASE_FOLDER, 'logs/')
    if not os.path.exists(LOG_FOLDER):
        os.mkdir(LOG_FOLDER)

    # 1) logging 설정
    dictConfig({
        'version': 1, # 1 고정값 사용. 버전무관하게 만들어주는 안전장치
        'formatters': {
            # 출력형식 : 현재시간 / 로그레벨 / 로그호출 모듈명 / 출력내용
            'default': {
                'format': '[%(asctime)s] %(levelname)s in %(module)s: %(message)s',
            }
        },
        'handlers': {
            # 출력 방법 -> file로
            'file': {
                # 출력 로그 레벨 설정: 그 이상 레벨을 다 출력한다. (DEBUG < INFO < WARNING < ERROR < CRITICAL)
                # => logging.debug, logging.info, logging.warning, logging.error, logging.critical 함수 중 logging.debug는 출력안될 것이다.
                # - 1단계 DEBUG: 디버깅 목적으로 사용
                # - 2단계 INFO: 일반 정보를 출력할 목적으로 사용
                # - 3단계 WARNING: 경고 정보를 출력할 목적으로(작은 문제) 사용
                # - 4단계 ERROR: 오류 정보를 출력할 목적으로(큰 문제) 사용
                # - 5단계 CRITICAL: 아주 심각한 문제를 출력할 목적으로 사용
                'level': 'INFO',
                # 로그핸들러 class지정.
                # - RotatingFileHandler는 파일크기가 설정한 값보다 커지면 파일 뒤에 인덱스를 붙여 백업. RotatingFileHandler의 장점은 로그가 무한히 생겨도 파일 개수를 일정하게 유지(rolling)하므로 "로그 파일이 너무 커져서 디스크가 꽉 차는 위험"을 방지
                'class': 'logging.handlers.RotatingFileHandler',
                'filename': os.path.join(LOG_FOLDER, f'{project_config.PROJECT_NAME}.log'),
                'maxBytes': 1024 * 1024 * 5,  # 5 MB
                # maxBytes을 넘어설 때 최대 만들 로그파일 갯수.
                'backupCount': 5,
                'formatter': 'default',
            },
        },
        # 최상위 로거 설정
        'root': {
            'level': 'INFO',
            'handlers': ['file']
        }
    })

```



##### local flask run(prod) 이후 logs폴더 생성 확인한 뒤, gitignore에 logs폴더 추가하기



```shell
flask run
```

![image-20230208011914565](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208011914565.png)

```ini
#...

logs
```



##### Zerodivision에러 페이지 접속하고, 터미널 + logs/sqlalchemy.log 파일 확인하기

![image-20230208012020591](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208012020591.png)

1. production모드에선 **터미널에 아무것도 뜨지 않는다.**

   ![image-20230208012055394](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208012055394.png)

2. logs/sqlalchemy.log 보기

   ![image-20230208012125236](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208012125236.png)

##### 로컬 run.ps1에 모드 다시 돌리기

```init
$env:APP_CONFIG='development'
```



##### 서버에 push pull wsgi재시작 하여  cat / tail -f로  로그파일 확인하기

```shell
sudo systemctl restart sqlalchemy.service 
ls -rlt

drwxr-xr-x 2 ubuntu ubuntu   4096 Feb  8 01:24  logs
-rw-r--r-- 1 ubuntu ubuntu 176128 Feb  8 01:24  data-prod.db
```

```shell
cat ./logs/sqlalchemy.log 
tail -f logs/sqlalchemy.log 
```



![image-20230208012446473](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208012446473.png)

![image-20230208012715155](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208012715155.png)



##### 이제부터 서버쪽에서 찍고 싶다면 current_app import 후 current_app.logger.level('내용')

```python
from flask import Blueprint, url_for, current_app
(... 생략 ...)

@bp.route('/')
def index():
	# 3/0  # 강제로 오류발생
    current_app.logger.info("INFO 레벨로 출력")
    (... 생략 ...)
```



### 도메인 붙이기

- ROUTE 53에서 구매할 수 있지만, .co.kr, .kr을 만들 순 없다
  - 가비아에서 구매

1. 도메인 선택 [whois.kr](https://whois.kr/)
2. 도메인 구입시에 **네임서버 주소를 설정하는 항목**이 있는데 일단 해당 업체의 네임서버 주소를 사용하는 것으로 설정하자. 
   - **네임서버 주소는 고정아이피와 도메인을 연결**하는 중요한 항목이다. **도메인에 등록된 네임서버 주소는 언제든지 수정**할 수 있으니 잘못 등록될까 걱정할 필요는 없다.



#### aws 고정ip와 도메인 연결하기 - DNS 설정시 호스트(레코드 이름)-고정IP 연결하는 레코드 추가

1. [lightsail](https://lightsail.aws.amazon.com)에서 **~~네트워킹 > DNS 영역 생성~~ 도메인 및 DNS > DNS 영역 생성 **을 선택한다

2. 다른 도메인 대행업체의 도메인 생성 -> 도메인 이름`chojaeseong.com`을 입력한다

   ![image-20230208034139413](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208034139413.png)

3. ~~`도메인 영역 생성`시 제공해주는 `이름서버(네임 서버)`를 복사해놓고, **`도메인(가비아)의 네임서버`에서 봍붙할 준비를 한다.**~~

   - **나는 이미 가비아에 네임서버를 이용중이므로 이작업은 생략한다.**
     - 가비아의 네임서버를 사용안한다면, 이것들을 **가비아 > 도메인관리 > 도메인 정보변경  네임서버를 선택해서 차례대로 넣어주면 된다. **

   ```
   ns-1463.awsdns-54.org
   
   ns-862.awsdns-43.net
   
   ns-1829.awsdns-36.co.uk
   
   ns-57.awsdns-07.com
   ```

4. `DNS 레코드`탭으로 와서 레코드를 추가한다. 

   1. **나는 가비아의 DNS 레코드를 추가해서 사용한다.**

      1. **도메인 관리 > DNS정보 > DNS 관리 > DNS 설정 > 레코드 추가**

         ![image-20230208041237530](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208041237530.png)

      2. **라이트세일과 다르게 레코드유형 -> `타입` / 레코드 이름 -> `호스트`로 나타낸다.**

   2. 라이트세일 것을 사용하려면

      1. **레코드 유형: `레코드`(기존A레코드)는 `고정IP와 직접 연결`하는 방식이다. 참고로`CName`은 도메인을 다른도메인으로 연결하는 방식이다.**
      2. **레코드 이름: www도 안붙이려면  `@`.chojaeseong.com으로 만든다.**

   ![image-20230208034501618](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208034501618.png)

   ![image-20230208041315630](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230208041315630.png)





#### Nginx의 server block은 1개지만, 확장성 고려, 분기 전 확인용인 server_name(client 접속 IP or 도메인들) 고정IP -> 도메인으로 변경

- 사실 `기존 고정IP`에 `space + 도메인`을 추가해도 상관없다. 어차피 `여러 server가 있을 경우 분기 전 비교용`이기 때문?!

```shell
sudo vi /etc/nginx/sites-available/sqlalchemy 
```

```ini
server {
        listen 80; # client 접속 port
        # client 접속 고정IP or 도메인 or localhost -> 여러 server{}블락이 있는 경우 분기를 찾기 위한 name으로 유효하지 않아도 된다. request의 헤더속 도메인과 비교한다.
        server_name app.chojaeseong.com; 


```

```shell
sudo systemctl restart nginx
```



### SSL 적용하기(Let'sEncrypt)

#### 설치 및 도메인 인증서(key)발급

1. certbot 및 python3모듈 설치

   ```shell
   sudo apt install certbot
   sudo apt install python3-certbot-nginx
   ```

2. nginx용 인증서 발급하기

   1. email을 입력한다

   2. **자동으로 nginx설정에 입력했던 server_name인 `app.chojaeseong.com`에 적용할 것인지 확인한다**

      - 안나오면 server_name으로 등록한 도메인을 입력한다

   3. **3개월후 만기라고 안내하며, 생성된 key들의 위치를 알려준다.**

      - 추가로 그 전에 `certbot renew`라고 치면 되나보다.

      ```
      Your certificate and chain have been saved at:
      /etc/letsencrypt/live/app.chojaeseong.com/fullchain.pem
      
      Your key file has been saved at:
      /etc/letsencrypt/live/app.chojaeseong.com/privkey.pem
      
      
      Your cert will expire on 2023-05-09. To obtain a new or tweaked
      version of this certificate in the future, simply run certbot
      again. To non-interactively renew *all* of your certificates, run
      "certbot renew"
      
      ```



#### nginx 설정파일(sites-available/{프로젝트명}) 80 -> 443으로 redict하고 443에 정의하기

```shell
sudo vi /etc/nginx/sites-available/sqlalchemy
```

1. 80번 포트 server 블락은 redirect문법을 쓴다.

2. **`443 ssl`포트은 ssl관련 설정 중 도메인경로만 바뀌며 나머지는 고정이다.**

   - 80번 포트 내용을 그대로 사용한다.
   - server_name은 동일하게 준다.

   ```ini
   server {
           listen 80; # client 접속 port
           # client 접속 고정IP or 도메인 or localhost -> 여러 server{}블락이 있는 경우 분기를 찾기 위한 name으로 유효하지 않아도 된다. request의 헤더속 도메인과 비교한다.
           server_name app.chojaeseong.com;
           # 80으로 들어오더라도 443으로 redirect
           rewrite         ^ https://$server_name$request_uri? permanent;
   }
   
   server {
           listen 443 ssl;
           server_name app.chojaeseong.com;
   
           # 아래 4줄은 복붙후 인증서 경로 live/ <--> /fullchain.pem or privkey.pem 사이 도메인만 나의 것으로 변경
           ssl_certificate /etc/letsencrypt/live/app.chojaeseong.com/fullchain.pem; # managed by Certbot
           ssl_certificate_key /etc/letsencrypt/live/app.chojaeseong.com/privkey.pem; # managed by Certbot
           ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
           ssl_ciphers "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4";
           ssl_prefer_server_ciphers on;
   
           location = /favicon.ico { access_log off; log_not_found off; }
   
           location /static {
                   alias /home/ubuntu/projects/sqlalchemy/src/main/static;
           }
   
           location / {
                   include proxy_params;
                   proxy_pass http://unix:/tmp/sqlalchemy.sock;
           }
   }
   
   ```



#### 443 ssl포트 접속을 sock으로 보내줄건데, aws에서 포트개방을 해놔야한다.

- 인스턴스 > 네트워킹 > 규칙 추가

![image-20230209001145878](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209001145878.png)







### PostgreSQL로 옮기기



#### 라이트세일에서 데이터베이스(인스턴스) 만들기

1. postgresql로 최신버전(12.13)로 만듦
   - 3개월 무료, 40기가, **리전을 서울로 바꿔서 만들 것**
2. 연결 세부 정보 확인
   1. 사용자이름 / 암호 / 엔드포인트및 포트
      - 암호는 변경하자.(시간 걸림) - 12!.
      - ls-c7a13ab2b977265f9625a1b601bf880df9669360.cmu25eembpih.ap-northeast-2.rds.amazonaws.com
      - 5432

#### aws 서버에서 PostgreSQL 클라이언트 설치하여 table이 들어갈 데이터 베이스 생성하기

```shell
sudo apt install postgresql-client
```

- 설치되면 **`createdb` [db명] --username=[db서버유저명] -h [데이터베이스주소] `명령어`를 사용할 수 있게 된다.**
  - 엔터치면 암호도 묻는다.



```shell
createdb sqlalchemy --username=dbmasteruser -h ls-c7a13ab2b977265f9625a1b601bf880df9669360.cmu25eembpih.ap-northeast-2.rds.amazonaws.com
Password: 
```





#### db 서버 퍼블릭으로 만들기

- 네트워킹 > 퍼블릭모드 켜기
  - 시간 좀 걸림
- **퍼블릭이 아니면, DB와 동일 리전에서의 lightsail만 접속가능하다고 한다.**

![image-20230209031108167](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209031108167.png)

#### pycharm으로 db서버 연결하기 

- 인증방식을 User & password로 바꿔서 접속한다

  ![image-20230209030644275](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209030644275.png)



- 파이참 연결 후, 생성한 `sqlalchemy` 데이터베이스는 클릭해야 보인다.

  ![image-20230209031250617](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209031250617.png)



#### [서버전용] flask -> postgre 연결을 위한 모듈 psycopg2-binary 설치하기

```shell
source  ~/venvs/sqlalchemy/bin/activate

(sqlalchemy) pip install psycopg2-binary
```



#### [서버전용] .env 파일 생성해서 정보기입하기

##### 나의 경우, src/config/settings.py DATABASE_URL 설정(sqlite -> RDB)은 DB_CONNECTION이 .env에 있냐없냐의 차이로 결정된다.

```python
# src/config/settings.py

#...
class DBProductionConfig(DB):
    # .env 파일에 DB_CONNECTION 여부가 sqlite vs RDB를 결정한다.
    if os.getenv("DB_CONNECTION"):
        DB_CONNECTION = os.getenv("DB_CONNECTION").lower()
        DB_USER: str = os.getenv("DB_USER", "root")
        DB_PASSWORD = os.getenv("DB_PASSWORD", "root")
        DB_HOST = os.getenv("DB_HOST", "localhost")
        DB_PORT: str = os.getenv("DB_PORT", "3306")
        DB_NAME: str = os.getenv("DB_NAME", "test")

        DATABASE_URL = f"{DB_CONNECTION}://" \
                       f"{DB_USER}:{DB_PASSWORD}@" \
                       f"{DB_HOST}:{DB_PORT}/" \
                       f"{DB_NAME}"
    else:
        DATABASE_URL = 'sqlite:///' + os.path.join(BASE_FOLDER, f'{os.getenv("DB_NAME") or "data"}-prod.db')

#...
```



#### [서버전용] .env.example -> .env로 바꾸고, 내용 작성하기

```shell
sudo mv .env.example .env

sudo vi .env
```

```ini
#### 비워둘거면 아예 주석처리해야 빈문자열이 안가서 python내부 default값이 적용된다.

#### project####
## UPLOAD_PATH를 비워두면, base + 'uploads/'를 업로드 폴더로 간주한다.
ADMIN_EMAIL='tingstyle1@gmail.com'
# PROJECT_NAME=
# PROJECT_VERSION=
# UPLOAD_PATH=



#### DB ####
## DB_NAME 생략시 data-dev.db
## test) sqlite:///:memory:로 작동한다
## prod) DB_CONNECTION에 dialect+모듈 입력시 RDB로 인식된다.

DB_NAME=sqlalchemy # 생략시 data-dev.db or data-prod.db

POST_PER_PAGE = 10
COMMENTS_PER_PAGE = 10

#### production + RDB적용시 ####
## postgresql+psycopg2 / mysql+pymysql
DB_CONNECTION=postgresql+psycopg2 # 생략시 sqlite로 돌아가며, base+ [DB_NAME.db or data-dev.sqlite]
DB_USER=dbmasteruser
DB_PASSWORD=12!.
DB_HOST=ls-c7a13ab2b977265f9625a1b601bf880df9669360.cmu25eembpih.ap-northeast-2.rds.amazonaws.com
DB_PORT=5432

#### FLASK ####
SECRET_KEY = 'secret-key'


#### jwt ####
# TOKEN_KEY=
# EXP_TIME_MIN=
# REFRESH_TIME_MIN

```



#### [서버전용] 기존 sqlite DB 삭제( .env의 DB_CONNECTION 지정으로 인한 RDB사용 후)

##### 마이그레이션 기록 삭제 -> db 삭제

- 마이그레이션 기록들
  - **alembic : `alembic/versions` but  폴더를 지우면 안된다.**
  - flask :  `migrations`
    - 이것은 폴더까지 하번에 지워도 된다.

```shell
# 폴더말고 내용물만 지우기
rm -rf alembic2/versions/*

sudo rm data-prod.db
```



##### flask로 테이블 생성

```shell
source ./run.sh # 가상환경 켜기

flask create_db
flask create_role
flask create_admin_user
```



##### 프로젝트 서비스(gunicorn) 재실행

```shell
sudo systemctl restart sqlalchemy.service 
```



#### Local에서부터 alembic 세팅만 만들어 push하여 SERVER migraion 가능케 하기

##### [공통 from local] pytho모듈 설치

1. 이미 설치했지만, 안되어있으면

   ```shell
   pip3 install alembic
   ```

   

##### [공통 from local] alembic init {폴더명}부터는 후 env.py에 DATABASE 세팅

###### 기존 기록 확인

1. **alembic 폴더를 기준으로 이미 생성(초기화)되어있는지 확인한다.**

   - **`alembic init {폴더명}`은 `DIRECTORY alembic`을 기준으로 에러를 발생한다.**

     ```shell
     alembic init alembic
     
     FAILED: Directory alembic already exists and is not empty
     ```

   - **`기존 alembic 폴더 삭제` + `alembic_version 테이블` 하고 `초기화`하기**

     - 초기화하면 root폴더에 `alembic`폴더가 생성된다.

     ```powershell
     run.ps1
     	
     alembic init alembic
     ```

     - tree명령어는 `/f` 매개변수와 함께 `해당폴더 경로에 /`가 뺀 체로 치면 된다.

       ```powershell
       tree .\alembic /f  # not .\alembic\   but .\alembic
       
       C:\USERS\IS2JS\PYTHONPROJECT\2022_SQLALCHEMY\ALEMBIC
       │  env.py
       │  README
       │  script.py.mako
       │
       └─versions
       
       ```

     - root에는 `alembic.ini`파일도 생성된다.

       ![image-20230209210349144](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209210349144.png)

   ##### 

2. **DB에 table**이 생기며, 그 버전을 기록한다

   - dev / prop 서로 다른 DB기 때문에 **각각 초기화해줘야한다.**

   ![image-20230209181339830](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209181339830.png)

   ![image-20230209181433022](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209181433022.png)



###### alembic init {migrations}로 초기화(파일생성) 후 4가지 세팅하기

```shell
alembic init migrations
```

1. root에 `alembic.ini` + `migrations`폴더 및 내부 파일들이 생기는데

- **나는 DATABASE_URL이 동적으로 생성되기 때문에 `alembic.ini`정적파일이 `sqlalchemy.url` 변수는 사용안하도록 주석처리 한다**

```ini
# alembic.ini

#...

#sqlalchemy.url = driver://user:pass@localhost/dbname

#...
```

- **삭제하면 나중에 revision 생성시 에러 뜬다.**

  ```shell
  alembic revision -m "init migrations"
  FAILED: No config file 'alembic.ini' found, or file has no '[alembic]' section
  ```

  

![image-20230209212107711](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209212107711.png)



2. `env.py`에 생성해놓은 `config`객체 아래 `main_option`으로서 `sqlalchemy.url` key에 set해준다.

```python
#...

config = context.config

# 1. DB 연결해주기 - config객체에 main_option에 'sqlalchemy.url'이라는 key에 걸어준다.
if not config.get_main_option('sqlalchemy.url'):
    config.set_main_option('sqlalchemy.url', db_config.DATABASE_URL)

```



3. `target_metadata` 객체 **우리의 `Base객체.metadata`를 연결해주고, `entity Model`들을 다 메모리에 import해놓는다.**

```python
# 2. target_metadata에 Base객체의 metadata를 연결하고, entity들을 메모리에 띄워둔다.
from src.infra.config.base import Base
from src.infra.tutorial3 import *

target_metadata = Base.metadata
```



4. run_migrations_online부분에 **sqlite인 경우 render_as_batch=True옵션을 줘야 ALTER not support 옵션이 안뜬다.**

   ```python
   def run_migrations_online() -> None:
       #...
       with connectable.connect() as connection:
           # 4. sqlite ALTER support를 안해주므로, sqlite인 경우 render_as_batch옵션이 들어가도록
           render_as_batch = db_config.DATABASE_URL.startswith("sqlite")
   
           context.configure(
               connection=connection,
               target_metadata=target_metadata,
               render_as_batch=render_as_batch # 옵션 주어서 실행
           )
   ```

   

- init한다고 `alembic_version`테이블이 아직 생성되진 않는다.
  - revision -> 첫 upgrade를 해야 생김.

![image-20230209213411668](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209213411668.png)



##### [공통 from local] {폴더명}/versions의 기록도 push되면 안된다 -> .gitignore에 추가

- **`versions`폴더는 서버에 존재해야한다.**

  - 일반적인 `폴더/*`로 등록하면 **폴더까지 포함해서 ignore된다.**
  - **특정폴더까지 포함시키려면, `!/폴더` + `/`** 끝에 `/`를 붙여서 폴더 ignore를 ignore한다

  ```ini
  # .gitignore
  
  logs
  
  !{폴더명}/versions/
  {폴더명}/versions/*
  ```

  ```ini
  !alembic/versions/
  alembic/versions/*
  !migrations/versions/
  migrations/versions/*
  ```

  

##### [공통 from local] alembic 최초 revision 작성 전에 [alembic_version테이블 drop] + [versions 내용물 삭제] 2개를 다 확인해야한다.

- gitignore에 추가안하고 push했다면 서버에서는 `versions 정보들을 지워`줘야한다.

```shell
rm -rf {폴더명}/versions/*
```

![image-20230209181806438](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209181806438.png)



- **`alembic init {migrations(폴더명)}`를 하기 전엔, alembic_version 테이블이 없어야 정상이다. 있으면 drop해준다.**



- 그에 따른 `alembic history`도 없다

```shell
alembic history 
```

- `alembic current`, `alembic heads`는 무반응이다.

```shell
alembic current

alembic heads
```



##### [개별] alembic revision [-m "msg"]로 최초 base revision 만들고 -> 첫 upgrade로 alembic_version 테이블 만들기

```shell
alembic revision -m "init migrations"
```

1. revision 생성한다고해서 **아직 alembic_version 테이블**이 생성되진 않는다.

   ![image-20230209213806347](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209213806347.png)

   - **alembic history**만 등록된다.

   ```shell
   alembic history                      
   
   <base> -> afbb75e7ffff (head), init migrations
   ```

   

2. **해당 최상위 버전인 `head`로 `첫 upgrade`하는 순간 `테이블이 생성된다`**

   ![image-20230209214044122](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209214044122.png)

   ![image-20230209213812722](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209213812722.png)





3. **alembic의 현재버전(current)과 최신버전(heads)를 각각 확인할 수 있다.**

   ```shell
   alembic heads       
   
   afbb75e7ffff (head)
   
   #---
   alembic current
   
   INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
   INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
   afbb75e7ffff (head)
   
   ```



4. **server에 세팅정보만(gitignore를 통해 자동)를 push**하고 똑같이 수행한다.

   ```shell
   git pull
   
   
   alembic revision -m "init migrations"
   
   alembic history
   
   alembic upgrade head
   ```

   ![image-20230209220554050](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209220554050.png)



##### [공통 ORM변화 => 개별 revision 작성 ] ORM 변화 -> DB반영 하기

1. 현재 테이블명 settings1 -> setting으로 ORM을 바꾸자.

   ```python
   class Setting(Base):
       __tablename__ = 'settings' # <- 'settings1'
   ```

2. **`alembic revision --autogenerate`로 ORM변화를 자동 감지하자.**

   ```shell
   alembic revision --autogenerate -m "rename settings1 to settings"
   
   
   INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
   INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
   INFO  [alembic.autogenerate.compare] Detected added table 'settings'
   INFO  [alembic.autogenerate.compare] Detected added index 'ix_settings_setting_key' on '['setting_key']'
   INFO  [alembic.autogenerate.compare] Detected removed index 'ix_settings1_setting_key' on 'settings1'
   INFO  [alembic.autogenerate.compare] Detected removed table 'settings1'
   INFO  [alembic.autogenerate.compare] Detected removed unique constraint 'uq_roles_name' on 'roles'
   INFO  [alembic.autogenerate.compare] Detected added index 'ix_roles_name' on '['name']'
   Generating C:\Users\is2js\pythonProject\2022_sqlalchemy\migrations\versions\1a958ec203ba_rename_settings1_to_settings.py ...  done
   
   ```

   - 현재 버전이 down_revision으로 기록되면서, downgrade함수에 현재db로 돌릴 수 있는 코드가 나와있다.

     ![image-20230209215315560](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209215315560.png)

3. **감지된 내용(revision)으로 upgrade하여 db를 변화시킨다.**

   ```shell
   alembic upgrade head
   ```

   

![image-20230209183209334](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209183209334.png)





##### [downgrade] Local -> Server 과정 (앵간하면 안하도록)

###### Local에서 미리 데이터백업 + revision파일 or git보고 ORM 수동 백업 후 => alembic downgrade -1 or {revisionId} => 이후버전 삭제하여 head로 만든 뒤 alembic stamp head로 table의 버전도 바뀐head로 맞추기

1. **(아직 명령어를 치지말고)** `alembic downgrade -1`  or `alembic downgrade {Id}`로 **`DB만 이전 revision으로 백업되므로 ORM code를 수동으로 백업`해줘야한다.**

   - --autogenereate 로 ORM을 감지했지만, **downgrade는 `ORM무관`하게 `DATABASE`만 되돌린다.**

   - **또한, sqlite인 경우, render_as_batch=True로 인해 `테이블명 변화시에도 테이블을 drop했다가 새로 만든다`**

     - sqlite는 ALTER, DROP 명령어를 지원하지 않기 때문

   - 그러므로

     1. **`downgrade 전, sqlite 데이터를 미리 복사해서 옮겨둔다`**
     2. **`Open diff window`에다가 현재revision의 `update<->downgrade`메서드 코드들을 diff창에 놓고 무엇이 변했는지 확인하거나 혹은 `git comit에서 upgrade 전 ORM수정으로 돌아가는 코드를 확인`해서 미리 코드를 바꿔놓는다.**

     ![image-20230209230448432](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209230448432.png)

     ![image-20230209230506296](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209230506296.png)			![image-20230209230604493](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209230604493.png)

     ![image-20230209230647933](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209230647933.png)

2. **ORM코드를 백업되도록 수정했으면 `alembic downgrade -1`로 DB를 백업시킨다.**

   ```shell
   alembic downgrade -1
   ```

   ```shell
   alembic history
   ```

   

3. **downgrade한 revision이 최신버전(head)가 될 수 있도록, `그 이후버전들의 versions py파일들을 삭제`하고, `백업으로 돌아간 현재 버전(head가 됨`)을 alembic_version table에 head로 남도록 `alembic stamp head`로 바꿔준다.**

   ![image-20230209225958182](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209225958182.png)

   ```shell
   alembic stamp head
   ```

   



##### server는 수동백업된 ORM이 push로 올라면, git pull후 --autogenerate로 새 revision을 만들어서 message만 downgrade

- 서버는 ORM만 바뀐상태로 push가 온다. 코드는 미리 수정되어있으니 다운grade만 해서 db만 바꾸며 된다.
  - **서버는ORM이 원하는대로 바뀌었으니, backup downgrade 대신 새로운 revision을 만들며 ㄴ된다.**

```shell
git pull

alembic revision --autogenerate -m "downgrade -1 in local"
  Generating /home/ubuntu/projects/sqlalchemy/migrations/versions/1b1dc1dbbfb8_downgrade_1_in_local.py ...  done

alembic upgrade head
alembic history

78501cb5428b -> 1b1dc1dbbfb8 (head), downgrade -1 in local
2a70ee9276bc -> 78501cb5428b, init migrations
<base> -> 2a70ee9276bc, init migrations
```



![image-20230209231330738](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209231330738.png)

![image-20230209231346059](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230209231346059.png)



### 부록



#### OS별 환경변수 

1. **환경변수 선언**
   - ps1: `export $env:{변수}={'값'}`
   - cmd: `set {변수}={값}`
   - sh: `export {변수}={값}`
2. **환경변수 사용**
   - ps1: `$env:{변수}`
   - cmd: `%{변수}%`
     - `echo %{변수}%`
   - sh: `${변수}`
     - `$echo ${변수}`
3. **환경변수 list 보기**
   - ps1 : `gci env:` `gci env:{*flask*}` `gci env: | ? Name -match "flask" | sort Name`
   - cmd: `set` `set | findstr /i {flask}`
   - sh: `export` `env`  `printenv` `printenv | grep -i {flask}`
4. **환경변수 제거**
   - ps1: `ri env:/{변수명}`
   - cmd: `set {변수명}=` 
     - 빈값으로 null을 주면 지워진다.
   - sh: `unset {변수명}`

##### 로컬용 .cmd / .ps1 by development

- 로컬에서는 가상환경이 바로 해당 폴더에 있으니, cd 없이 가상환경 실행만 한다

  - `run.cmd`

  ```shell
  @echo off
  
  :: development / testing / production / default
  set APP_CONFIG=production
  set FLASK_APP=manage.py
  
  set FLASK_ENV=%APP_CONFIG%
  set FLASK_RUN_HOST=localhost
  set FLASK_RUN_PORT=5000
  
  .\venv\Scripts\activate
  ```

  - `run.ps1`

  ```shell
  # development / testing / production / default
  $env:APP_CONFIG='development'
  $env:FLASK_APP='manage.py'
  
  $env:FLASK_ENV=$env:APP_CONFIG
  $env:FLASK_RUN_HOST='localhost'
  $env:FLASK_RUN_PORT='5000'
  
  ./venv/Scripts/activate
  ```

  

##### 서버용 .sh by production

- `run.sh`

  ```shell
  #!/bin/bash
  
  # 프로젝트 폴더로 이동
  cd ~/projects/sqlalchemy
  
  # development / testing / production / default
  export APP_CONFIG=production
  export FLASK_APP=manage.py
  
  export FLASK_ENV=$APP_CONFIG
  export FLASK_RUN_HOST=0.0.0.0
  export FLASK_RUN_PORT=5000
  
  # 가상환경 위치 + 실행까지
  . ~/venvs/sqlalchemy/bin/activate
  ```



#### 서비스 관련 명령어

##### wsgi(gunicorn)

1. 서비스 파일 존재 확인

   - 서비스 파일들은 `/etc/systemd/system`에 `.service`파일로 작성해놓는다.

   ```shell
   ls  /etc/systemd/system/
   ```

2. 서비스 일반 실행

   ```shell
   sudo systemctl start sqlalchemy.service
   ```

3. 서비스 오류시 서비스 로그 확인

   - 서비스의 에러들은 `/var/log/syslog`에 찍히나보다.

   ```shell
   tail -f /var/log/syslog 
   ```

4. 서비스 실행 상태 확인

   ```shell
   sudo systemctl status sqlalchemy.service
   ```

5. 서비스 종료

   ```shell
   sudo systemctl stop sqlalchemy.service
   ```

6. 서비스 재부팅시 매번 재실행

   ```shell
   sudo systemctl enable sqlalchemy.service
   ```

   

##### nginx

1. **avalable안에 있는 설정파일을 `site-enabled`디렉토리로 ln -s 심볼릭링크를 걸어야하므로, 걸어줄 위치를 생략하기 위해 `site-enabled`폴더로 이동한다**

   - sites-enabled 디렉터리는 **site-available 디렉터리에 있는 설정 파일 중에서 활성화하고 싶은 것을 링크로 관리하는 디렉터리**이다.

   ```shell
   cd /etc/nginx/sites-enabled/
   ls 
   
   sudo ln -s /etc/nginx/sites-available/sqlalchemy 
   ```

   ```shell
   ubuntu@chojaeseong:/etc/nginx/sites-enabled$ ls
   default  sqlalchemy
   ```

2. **기존 기본설정 활성화 링크 삭제** 

   ```shell
   sudo rm default
   
   ubuntu@chojaeseong:/etc/nginx/sites-enabled$ ls
   sqlalchemy
   ```

3. **nginx 서비스 재시작**

   - 설치하면 기본적으로 서비스가 실행되어있음

   ```shell
   ubuntu@chojaeseong:/etc/nginx/sites-enabled$ sudo systemctl restart nginx
   ```

4. **nginx 세팅확인 `-t`**

   ```shell
   ubuntu@chojaeseong:/etc/nginx/sites-enabled$ sudo nginx -t
   
   nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
   nginx: configuration file /etc/nginx/nginx.conf test is successful
   ```

5. nginx 서비스 상태확인 / stop / 시작

   ```shell
   sudo systemctl status nginx
   sudo systemctl stop nginx
   sudo systemctl start nginx
   ```

   



##### certbot renew



##### db server



```shell
createdb sqlalchemy \
--username=dbmasteruser \
-h ls-c7a13ab2b977265f9625a1b601bf880df9669360.cmu25eembpih.ap-northeast-2.rds.amazonaws.com
Password: 
```



##### git pull -> gunicorn service restart

```shell
git pull
sudo systemctl restart sqlalchemy.service
```





##### alembic revision

- 기본 명령어

  ```shell
  alembic init {폴더명}
  
  alembic history
  alembic current # alembic_version 테이블에 저장된 현재 revision
  alembic heads # 최상위 revision
  
  alembic revision -m --autogenerate "" # 현재DB vs 바뀐ORM 비교
  
  alembic upgrade head | id | +1
  alembic downgrade base | id | -1
  ```

  

###### local

1. **ORM 수동 수정** 

2. **데이터 수동 백업** for sqlite NO ALTER DROP => table지웠다가 새로 생성

   ```shell
   alembic revision --autogenerate -m "msg"
   alembic upgrade head
   ```

   

###### server

- 서버에는 local에서 downgrade를 하든 뭘하든 **`수동으로 변환된 ORM`이 넘어오므로 최신버전으로 개정만** 해주면 된다

```shell
git pull

alembic revision --autogenerate -m "downgrade -1 in local"
alembic upgrade head

sudo systemctl restart sqlalchemy.service
```

