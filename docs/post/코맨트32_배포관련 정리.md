### 지금까지

#### 스크립트: flask 실행 환경변수 -> OS에 세기고 -> flask run:실행

##### (1)  run.ps1 / run.cmd 실행 -> 가상환경에서 flask run

```ini
$env:FLASK_APP='manage.py'
#$env:FLASK_ENV='development'
#$env:FLASK_DEBUG='true'
# development /testing / production / default
$env:APP_CONFIG='production'
$env:FLASK_RUN_HOST='localhost'
$env:FLASK_RUN_PORT='5001'
```

```ini
set FLASK_APP='manage.py'
#set FLASK_ENV='development'
#set FLASK_DEBUG='true'
set APP_CONFIG='development'
set FLASK_RUN_HOST='localhost'
set FLASK_RUN_PORT='5000'
```

```shell
.\run.ps1
.\venv\Scripts\activate

flask run
```



- 파워셸 환경변수 확인 -> **`Get-childitem ENV:`의 약어**

  - [참고 블로그](https://wednesday1304.tistory.com/entry/PowerShell-%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%ED%99%95%EC%9D%B8-cmd)

  ```powershell
  gci env:
  ```

  

##### (2) 또는 flask run --host=localhost --port=5000 등 지정 실행

```shell
flask run --host=localhost --port=5000
```



##### FLASK_ENV 및 _DEBUG설정 대신 새로운 APP_CONFIG 환경변수를 새로 파서 -> 프로젝트 내부 settings.py에서 한다

- production이 선택되면, 내부에서 `ENV`와 `DEBUG`가 자동 설정되게 한다.
- 공통 설정 + 각 mode별 클래스를 만들어, 상속된 것을 선택해서 가져간다
- 

```python
# settings.py

#...

class FlaskConfig:
    # CORS
    SECRET_KEY = os.getenv("SECRET_KEY") or 'hard to guess string'

    # @staticmethod
    # def init_app(app: Flask):
    #     pass

    # 나는 app객체에 class를 넘기는게 아니라 객체를 넘겨서 import되어 사용될 예정이므로
    # self를 단 인스턴스 메서드를 작성한다?!
    def init_app(self, app: Flask):
        pass


class FlaskDevConfig(FlaskConfig):
    DEBUG = True 


class FlaskTestingConfig(FlaskConfig):
    TESTING = True


class FlaskProdConfig(FlaskConfig):
    ENV = 'production'
    DEBUG = False

    
app_config = {
    'development': FlaskDevConfig,
    'testing': FlaskTestingConfig,
    'production': FlaskProdConfig,
    'default': FlaskDevConfig,
}

app_config = app_config[os.getenv('APP_CONFIG') or 'default']()
#...
```



- init.py

```python
from src.config import app_config

#...
def create_app(config_name):
	#...
    print("config_name>>>", config_name)

    app = Flask(__name__,
                template_folder=template_dir,
                static_folder=static_dir)
    
    app.config.from_object(app_config)
```





#### FLASK_APP 모듈(manage.py)은 내부 create_app메서드로 app객체를 만든다.

##### 이 때, DB객체 및,, model을 import해서 `dict로 싸서 반환`해주면, flask shell에서 활용할 수 있다.

- **manage.py**

  ```python
  import os
  
  from src.infra.config.connection import DBConnectionHandler
  from src.infra.tutorial3 import User, Role
  from src.main.config import create_app
  
  app = create_app(os.getenv('APP_CONFIG') or 'default')
  
  
  # flask shell에 객체들을 미리 던져놓는다.
  @app.shell_context_processor
  def make_shell_context():
      return dict(db=DBConnectionHandler(), User=User, Role=Role)
  
  ```

  ```shell
  flask shell
  
  
  >>> db
  <src.infra.config.connection.DBConnectionHandler object at 0x00000212135FA5C0>
  >>> User
  <class 'src.infra.tutorial3.auth.users.User'>
  >>> Role
  <class 'src.infra.tutorial3.auth.users.Role'>
  >>>
  
  ```

  



##### 팩토리 메서드 create_app()은 src.main.config의 `init.py`에 만들어, from config패키지 import create_app 메서드만 가져오면 된다. 

![image-20230206235214521](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230206235214521.png)

1. **create_app 팩토리 메서드를 정의하는 init.py**에는

   1. 프로젝트 자체설정 `src.config` / db객체 / 모델들 / extenstions 들 / **Flask**  모듈을 import하며
   2. **커스텀 template/static폴더 지정**하여 **app객체 생성**시 입력된다.
   3. 각종 extension으로 app객체를 초기화한다.
   4. **jinja필터 추가**
   5. **bp추가**
   6. **add_url_rule 추가 url추가**
   7. **`항상 떠있을 데이터 inject메서드 정의 및 context_processor로 등록`**
   8. **`app객체 반환`**

   ```python
   # from .app import app
   
   import datetime
   from pathlib import Path
   
   from flask import Flask
   from flask_cors import CORS
   from sqlalchemy import select
   
   from src.config import app_config
   
   from src.infra.config.connection import DBConnectionHandler
   from src.infra.tutorial3 import Category, Setting, Permission, Roles
   
   ## Path.cwd()는 실행파일(root의 run.py)의 위치가 찍힌다 -> root부터 경로잡기
   # -> path는 joinpath시 끝이 디렉토리라면 / 까지 넣어줘야한다.
   
   template_dir = str(Path.cwd().joinpath('src/main/templates/'))
   static_dir = str(Path.cwd().joinpath('src/main/static/'))
   print(f"template_dir: {template_dir}\n"
         f"static_dir: {static_dir}")
   
   ## 추가 extenstion객체 생성
   # migrate = Migrate()
   # moment = Moment()
   # pagedown = PageDown()
   
   def create_app(config_name):
   
       print("config_name>>>", config_name)
   
       app = Flask(__name__,
                   template_folder=template_dir,
                   static_folder=static_dir)
   
       ## db환경변수를 개별로 넣지않고 config object로 넣는다.
       # app.config["SECRET_KEY"] = app_config.SECRET_KEY
       # app_config.init_app(app)
       app.config.from_object(app_config)
       # print(app.config)
   
       ## extension객체들로 app객체 초기화
       CORS(app)
   
       ## 필터 추가
       from src.main.templates.filters import feed_datetime, join_phone, join_birth, format_date, format_datetime, format_timedelta
       app.jinja_env.filters["feed_datetime"] = feed_datetime
       app.jinja_env.filters["join_phone"] = join_phone
       app.jinja_env.filters["join_birth"] = join_birth
       app.jinja_env.filters["format_date"] = format_date
       app.jinja_env.filters["format_datetime"] = format_datetime
       app.jinja_env.filters["format_timedelta"] = format_timedelta
   
   
       ## bp아닌 것들은 add_url_rule용
       from src.main.routes import (
           main_bp, index,
           api_routes_bp, auth_bp,
           admin_bp,
           util_bp,
           dept_bp,
       )
   
       app.register_blueprint(main_bp)
       app.register_blueprint(api_routes_bp)
       app.register_blueprint(auth_bp)
       app.register_blueprint(admin_bp)
       app.register_blueprint(util_bp)
       app.register_blueprint(dept_bp)
   
       # 기본 / url 지정 in route.py의 function
       app.add_url_rule('/', endpoint='index', view_func=index)
       from ..utils.upload_utils import download_file
       app.add_url_rule('/uploads/<path:filename>', endpoint='download_file', view_func=download_file)
   
       ## app context단위로 항상 떠있는 entity 객체value의 dict 반환 method 주입
       app.context_processor(inject_category_and_settings)
       app.context_processor(inject_today_date)
       # app.context_processor(inject_permission_and_roles)
       app.context_processor(inject_permission)
   
       ## [flask xxxx] 명령어 추가
       from src.main.utils import init_script
       init_script(app)
   
       return app
   
   
   def inject_category_and_settings():
       with DBConnectionHandler() as db:
           categories = db.session.scalars(
               select(Category)
               .order_by(Category.id.asc())
           ).all()
   
           settings = Setting.to_dict()
   
       return dict(
           categories=categories,
           settings=settings,
       )
   
   
   def inject_today_date():
       return {'today_date': datetime.date.today}
   
   
   # def inject_permission_and_roles():
   ## role Roles이넘을 이용해 user객체의 hybrid_property로 다 정해줌
   def inject_permission():
       return dict(
           Permission=Permission,
           # Roles=Roles,
       )
   
   ```

   



#### 프로젝트 환경변수 .env -> OS에 안세기고,  settings.py에서 load_dotenv로 꺼내먹기

- `.env`

  ```ini
  #### 비워둘거면 아예 주석처리해야 빈문자열이 안가서 python내부 default값이 적용된다.
  
  #### project####  
  # = upload_path를 비워두면, base + 'uploads/'를 업로드 폴더로 간주한다.
  # PROJECT_NAME=
  # PROJECT_VERSION=
  ADMIN_EMAIL='tingstyle1@gmail.com'
  # UPLOAD_PATH=
  
  
  
  #### DB #### 
  # = dev) DEV_DATABASE_URL을 따로 지정하지 않으면, base + DB_NAME or (DB_NAME주석처리시)data-dev.sqlite
  # = testing) TEST_DATABASE_URL 따로 지정하지 않으면, sqlite:///:memory:로 작동한다 
  # = prod) DB_CONNECTION를 주석처리시, base + DB_NAME or (DB_NAME주석처리시)data.sqlite
  # POST_PER_PAGE = 10
  # COMMENTS_PER_PAGE = 10
  
  # DEV_DATABASE_URL= # 생략시 base+ [DB_NAME.db or data-dev.sqlite]
  DB_NAME=tutorial3 # 생략시 base + data-dev.sqlite or data.sqlite 
  
  #### production + RDB적용시 #### 
  # DB_CONNECTION=mysql+pymysql # 생략시 sqlite로 돌아가며, base+ [DB_NAME.db or data-dev.sqlite]
  # DB_USER=root
  # DB_PASSWORD=564123
  # DB_SERVER=0.0.0.0
  # DB_PORT=3306
  
  #### FLASK #### 
  SECRET_KEY = 'secret-key'
  
  
  #### jwt #### 
  # TOKEN_KEY=
  # EXP_TIME_MIN=
  # REFRESH_TIME_MIN
  ```

  

- settings.py

  ```python
  
  from dotenv import load_dotenv
  from flask import Flask
  
  dotenv_path = Path("./.env")
  load_dotenv(dotenv_path=dotenv_path)
  
  BASE_FOLDER = Path(__file__).resolve().parent.parent.parent  # root
  
  
  # fastapi 세팅 참고
  # https://github.com/heumsi/python-rest-api-server-101/blob/main/project/src/config.py
  class Project:
      # project
      PROJECT_NAME: str = os.getenv("PROJECT_NAME")
      PROJECT_VERSION: str = os.getenv("PROJECT_VERSION")
      # user생성시 role안넣은 상태에서, email이 정해진 email이면, 관리자 Role을 넣어준다.
      ADMIN_EMAIL: str = os.getenv("ADMIN_EMAIL")
  
  
  # path로 join만 하면 [마지막을 파일명으로 취급]하여 '/'가 없다.
  # -> 뒤에 개별폴더명이 붙을 joinpath라면 + '마지막 폴더명/'을 붙여서 연결하여, 다음엔 '/'없이 파일명 or 개별폴더명/파일명만 올 수 있도록 만든다.
  # UPLOAD_FOLDER = BASE_FOLDER.joinpath('uploads/')
  class ProjectDevConfig(Project):
      UPLOAD_FOLDER = BASE_FOLDER.joinpath('uploads/')
  
  
  class ProjectTestingConfig(Project):
      UPLOAD_FOLDER = BASE_FOLDER.joinpath('uploads/')
  
  
  class ProjectProdConfig(Project):
      UPLOAD_FOLDER = os.getenv('UPLOAD_FOLDER') \
                      or BASE_FOLDER.joinpath('uploads/')
  
  
  project_config = {
      'development': ProjectDevConfig,
      'testing': ProjectTestingConfig,
      'production': ProjectProdConfig,
  
      'default': ProjectDevConfig
  }
  project_config = project_config[os.getenv('APP_CONFIG') or 'default']()
  
  
  class DB:
      POST_PER_PAGE = int(os.getenv("POST_PER_PAGE", "10"))
      COMMENTS_PER_PAGE = int(os.getenv("COMMENTS_PER_PAGE", "20"))
  
  
  class DBDevConfig(DB):
      DATABASE_URL = os.environ.get('DEV_DATABASE_URL') or \
                     'sqlite:///' + os.path.join(BASE_FOLDER, f'{os.getenv("DB_NAME")}-dev.db' or "data-dev.sqlite")
  
  
  class DBTestingConfig(DB):
      DATABASE_URL = os.environ.get('TEST_DATABASE_URL') or \
                     'sqlite:///:memory:'
  
  
  class DBProductionConfig(DB):
      if os.getenv("DB_CONNECTION"):
          DB_CONNECTION = os.getenv("DB_CONNECTION").lower()
          DB_USER: str = os.getenv("DB_USER", "root")
          DB_PASSWORD = os.getenv("DB_PASSWORD", "root")
          DB_SERVER = os.getenv("DB_SERVER", "localhost")
          DB_PORT: str = os.getenv("DB_PORT", "3306")
          DB_NAME: str = os.getenv("DB_NAME", "test")
  
          DATABASE_URL = f"{DB_CONNECTION}://" \
                         f"{DB_USER}:{DB_PASSWORD}@" \
                         f"{DB_SERVER}:{DB_PORT}/" \
                         f"{DB_NAME}"
      else:
          DATABASE_URL = 'sqlite:///' + os.path.join(BASE_FOLDER, f'{os.getenv("DB_NAME")}.db' or "data.sqlite")
  
  
  db_config = {
      'development': DBDevConfig,
      'testing': DBTestingConfig,
      'production': DBProductionConfig,
  
      'default': DBDevConfig
  }
  db_config = db_config[os.getenv('APP_CONFIG') or 'default']()
  
  #...
  ```





### 라이트세일 사용 및 pycharm 접속

1. 한국어로 바꾸기

   ![image-20230207010848918](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207010848918.png)

2. OS전용 ubuntu 20.04 LTS 선택

3. 월 5달러, 1GB 메모리를 선택

4. 네트워킹 > **고정IP(탄력적IP) 생성** > 인스턴스 연결

   1. 3달간 무료로 사용할 수 있고 이후엔 비용이 발생한다. 이를 원치 않는다면 인스턴스와 고정 IP를 삭제해야 한다. 인스턴스는 다음처럼 AWS 라이트세일 홈페이지 화면의 [인스턴스] 탭에서 삭제할 수 있다
   2. 고정 IP는 다음처럼 [네트워킹] 탭에서 삭제할 수 있다.

5. 80번, 22번외 포트(flask 5000) 방화벽 해제

   1. 인스턴스 선택 > 네트워킹 > 규칙 추가 > 5000번 생성

6. key 페어 다운로드

   1. 계정 > 계정지원 > SSH 키 > 하단에 다운로드

      ![image-20230207011957479](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207011957479.png)

      ![image-20230207012007577](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207012007577.png)

   2. **프로젝트명.pem**으로 파일명 변경 후 > `C:\Users\{계정명}\.ssh`에 옮겨준다

      ![image-20230207012202157](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207012202157.png)

   3. pycharm에서 SSH로 접속하기(**putty는 pem -> .ppk로 generate과정 필요**)

      1. 설정 > SSH configurations

      2. Host에는 ip입력 / port는 22 그대로

      3. Username: 운영체제계정명 `ubuntu`

      4. 인증타입 : Key pair

      5. Private key file : `c:\Users\{계정명}\.ssh\`

      6. test Connection 성공후 이름바꿔주기

         ![image-20230207012924993](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207012924993.png)

      7. Tools > new SSH connection으로 실행 or `화살표 2개의 new predefined session`에서 실행

         ![image-20230207013655333](C:\Users\is2js\AppData\Roaming\Typora\typora-user-images\image-20230207013655333.png)

         ![image-20230207013537745](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207013537745.png)



#### ubuntu 초기 설정

##### hostname 변경

1. host명을 ip대신 다른 것으로 변경하기

   ```shell
   sudo hostnamectl set-hostname chojaeseong
   
   sudo reboot
   ```

   ```shell
   ubuntu@chojaeseong:~$ hostname
   
   chojaeseong
   ```

   



##### 서버 시간(localtime) 설정

- [ln관련 블로그](https://leechwin.tistory.com/entry/Ubuntu-ln-%EB%AA%85%EB%A0%B9%EC%9C%BC%EB%A1%9C-%EB%A7%81%ED%81%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0)

- ln `-s`(심볼릭not하드링크)`f`(foce, remove 기존 목적지파일) 

  - 서버의 로컬타임을 담당하는 link인 `/etc/localtime`은 **원본을 /UTC로 보고있다**

    ```shell
    ll /etc/localtime
    
    lrwxrwxrwx 1 root root 27 Jul 16  2020 /etc/localtime -> /usr/share/zoneinfo/Etc/UTC
    ```

    ```shell
    date
    
    Mon Feb  6 16:56:07 UTC 2023
    ```

  - **/etc/localtime의 링크를 Asia/Seoul로 걸어주면, `date(서버 localtime)`이 아시아로 바뀐다.**

    ```shell
    sudo ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime
    ```

    ```shell
    ll /etc/localtime
    
    lrwxrwxrwx 1 root root 30 Feb  7 01:56 /etc/localtime -> /usr/share/zoneinfo/Asia/Seoul
    ```

    ```shell
    date
    
    Tue Feb  7 01:57:04 KST 2023
    ```

    

##### python설치 확인

```shell
ubuntu@chojaeseong:~$ python

ubuntu@chojaeseong:~$ python3

ubuntu@chojaeseong:~$ python3 --version
Python 3.8.2
```





##### root용 가상환경 패키지 설치

1. 우분투 패키지 업데이트

   ```shell
   sudo apt update
   ```

   

2. 가상환경 생성 패키지(`python3-venv`)를 우분투 apt install로 설치

   ```shell
   sudo apt install python3-venv
   ```

   



#### 소스폴더 vs 가사환경폴더 분리해서 가상환경 생성하기

- 소스폴더 : `~/projects`

- 가상환경폴더 : `~/venvs`

  ```shell
  ubuntu@chojaeseong:~$ mkdir projects
  ubuntu@chojaeseong:~$ mkdir venvs
  ubuntu@chojaeseong:~$ ls
  projects  venvs
  
  ```

  

##### venvs에 프로젝트명으로 가상환경 생성 및 활성화

```shell
ubuntu@chojaeseong:~/venvs$ python3 -m venv sqlalchemy
ubuntu@chojaeseong:~/venvs$ ls
sqlalchemy


 . ~/venvs/sqlalchemy/bin/activate
 # 혹은
 source ~/venvs/sqlalchemy/bin/activate
```



###### 가상환경에 오류방지 wheel 패키지 설치

```shell
pip install wheel
```





#### projects폴더에 git clone(SSH)하기

##### ubunut sshkey 생성 후 -> github 계정 설정에 ssh key 등록하기

1. `cd ~/.ssh`로 이동

   ```shell
   cd ~/.ssh
   ```

2. ssh-keygen 명령어를 -t -b 알고리즘 옵션과 함께 -C 커맨트에 github 메일을 입력한다

   ```shell
   ssh-keygen -t rsa -b 4096 -C "tingstyle1@gmail.com"
   ```

3. 생성된 `id_rsa.pub` 버플릭키를 `cat`명령어로 터미널에 찍어 복붙 준비를 한다.

   ```shell
   cat cd ~/.ssh/id_rsa.pub
   ```

4. **github 계정의 settings** > SSH and GPG keys > `New SSH key`에 생성한 키를 등록한다.

   ![image-20230207042350187](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207042350187.png)

   ![image-20230207042413978](https://raw.githubusercontent.com/is2js/screenshots/main/image-20230207042413978.png)



##### ssh기반으로 repo clone하기

1. 프로젝트 폴더로 이동

   ```shell
   cd ~/projects
   ```

   

2. github repo **SSH clone**을 하며 **git clone [ssh주소] `[gitrepo명 대신 new 폴더명]`를 반드시 추가한다.**

   - projects/ `생성폴더`/ 소스코드들

   ```shell
   git clone git@github.com:is2js/2022_sqlalchemy.git sqlalchemy
   
   (sqlalchemy) ubuntu@chojaeseong:~/projects$ ls
   sqlalchemy
   
   
   cd sqlalchemy/
   ls
   ```





##### clone후 초기작업 requirements.txt 설치하기 -> install전에 pip install로 pip도 업그레이드

```shell
pip install --upgrade pip
pip install -r requirements.txt
```



- `pywin32==400`설치 오류 -> **윈도우 관련모듈이므로 주석처리했다.**



#### flask 실행환경변수 직접 입력 + flask create_db부터하고 실행



