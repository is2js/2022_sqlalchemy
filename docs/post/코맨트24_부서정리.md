### 갑분 초대 => 알림 시스템 만들기



#### Invite 분석정리하기



1. employee(current_user)는 특정User에 대해 `[직원전환] -> employee가 입력` 대신 `[직원초대]`를 누르면

   - `employee/invites` route에서
     - current_user -> ~~employee_id~~(`inviter_id`) - > **user_id** 항상 직원->User초대만 있는 것이 아니기 때문에 공용적인 user_id를 넣는다
     - 상대user -> user_id(`invitee_id`)
       - ~~employee~~는 user는 Invite.inviter_id에 대한 one으로서 `.inviters`를 통해, `내가 보낸 초대들`을 볼 수 있다.
       - users는 invite.invitee_id에 대한 one으로서 `.invitees`를 통해, `내가 받은 초대들`을 볼 수 있다.
     - **초대의 주제type  or  상위 주제entity의 id(fk)**
       - ~~ex> employee관련 이므로, employee_id를 넣고 하위의 초대로 만들게 한다~~
       - 검색이나 조회를 위해 `초대들마다 상위주제`가 정해져있어야한다.
         - 특정 예약entity에 대한 초대가 아니므로, 상위entity 없다
     - 까지만 넣고, 내부 deafult값으로 status, answered False로 Invite객체를 만든다

   ```python
   class Inivite
   #class PlayerInvite(db.Model):
       playerinvite_id = db.Column(db.Integer, primary_key=True)
       # invitees
       guest_id = db.Column(db.Integer, db.ForeignKey('player.player_id'))
       # inviters
       host_id = db.Column(db.Integer, db.ForeignKey('player.player_id'))
       # 상위주제entitye대신 초대 Category Type으로
       #booking_id = db.Column(db.Integer, db.ForeignKey('booking.booking_id'))
   
       status = db.Column(db.Boolean, default=False)
       answered = db.Column(db.Boolean, default=False)
   
   ```

   

   ```python
   guests = db.relationship("PlayerInvite", foreign_keys='PlayerInvite.guest_id')
   
   hosts = db.relationship("PlayerInvite", foreign_keys='PlayerInvite.host_id')
   ```

   

   

   ```python
   @player.route('/players/invite/add', methods=['POST'])
   @token_required
   def invite_player(current_user):
       data = request.get_json()
       invite = PlayerInvite(guest_id=data['guest_id'],
                             host_id=data['host_id'],
                             booking_id=data['booking_id'])
       db.session.add(invite)
       db.session.flush()
       db.session.commit()
       return {'message': 'Success!'}
   ```

   



2. employee가 `[직원초대]`를 누르면  초대 뿐만 아니라 **notification이 해당 user에게 가야할 것**이다.



3. 초대받은 user는 notification을받아 -> `메세지`상의 `[직원 초대 수락]` 를 클릭할 것이다



4. 아직, notification이 없으면, 바로 `[내가 받은 초대]`를 클릭하여 초대 목록을 확인한다

   - /auth/userinfo(내 정보) 다음 칸의 `/auth/invite/invitee`(내가 **받은(invitee)** 초대)에서 확인한다
     - 내가 받은 초대 tab은   user.invitees로서, 데이터가 잇을때만 나타나게 해야, 일반회원들한테 혼란을 줄일 수 있을 것이다?

   ```python
   def my_invites(user_id):
       player = Player.query.filter_by(user_id=user_id).first()
       invites = PlayerInvite.query.filter_by(guest_id=player.player_id)
   ```

   ```python
   @player.route('/players/invites/guest', methods=['GET'])
   @token_required
   def get_my_invites(current_user):  # Return invites sent to the logged player.
   
       output = []
   
       for invite in my_invites(current_user.id):
   
           invite_data = {'booking_id': invite.booking_id,
                          'spot_name': invite.spot_name,
                          'spot_id': invite.spot_id,
                          'status': invite.status,
                          'invite_id': invite.playerinvite_id,
                          'guest_id': invite.guest_id,
                          'host_name': f'{invite.host_name} {invite.host_surname}'
                          }
           output.append(invite_data)
   
       return {'invites': output}
   ```

   

5. 받은 초대목록 중에 `[초대거부/초대승락]`을 선택해서 누른다

   - 초대 수락

     - 초대는 employee/invite/add지만 
     - 초대수락은 `auth/invite/accept`로 받는다.
       - 초대id로 해당 초대객체를 가져와서 default False였던 **status(수락여부)와 answered(응답여부)를  True**로 놓는다.
     - **초대수락시, 상위entity에 하위entity로서 구성원들을 LineUp entity 모을 수 있지만, 여기선 해당 초대에 대한 상위entity (X), 주제Type에 수락자들을 모을 필요가 없다**
     - **초대 수락시, `employee/add form으로 rediect`해야할 것 같다**

     ```python
     @player.route('/players/invites/accept', methods=['POST'])
     @token_required
     def accept_invite(current_user):
         data = request.get_json()
         invite = PlayerInvite.query.filter_by(playerinvite_id=data['playerinvite_id']).first()
         invite.status = True
         invite.answered = True
         
         db.session.add(invite)
         
         #lineup = Lineup(player_id=data['player_id'],
                    #     booking_id=data['booking_id'])
         
         #db.session.add(lineup)
         db.session.commit()
         return {'message': 'Success!'}
     ```

   - **초대 거부는 invite에서 데이터를 삭제**한다

   - 그렇다면

     - 초대수락 route가 아니라 초대 answer_invite route로 만들고
       - `초대 수락`시 ->  Employeeform + **초대자의 role미만으로 선role선택가능하도록 동적필드choices** 로 `초대Type에 맞는 redirect `-> 초대 삭제 -> **render_tempalte(새로 route파서)**
       - `초대 거부`시 -> 초대 삭제
     - **그렇다면, 초대Type은 value로 초대수락시 `redirect될 url or render될 form과 template?`을 가져야한다? **
       - 초대Type에 다른 redirect_url을 어디다가 기입할까? IntEnum은 int만 저장하는데?
       - route에서 if 초대Type -> redirect_url을 배정해줘야하나?
         - 초대Type + form에 들어갈 정보도 redirect_url에 같이 줘야한다 (furl)
         - 그렇다면, invite에는 복잡한 고유key칼럼을 url대신 소유하고 있다가 **초대Type에 맞는, url을 만들어내는 함수를 소유한다**
     - 현재의 employee/add는 
       - employeeform에는 user_id, g.user( current_employee_id)가
       - route자체적으로는 role.chiefstaff이상이 필요한 상태다
       - 일반 유저도 접속할 수 있는 /auth/invite/employee/add가 필요할 듯하다?

     ```python
         def save(self, **kwargs):
             if not self.pk:
                 self.key = self.generate_key()
     
             return super().save(**kwargs)
     
         @staticmethod
         def generate_key():
             return get_random_string(64).lower()
     
         def send(self, request=None):
             url = self.get_absolute_url()
             if request:
                 url = request.build_absolute_uri(url)
     
             template = find_template("invite")
             context = {
                 "inviter_name": self.inviter.get_full_name(),
                 "email": self.invitee_email,
                 "invite_link": url,
             }
     
             return template.send_email([self.invitee_email], context)
     
         def get_absolute_url(self) -> str:
             return reverse("accounts:invite_accept", kwargs={"key": self.key})
     
         def expired(self) -> bool:
             expiration_date = self.created_on + timedelta(days=settings.INVITE_EXPIRY)
             return expiration_date <= timezone.now()
     ```

6. invite에는 **`create_on`을 넣고, 만료기간도 계산해서, `내가 받은 초대 조회`시 `is_expired도 where`로 걸어야할 것 같다**

7. 직원이라면, 내가 보낸 초대 목록도 확인할 수 있게 하여

   - answered로 응답됬는지
   - status(is_accpeted)로 수락/거부 여부도 볼 수 있게 하면 될 것 같다





### employee정보만 수정하도록 추가

- anchor tab연결을 끊고, 수동 메뉴로서 다른페이지도 받을 수 잇게 수정
- employeeForm으로는 나머지필드 안넣을시 에러나서 **employeInfoForm 새로 생성**

![image-20221224022319013](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221224022319013.png)

![image-20221224022327857](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221224022327857.png)









#### employee정보가 없는 admin이 직원정보에 들어가면 에러를 낸다 => admin계정 생성시, Employee정보도 생성하여 추가



![image-20221226151815299](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221226151815299.png)



```python
def init_script(app: Flask):
    # app -> terminal용 flask adminuser생성command를 method형태로 추가
    #     -> terminal용 [flask 메서드명]으로 사용하기 때문에 소문자이어서 지정
    # click -> flask 명령어 사용시 옵션으로 받을 값을 지정
    @app.cli.command()
    @click.option("--username", prompt=True, help="사용할 username을 입력!")
    @click.option("--password", prompt=True, hide_input=True, confirmation_prompt=True, help="사용할 password를 입력!")
    def createadminuser(username, password):
        click.echo('관리자 계정을 생성합니다.')
        with DBConnectionHandler() as db:
            # user = User(username=username, password=generate_password_hash(password), is_super_user=True)
            # user = User(username=username, password=password, is_super_user=True)
            try:
                role_admin = db.session.scalars(select(Role).where(Role.name == 'ADMINISTRATOR')).first()

                user_admin = User(username=username, password=password, email=project_config.ADMIN_EMAIL,
                                  role=role_admin)
                db.session.add(user_admin)

                #### 관리자도 직원정보를 가져야하므로 생성
                # print(user_admin.id)  # add만 해도 id가 부여된다.? => 안된다.
                db.session.flush()
                #### commit()을 하든 flush()를 하던 한번 갔다와야지 id부여된다.

                employee_admin = Employee(user_id=user_admin.id, name='관리자', sub_name='Administrator',
                                          birth='9910101918111',
                                          join_date=datetime.date.today(), job_status=JobStatusType.재직,
                                          reference='관리자 계정')

                db.session.add(employee_admin)
                db.session.commit()

                click.echo(f'관리자 계정 [{
```





### 공부 정리

#### 한 테이블의 2개이상 관계칼럼 -> fk가 2개 발생해있을테니 -> 각각의 fk를 관계마다 foreign_keys 지정

- [링크](https://thrillfighter.tistory.com/719)

- 한 테이블 내에서 **`똑같은 테이블의 관계컬럼을 2개이상` 사용할 경우는 foreign_keys 지정**해야한다. 

  - relationship함수에서 `primaryjoin` 설정 또는 `foreign_keys` 를 설정

  - EmployeeInivite

    ```python
    class User(BaseModel):
        __tablename__ = 'users'
        #...
        inviters = relationship('EmployeeInvite', backref=backref('inviter', lazy='subquery'), lazy='dynamic',
                                foreign_keys='EmployeeInvite.inviter_id'
                                )
        invitees = relationship('EmployeeInvite', backref=backref('invitee', lazy='subquery'), lazy='dynamic',
                                foreign_keys='EmployeeInvite.invitee_id'
                                )
    ```

#### 한 테이블에 자기참조 관계칼럼 -> Parent쪽 backref( , remote_side=[id]) 지정

- `remote_side`는 **자기참조 관계에서 primary key 지정에 사용**되는 것 같다. 
  - 지정은 반드시 "자신의모델(클래스명).primaykey컬럼" 을 한다. 그렇지 않으면 이상한 에러 발생한다고 한다. (위 스택오버플로 링크 참조)
    - **`관계칼럼은 fk기반인데, 자기참조에서는 fk가 자기자신으로 걸려있으니, 헷깔리지 말라고 지정해준다?`**
  - `relationship`의 첫 번째 인자의 값은 모델 클래스 이름 또는 모델 클래스 문자열로 지정한다. 자기 참조일 때는 자기 자신의 클래스 이름을 참조할 수 없기 때문에 클래스 이름을 문자열로 전달한다.

- `back_populates` 와 `backref`는 모두 자신의(테이블)의 별칭을 지정하는 것 같다. 
  
- 양방향`back_populates` 인지 단방향`backref` 으로 각각 사용되는 듯.
  
- [multiple 자기참조 스택오버플로우](https://stackoverflow.com/questions/4975793/multiple-self-referential-relationships-in-sqlalchemy)

  - Page

    ```python
    class Page(Base):
        __tablename__ = 'pages'
        id          = Column(Integer, primary_key=True)
        title       = Column(String(100), nullable=False)
        content     = Column(Text, nullable=False)
    
        parent_id   = Column(Integer, ForeignKey("pages.id"), nullable=True)
        parent      = relationship("Page",
                        foreign_keys=[parent_id], # 한 테이블에 관계 2개이상 쓸때부터 각 fk키를 직접 지정
                        remote_side=[id], # 자기참조는 원쪽에 pk를 지정
                        backref=backref("children" ))
    
        next_id     = Column(Integer, ForeignKey("pages.id"), nullable=True)
        next        = relationship("Page", 
                        foreign_keys=[next_id],
                        remote_side=[id], 
                        backref=backref("prev", uselist=False))
    ```

    

#### uselist=False는 1:1관계를 만들지만, Many쪽에 똑같은 fk가 추가되면, 기존 것은 null로 채운다 => unique=True까지 같이 주면 좋을 듯

따라서 위 코드에서는 1:1관계로 만들기 위해 `uselist=False`로 만들었습니다.
하지만 `uselist=False`는 1:1아닌 1: (0..1) 관계를 만듭니다.
실제 동작은 다음과 같습니다.

1. **address** 테이블에 동일한 `member_id`가 입력되려고 한다.
2. 동일한 `member_id` 입력에 대해서는 `member_id`를 *null*로 만들고 나머지 값들은 그대로 입력한다.
   따라서*null*로 인해 참조무결성이 희생됩니다.



더 큰 문제는 `uselist=True` 였던 테이블을 `uselist=False`로 변경한 경우입니다.
이런 경우는 데이터의 입력이 이미 이루어 졌고 입력 데이터 자체에 1:다의 관계가 형성되었다면 참조 무결성은 무참히 깨지게 됩니다.
왜냐면 `uselist=False` 자체로 테이블의 참조 무결성을 검사하지 않고 에러를 내지 않기 때문입니다. 몇몇 예제로 실험해보니 이 옵션은 단지 db단이 아닌 python코드 단에서 필터링하는 효과만 있는 것 같습니다.

저도 처음으로 문서를 살펴보는 중이므로 저 옵션을 어떻게 사용해야할지 궁금합니다. 

postgresql이 아닌 다른 데이터베이스(mysql, SQLite)과 같은 경우에 필요한 옵션이라고 생각합니다.
하지만 1:1관계는 그렇게 흔한 관계는 아니므로 다음과 같은 결론을 내고 마무리하려고 합니다.

1. 참조 무결성을 위해서는 Foreign Key(member_id)의 제약조건에 `unique=True` 옵션을 주는 것이 좋다고 생각합니다.
2. 만약 `uselist=False` 옵션을 사용한다면 `nullable=False`도 같이 주는 것이 좋다고 생각합니다. 하지만 기존 테이블이 `uselist=True` 였다면 참조 무결성을 보장할 수 없으므로 `unique=True` 옵션을 주고 데이터 참조 무결성을 해결하는 것이 좋은 해결책일 듯 싶습니다.



### Department 적용

#### 01 Model

##### Department

- auth / departments.py

  - name: 검색용(index), id대용(unique)
  - parent_id
    - 자기참조 root는 parent없어서 nullable=True
    - 자기자신의 id를 FK로
  - children
    - 관계필드 children을 사용하진 않지만, backref를 자기자신의 부모 parent를 쓰이 위함
    - backref('parent')
      - parent(One)를 바로 뽑기 위해 backref는 lazy='subquery'
      - 관계테이블이 자기테이블(자기참조)일 땐, 자기자신의 필드를 backref(parent)는 remote_side=[id]를 필수옵션으로
        - **자기참조에서 One쪽에 주는 relationship관계칼럼은 pk를 remote_side=[id]로 지정해줘야한다. `안주면 fk가 존재안하니 관계칼럼이 자동으로인식을 못할 것이다.`**
        - 원래 관계칼럼은 2개이상써서 헷깔릴 땐, relationship에 fk를 foreign_keys=[]로 지정해준다.
      - cascade='all'
  - leader_id: 팀장_id
  - leader : 다대다와 별개로 User를 One에 관계칼럼을 지정해주는게 보통이지만
    - **Many쪽에서, `fk를 직접지정해서 관계칼럼`을 지정해줄 수 있다.**
    - lazy='joined'로   `employee.leader`를 바로 쓸 수 있지만, **FK가 nullable=True**인 상황이라면 **`joined`걸어놓으면, 단순조회시에도 딸려와서 None에러** 난다
  - sort: **부서의 순서인데, `동적으로 채우기 위해, nullable=True => .save() 메서드내에서 add+commit후, 정보를 조회해서 채운다`**
  - path: 기존에는 생성순서인 id로 채웠지만, **sort(같은 부모아래 나와 동급들의 갯수)를 동적으로 파악한 뒤 -> path를 짜도록 한다**
    - index=True를 줘서 path로 검색되게 한다?
  - repr:  하이브리드 sort- > path -> level을 쓸 수 도 있지만, **sort+path 동적으로 채우기 전 출력하기에서 level호출시 에러가 남**

  ```python
  class Department(BaseModel):
      __tablename__ = 'departments'
  
      _N = 3
  
      id = Column(BigInteger().with_variant(Integer, "sqlite"), primary_key=True)
      
      name = Column(String(50), nullable=False, index=True, unique=True, comment="부서 이름")
      
      parent_id = Column(Integer, ForeignKey('departments.id'), comment="상위 부서 id", nullable=True)  # 5 
      children = relationship('Department', backref=backref(
          'parent', remote_side=[id], lazy='subquery',
          cascade='all',  # 7
      ))
  
      leader_id = Column(Integer, ForeignKey('employees.id'), nullable=True)
      leader = relationship("Employee", backref="managed_department", foreign_keys=[leader_id])  # lazy='joined')
  
      status = Column(Boolean, comment='부서 사용 상태(0 미사용, 1사용)', default=1)
      sort = Column(Integer, comment="부서 순서")  # 1 #  .order_by(Department.sort).all()
      path = Column(Text, index=True)  # 동적으로 채울거라 nullabe=True로 일단 주고, add후 다른데이터를 보고 채운다다
  
      def __repr__(self):
          info: str = f"{self.__class__.__name__}" \
                      f"[id={self.id!r}," \
                      f" title={self.name!r}," \
                      f" parent_id={self.parent_id!r}]" \
  ```

  

##### Department method 1

- exists
  - 자기참조는 save를 통해 동적으로 sort -> path를 동적으로 채울 예정인데, **save 내부에 exists를 활용**한다
  - first()로 조회해서 존재하면 True대신 해당 객체를 return한다
- save
  - 자체 존재검사를 한 뒤
  - 동적필드 **sort, path 제외하고 먼저 add commit/flush를 먼저 하여, 조회시 sort에 필요한 카운팅에 포함**되도록 한다
- level
  - path 기준 칸수를 _N으로 지정해놓은 상태인데
  - path의 길이 len을 기준칸수로 나눈 뒤 1을 뺀다
    -  root부터 3칸을 차고 있으니,  1부터 시작되는데 -1을 해야 level은 0부터 시작하게 된다.

```python
    def exists(self):
        with DBConnectionHandler() as db:
            department = db.session.scalars(select(Department).where(Department.name == self.name)).first()
            return department # 객체 or None

    def save(self):
        department_or_none = self.exists()
        if department_or_none:
            print(f"{self.name}는 이미 존재하는 부서입니다.")
            return department_or_none

        with DBConnectionHandler() as db:
            db.session.add(self)
            #### 더이상 path구성에 id를 사용하지 않으므로, flush()나 commit()을 미리 할 필요없이 => add만 해도, 자신이 포함된다.
            #db.session.flush()

            if self.parent:

                sort_count = db.session.scalar(
                    (
                        select(func.count(Department.id))
                        .select_from(Department)
                        .where(with_parent(self.parent, Department.children))
                    )
                )

                print(f'부모를 가졌으며, 해당부모의 자식수는 flush한 나를 포함하여 {sort_count}개로 sort가 정해집니다', sep=' / ')

            else:
                sort_count = db.session.scalar(select(func.count(Department.id)).where(Department.parent_id.is_(None)))
                print(f'부모가 없어 level==0인 부서는 flush한 나를 포함하여 {sort_count}개로서 sort가 정해집니다', sep=' / ')
                
            self.sort = sort_count

            prefix = self.parent.path if self.parent else ''
            self.path = prefix + f"{self.sort:0{self._N}d}"

            db.session.commit()

            return self

    @hybrid_property
    def level(self):
        return len(self.path) // self._N - 1

    @level.expression
    def level(cls):
        return func.length(cls.path) / cls._N - 1
```



##### EmployeeDepartment

- Employee별 Department별 입사하게 되면 추가정보 입사일 + 해고일이 추가되어 관계테이블을 entity로 만든다
- 각각이 fk이기 때문에 관계칼럼을 joined로 만들어준다.
  - Many에서 One에 관계를 주기 위해 fk -> foregin_keys=[ fk칼럼]을 지정해준다

```python
class EmployeeDepartment(BaseModel):
    __tablename__ = 'employee_departments'

    id = Column(BigInteger().with_variant(Integer, "sqlite"), primary_key=True)

    employee_id = Column(Integer, ForeignKey('employees.id'), nullable=False, index=True)
    department_id = Column(Integer, ForeignKey('departments.id'), nullable=False, index=True)

    # new
    employee = relationship("Employee", backref="employee_department", foreign_keys=[employee_id],
                            lazy='joined', # fk가 nullable하지 않으므로, joined를 줘도 된다.
                            )

    department = relationship("Department", backref="employee_department", foreign_keys=[department_id],
                            lazy='joined', # fk가 nullable하지 않으므로, joined를 줘도 된다.
                            )


    employment_date = Column(Date, nullable=False)
    dismissal_date = Column(Date, nullable=True)
```



#### 02  부서생성 전에 Employee를 User의 Role에 따라 골라낼 수 있도록 Entity 및 Method 정의

##### 관계속성을 관계entity를 method에서 사용할 수 있도록 Model 수정

- Employee에서 User를 Where에 `any()/has()`를 사용해야하는데 
  - **Employee내에 `backref로만 받고, 관계속성이 없으면 stmt에 쓸 수 가 없으`므로 `관계속성의 위치를 옮긴다`**

```python
class Employee(BaseModel):
    __tablename__ = 'employees'
    
    #...
    
    user_id = Column(Integer, ForeignKey("users.id"), index=True)
	# User에서 정의했던 관계속성 옮김 =>  employee = relationship('Employee', backref=backref('user', lazy='subquery'), lazy='subquery', uselist=False)
    user = relationship('User', backref=backref('employee', lazy='subquery'), lazy='subquery', uselist=False)
```

```python
class User(BaseModel):
    __tablename__ = 'users'
    
    #...
    
role_id = Column(Integer, ForeignKey('roles.id'), nullable=False)
    #### role에 정의했던 관계속성 옮김
    role = relationship('Role', backref=backref('users', lazy='dynamic'), lazy='subquery')
```



##### Employee.get_by_user_role(  Roles ):  관계속성 user를 where절 + any/has를 넣어서, User의 특정Role에 따른 Employee골라내기

- User에는 해당 Role에 따른 필터링 메서드가 정의되어있어서 활용한다
- Employee(cls)`. 관계속성.has ( 관계Entity.추가조건 )`를 활용해서 **User데이터가 존재하고 & User의 Role이 특정Role인 것으로 필터링한 Employee를 얻는다**

```python
    @classmethod
    def get_by_user_role(cls, roles: Roles):
        with DBConnectionHandler() as db:
            stmt = (
                select(cls)
                .where(cls.is_active)
            )

            if roles == Roles.USER:
                stmt = stmt.where(cls.user.has(~User.is_staff))
            elif roles == Roles.STAFF:
                stmt = stmt.where(cls.user.has(User.is_staff))
            elif roles == Roles.CHIEFSTAFF:
                stmt = stmt.where(cls.user.has(User.is_chiefstaff))
            elif roles == Roles.EXECUTIVE:
                stmt = stmt.where(cls.user.has(User.is_executive))
            elif roles == Roles.ADMINISTRATOR:
                stmt = stmt.where(cls.user.has(User.is_administrator))
            else:
                raise ValueError('잘못된 Roles를 입력했습니다.')
            return db.session.scalars(stmt).all()

```



##### bug fix -> User.is_staff   시리즈들은 전부 해당계급이상인 사람들 다 골라내니 추가조건으로, [~ User.is_상위계급] where문을 추가한다

```python
    @classmethod
    def get_by_user_role(cls, roles: Roles):
        with DBConnectionHandler() as db:
            stmt = (
                select(cls)
                .where(cls.is_active)
            )

            if roles == Roles.USER:
                stmt = stmt.where(cls.user.has(~User.is_staff))
            elif roles == Roles.STAFF:
                stmt = stmt.where(cls.user.has(User.is_staff)).where(cls.user.has(~User.is_chiefstaff))
            elif roles == Roles.CHIEFSTAFF:
                stmt = stmt.where(cls.user.has(User.is_chiefstaff)) .where(cls.user.has(~User.is_executive))
            elif roles == Roles.EXECUTIVE:
                stmt = stmt.where(cls.user.has(User.is_executive)).where(cls.user.has(~User.is_administrator))
            elif roles == Roles.ADMINISTRATOR:
                stmt = stmt.where(cls.user.has(User.is_administrator))
            else:
                raise ValueError('잘못된 Roles를 입력했습니다.')
```





#### 03 부서 생성

- .save()를 호출하면, 결과물로 생성된 객체가 반환된다. 

  - 실패해도 반환되게 했다.

  ```python
  #### (1) 부서 생성
  병원장_부서 = Department(name='병원장', leader_id=20)
  최상위_경영단_부서 = Department(name='경영단', leader_id=20)
  # session.add(병원장)
  # A. 생성시 add로 하지말고 .save()로
  병원장_부서.save() # 부모가 없어 level==0인 부서는 나를 포함하여 0개로서 sort 순서가 정해집니다 / id대신 sort로 채운 path: 000
  최상위_경영단_부서.save()
  
  이사회_부서 = Department(name='이사회', parent=최상위_경영단_부서)
  이사회_부서.save()
  이사회_부서2 = Department(name='이사회2', parent=최상위_경영단_부서)
  이사회_부서2.save()
  # A. 생성시 .save()안에  commit하지 않은 객체를 self exitst로 중복검사 해야할 듯. -> 안하면 DB의 .name unique제약만 걸림.
  
  
  Department(name='행정과', parent=병원장_부서).save()
  Department(name='원무과', parent=병원장_부서).save()
  진료부장_부서 = Department(name='진료부장', parent=병원장_부서).save()
  
  Department(name='약제과', parent=진료부장_부서).save()
  간호과 = Department(name='간호과', parent=진료부장_부서).save()
  Department(name='진료각과', parent=진료부장_부서).save()
  원장단 = Department(name='원장단', parent=진료부장_부서).save()
  ```



##### Department객체.save()  -  부모가 있으면 where with_parent( , )를 활용하여 나포함 나와동급갯수sort를, 부모없으면 부모없는 것 필터링해서 순서를 짠다

- save할 땐, **동적필드를 채우지 않은 체로 add만 시켜놓고**

  - 기존에는 path구성시 sort값이 아닌 autoincrement되는 id를 활용해서 **미리 flush()나 commit()하여 id를 배정받았으나**
  - **지금은 나포함 동급갯수 sort => path를 구성하므로 `add만 해도 나를 포함하여 조회`된다.**

- **나와 동급의 갯수를 센 뒤, 현재 순서를 마련한다**

  - 부모가 있으면 **where (`with_parent( 부모객체 , 부모Entity. 관계속성 )`을 통해  `보통은 특정 One Entity객체에 속한 Many`를 골라낼 때 쓴다**

    - 특정One객체에 속한 Many하위객체 골라내기

      ```python
      stmt = (
          select(Address)
          .where(with_parent(u2, User.addresses))
      )
      ```

    - 특정Many객체를 포함하는 One객체 골라내기

      ```python
      stmt = (
          select(User)
          .where(User.addresses.contains(a1))
      )
      ```

    - **근데 이게 `aliased`를 안쓰더라도, `자기참조에서도 사용가능`하다**

      - **`self.parent를 특정 One부모객체`로 취급한다. `One쪽이라서 subquery`로 걸어놨으니 바로 사용가능한 듯.**
      - 관계속성 자리에는 **Entity.childrend의 관계속성**을 사용한다

    - **갯수를 세기 위해 `select ( func.count ())` + `session.scalar()`를 쓰면 된다.**

    ```python
    sort_count = db.session.scalar(
        (
            select(func.count(Department.id))
            .select_from(Department)
            .where(with_parent(self.parent, Department.children))
        )
    )	
    ```

  - **부모가 없다면, `parent_id.is_(None)`으로 필터링하면 `root level`이다**

    - level 하이브리드는 아직 sort -> path -> level 순에서 sort도 안정했기 때문에 못쓴다.

- 나와 동급갯수를 self.sort에 동적으로 할당해주고

- path는 sort(나의 순서)를 바탕으로 **부모가 있다면 부모path + N자리를 맞춘 sort**로 path를 구성하여

  - 정렬시 부모별 나의순서별로 정렬된다

```python
    def save(self):
        department_or_none = self.exists()
        if department_or_none:
            print(f"{self.name}는 이미 존재하는 부서입니다.")
            return department_or_none

        with DBConnectionHandler() as db:
            db.session.add(self)
            #### 더이상 path구성에 id를 사용하지 않으므로, flush()나 commit()을 미리 할 필요없이 => add만 해도, 자신이 포함된다.
            #db.session.flush()

            if self.parent:
                sort_count = db.session.scalar(
                    (
                        select(func.count(Department.id))
                        .select_from(Department)
                        .where(with_parent(self.parent, Department.children))
                    )
                )
                # print(stmt)
                # SELECT count(departments.id) AS count_1
                # FROM departments
                # WHERE :param_1 = departments.parent_id

            else:
                sort_count = db.session.scalar(select(func.count(Department.id)).where(Department.parent_id.is_(None)))
                
            self.sort = sort_count

            prefix = self.parent.path if self.parent else ''
            self.path = prefix + f"{self.sort:0{self._N}d}"

            db.session.commit()

            return self
```







##### main.py에서 부서 생성하기

- 부서의 팀장으로 들어갈 CHIEFSTAFF이상의 employee들을 뽑아 팀장(leader)로 넣어주고 생성한다
  - 일부는 팀장없이 생성해본다

```python
    staffs = Employee.get_by_user_role(Roles.STAFF)
    chiefstaffs = Employee.get_by_user_role(Roles.CHIEFSTAFF)
    executives = Employee.get_by_user_role(Roles.EXECUTIVE)

    병원장 = Department(name='병원장', leader=executives[0])
    병원장.save()

    진료부 = Department(name='진료부', parent=병원장, leader=chiefstaffs[0]).save()
    간호부 = Department(name='간호부', parent=병원장, leader=chiefstaffs[1]).save()
    행정부 = Department(name='행정부', parent=병원장, leader=chiefstaffs[2]).save()

    #### 진료부 하위 부서 - 팀장없이
    한방진료실 = Department(name='한방진료실', parent=진료부).save()
    탕전실 = Department(name='탕전실', parent=진료부).save()
    #### 간호부 하위 부서 - 팀장없이
    외래 = Department(name='외래', parent=간호부).save()
    병동 = Department(name='병동', parent=간호부).save()
    #### 행정부 하위 부서 - 팀장없이
    원무 = Department(name='원무', parent=행정부).save()
    총무 = Department(name='총무', parent=행정부).save()
```









#### 04 입사하기 전에 입사시 position결정을 위한  DepartmentType 만들기

##### Department에 DepartmentType 필드 만들어서, => 직원부서정보 save시 => 직무[position ]필드 자동으로 입력되게 하기

```python
class DepartmentType(enum.IntEnum):
    부장 = 0  # 부서명 ex> 병원장, 진료부장, 간호부 => 끝에 장이 없으면 [부서명 + 장]
    실 = 1  # 실원, 실장 ex> 탕제실, 홍보실, 기획관리실, 정보전산실
    팀 = 2  # 팀원, 팀장 ex> 총무팀, 사무팀
    과 = 3  # 팀원, 과장 ex> 원무과, 행정과

    치료실 = 4 # 치료사, 실장
    원장단 = 5  # 원장, 대표원장
    진료과 = 6  # 원장, 과장
    의료센터 = 7  # 원장, 센터장


    연구소 = 8  # 연구원, 연구원장
    센터 = 9  # 센터원, 센터장

    위원회 = 10  # 위원, 위원장

    # form을 위한 choices에는, 선택권한을 안준다? -> 0을 value로 잡아서 제외시킴
    @classmethod
    def choices(cls):
        return [(choice.value, choice.name) for choice in cls]
    
class Department(BaseModel):
	#...
    
    #### EmployeeDepartment에 position을 남기기 위한, Type
    type = Column(IntEnum(DepartmentType), default=DepartmentType.팀, nullable=False, index=True)
```



##### 입사정보에 당시  DepartmentType에 따라 => position이 동적으로 담겨있어야한다?! (입사당시 기록으로 남아야하니 hybrid X)

```python
class EmployeeDepartment(BaseModel):

    # new 입사당시에 position을 Department.type에 따라 동적입력 -> 칼럼 nullable=True 필수 + .save()로 저장
    position = Column(String(50), nullable=True, comment="부서Type에 따른 직무")

```





##### Type넣어 Department들 새로 생성

```python
staffs = Employee.get_by_user_role(Roles.STAFF)
chiefstaffs = Employee.get_by_user_role(Roles.CHIEFSTAFF)
executives = Employee.get_by_user_role(Roles.EXECUTIVE)

병원장 = Department(name='병원장', type=DepartmentType.부장, leader=executives[0])
병원장.save()

진료부 = Department(name='진료부', type=DepartmentType.부장, parent=병원장, leader=chiefstaffs[0]).save()
간호부 = Department(name='간호부', type=DepartmentType.부장, parent=병원장, leader=chiefstaffs[1]).save()
행정부 = Department(name='행정부', type=DepartmentType.부장, parent=병원장, leader=chiefstaffs[2]).save()
```







#### 05 입사처리 in EmployeeDepartment

- 입사에는 `Employee` 1명 + `Department` 1개 + `employeement_date` 1개를 **외부에서 받아 지정**해서 만들며 **`동적으로 Department.type => position을 결정`하게 한다**
  - 부서입사일은 생성 당일이 아닐 수 있으므로 동적으로 자동 생성X
  - **추가적으로 `is_leader`를 deafult=False로 해놨으니 `리더일때만, 입력`해주면 되는데, form에서는 일단 받아야할 듯?**



##### 부임정보 .save()작성시 position결정할 때, leader여부가 여기로 왔으면 좋겠다

- 기존 Department에 따로 leader를 배정해주는 것을 삭제하고,
- 부임할 때, `is_leader`를 받아서, **팀원과 함께 팀장도 부임 정보에 포함되게 한다**

```python

class EmployeeDepartment(BaseModel):
    __tablename__ = 'employee_departments'
    
    #...
    
    # new 입사당시에 position을 Department.type에 따라 동적입력 -> 칼럼 nullable=True 필수 + .save()로 저장
    position = Column(String(50), nullable=True, comment="부서Type에 따른 직무")
    # new 입사당시에 is_leader인지를 받아서, 그것에 따른 position이 입력되게 해준다. => Department의 leader는 삭제하자.
    #### => 팀장, 팀원 모두가 부임정보에 나와있게 된다.
    is_leader = Column(Boolean, nullable=False, default=False)
```

- **나중에 leader부터 나오게하려면 마지막에 역순으로 정렬하면 된다.**

  - ##### [점프 투 플라스크] 공지 및 상단 고정 기능 https://pybo.kr/pybo/question/detail/904/

  ```python
  _question_list = _question_list.order_by('-notice', '-create_date')
  ```





##### 부서마다 부서장(leader)부임일 때만 is_leader=True 그외 기본정보3개를 넣고 .save() 로 생성한다

```python
    ed = EmployeeDepartment(
        department=병원장,
        employee=executives[0],
        employment_date=datetime.date.today(),
        is_leader=True
    ).save()

```



- save는 동적 필드 position을 `부서type`에 따라  `is_leader`에 따라 **position을 결정해서 넣어준다**

  ```python
      def save(self):
          #### 팀장이 이미 존재하는지 여부 / 같은부서에 부임하는지 여부
  
          #### 진료부장, 병원장도 기록이 남으려면, 팀원으로 받아서 => 부임정보에 남겨져야한다 => is_leader의 개발
          dep_name = self.department.name
          # 1) 부/장부서 => ~장, ~부장
          if self.department.type == DepartmentType.부장:
              if self.is_leader:
                  self.position = dep_name + ('' if dep_name.endswith('장') else '장') # 장으로 끝나지 않는 간호부 => 간호부 + 장이 되게 한다
              else:
                  raise ValueError('부/장 부서는 팀원 없이, 리더 1명만 입력해야합니다.')
          # 2) 실 => 실장 - 실원
          elif self.department.type == DepartmentType.실:
              self.position = '실장' if self.is_leader else '실원'
          # 3) 팀 => 팀장 - 실원
          elif self.department.type == DepartmentType.팀:
              self.position = '팀장' if self.is_leader else '팀원'
          # 4) 과 => 과장 - 팀원
          elif self.department.type == DepartmentType.과:
              self.position = '과장' if self.is_leader else '팀원'
          # 5) 치료실 => 실장 - 치료사
          elif self.department.type == DepartmentType.치료실:
              self.position = '실장' if self.is_leader else '치료사'
          # 6) 원장단 => 대표원장 - 원장
          elif self.department.type == DepartmentType.원장단:
              self.position = '대표원장' if self.is_leader else '원장'
          # 7) 진료과 => 과장 - 원장
          elif self.department.type == DepartmentType.진료과:
              self.position = '과장' if self.is_leader else '원장'
          # 8) 의료센터 => 센터장 - 원장
          elif self.department.type == DepartmentType.의료센터:
              self.position = '센터장' if self.is_leader else '원장'
          # 9) 연구소 => 연구소장 - 연구원
          elif self.department.type == DepartmentType.연구소:
              self.position = '연구소장' if self.is_leader else '연구원'
          # 10) 센터 => 센터장 - 센터원
          elif self.department.type == DepartmentType.센터:
              self.position = '센터장' if self.is_leader else '센터원'
          # 11) 위원회 => 위원장 - 위원
          elif self.department.type == DepartmentType.위원회:
              self.position = '위원장' if self.is_leader else '위원'
  
          with DBConnectionHandler() as db:
              db.session.add(self)
              db.session.commit()
  
          return self
  
  ```

  





##### 부서Type enum마다 position이 정해지므로, enum find_position method로 로직 옮기기

- 각 EmployeeDepartment 부임정보 객체마다, 들고 있는 관계객체 self.deparment의 .type에서 호출할 것이다.
  - 인스턴스 메서드로 정의한다

```python
    def find_position(self, is_leader, dep_name):
        # 1) 부/장부서 => ~장, ~부장
        if self == DepartmentType.부장:
            if is_leader:
                return dep_name + ('' if dep_name.endswith('장') else '장')  # 장으로 끝나지 않는 간호부 => 간호부 + 장이 되게 한다
            else:
                raise ValueError('부/장 부서는 팀원 없이, 리더 1명만 입력해야합니다.')
        # 2) 실 => 실장 - 실원
        elif self == DepartmentType.실:
            return '실장' if is_leader else '실원'
        # 3) 팀 => 팀장 - 실원
        elif self == DepartmentType.팀:
            return '팀장' if is_leader else '팀원'
        # 4) 과 => 과장 - 팀원
        elif self == DepartmentType.과:
            return '과장' if is_leader else '팀원'
        # 5) 치료실 => 실장 - 치료사
        elif self == DepartmentType.치료실:
            return '실장' if is_leader else '치료사'
        # 6) 원장단 => 대표원장 - 원장
        elif self == DepartmentType.원장단:
            return '대표원장' if is_leader else '원장'
        # 7) 진료과 => 과장 - 원장
        elif self == DepartmentType.진료과:
            return '과장' if is_leader else '원장'
        # 8) 의료센터 => 센터장 - 원장
        elif self == DepartmentType.의료센터:
            return '센터장' if is_leader else '원장'
        # 9) 연구소 => 연구소장 - 연구원
        elif self == DepartmentType.연구소:
            return '연구소장' if is_leader else '연구원'
        # 10) 센터 => 센터장 - 센터원
        elif self == DepartmentType.센터:
            return '센터장' if is_leader else '센터원'
        # 11) 위원회 => 위원장 - 위원
        elif self == DepartmentType.위원:
            return '위원장' if is_leader else '위원'
```







##### 외부에서 department객체가 아니라 , front에서 온 fk_id로 입력해서 생성하면 작동할까? => id배정이 필요없더라도 add / flush 한번 한 뒤, fk_id 입력이라도 관계객체로 연동시키고 동적필드 채우기~!

- `self.department`의  `.type`과 `.name`을 다 활용해야한다
  - **joined, subquery로 연결되어있지 않아도 `같은 세션내에서 관계객체 속성 호출은 자유`롭다**
- **외부에서 `department_id=`로 입력해도 `self.department`를 로직에서 쓸 수 있을 까?**
  - **session.add( self ). `session.flush() 나 commit()`을 한번 해서, `동적nullable필드를 제외하고 DB에 저장 한번`해줘야 `fk_id <-> 관계속성`이 연동된다.**

```python
    def save(self):
        #### 팀장이 이미 존재하는지 여부 / 같은부서에 부임하는지 여부

        with DBConnectionHandler() as db:
            #### flush나 commit을 하지 않으면 => fk_id 입력 vs fk관계객체입력이 따로 논다.
            #### => 한번 갔다오면, 관계객체 입력 <-> fk_id 입력이 동일시되며, fk_id입력으로도 내부에서 관계객체를 쓸 수 있게 된다.
            #### => 즉 외부에서 department_id=로 입력해도, 내부에서 self.department객체를 쓸 수 있게 된다.
            db.session.add(self)
            db.session.flush()

            self.position = self.department.type.find_position(is_leader=self.is_leader, dep_name=self.department.name) # joined를 삭제하면 fk만 넣어줘도 이게 돌아갈까?
            
            #### 한번만 session에 add해놓으면, 또 add할 필요는 없다.
            # db.session.add(self)
            db.session.commit()

        return self
```





##### save전 exists를 하되, 같은 부서에 대해서만 하기 (한 사람이 여러부서에 부임할 수 있다)

- add와 달리 flush할 일이 없는 쿼리문으로
  - **객체를 미리 만들어 판단하므로 fk_id입력 or fk관계객체입력을 `if else로 구분한 뒤 id만 추출`하였다.**

```python
    #### (1) 같은부서에 대해서만 존재 여부 확인 -> 다른 부서에는 또 부임할 수 있다.
    def exists_same_department(self):
        with DBConnectionHandler() as db:
            # Employee는 자신의 필수정보(name)으로만 중복검사햇으나
            # 여기서는 fk_id or fk관계객체를 이용해서 검사해야한다? => 둘중에 뭐가 들어올지 모르면서, add/flush하진 않을 것 같은데..
            #### 여기선 flush로 db에 갖다올 일이 없으니, 해당객체의 입력상황을 if 관계객체 else fk_id 로 나눠서 id를 뽑아서 검사하자
            dep_id = self.department.id if self.department else self.department_id
            emp_id = self.employee.id if self.employee else self.employee_id
            emp_dep = db.session.scalars(
                select(EmployeeDepartment) \
                    .where(EmployeeDepartment.dismissal_date.is_(None))  # 아직 끝나지 않은 부임정보에 대해
                    .where(EmployeeDepartment.employee_id == emp_id)  # 해당직원의 정보가
                    .where(EmployeeDepartment.department_id == dep_id)  # 해당부서에 부임정보가 이미 존재하는지
            ).first()
            return emp_dep  # 객체 or None

    def save(self):
        #### (1) 퇴직정보제외하고 & 해당 지원부서에 대해서 & 해당직원이 이미 존재하는지 여부 확인 -> 다른 부서에는 또 부임할 수 있다.
        emp_dep_or_none = self.exists_same_department()
        if emp_dep_or_none:
            print('이미 부임된 부서입니다.')
            return emp_dep_or_none
```



##### exists 2 : 팀장은 1명만 부임정보를 남길 수 있으므로 self.is_leader = True지원시 [해당부서 부서장이 이미 존재하는지] 여부 확인

```python

    #### (2) is_leader로 지원했는데, 팀장이 이미 차 있는지 여부
    def exists_already_leader(self):
        with DBConnectionHandler() as db:
            dep_id = self.department.id if self.department else self.department_id
            is_already_leader = db.session.scalars(
                select(EmployeeDepartment) \
                    .where(EmployeeDepartment.dismissal_date.is_(None)) # 퇴직정보가 아닌 것 중
                .where(EmployeeDepartment.department_id == dep_id) # 해당부서 정보 중
                .where(EmployeeDepartment.is_leader == True) # 팀장이 이미 있는지
            ).first()
            return is_already_leader

    def save(self):
        #### (1) 퇴직정보제외하고 & 해당 지원부서에 대해서 & 해당직원이 이미 존재하는지 여부 확인 -> 다른 부서에는 또 부임할 수 있다.
        emp_dep_or_none = self.exists_same_department()
        if emp_dep_or_none:
            print('이미 부임된 부서입니다.')
            return emp_dep_or_none

        #### (2) is_leader로 지원했는데, 팀장이 이미 차 있는지 여부
        #### 조건에 is_leadear가 True여야한다.
        if self.is_leader and self.exists_already_leader():
            print('해당부서에 이미 부서장이 존재합니다.')
            return None

```



```python
    대표원장_추가로_취임 = EmployeeDepartment(
        department=한방진료실,
        employee=chiefstaffs[1], # 추가로 다른사람을 부임시키면 -> 부서장 이미 있다고 든다.
        employment_date=datetime.date.today(),
        is_leader=True # 이미 is_leader가 있는 부서인데
    ).save()
```

![image-20221228171801308](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221228171801308.png)





##### exists 3 : 부/장급 Department의 부임은 is_leader와 무관하게 팀원은 1명만 받도록 확인하기

```python
    #### (3) 부/장급 부서는 only 1명만 등록가능하고, is_leader가 체크안되어있더라도, 체크해줘야한다
    def is_full_in_one_person_department(self):
        with DBConnectionHandler() as db:
            if self.department:
                dep_type = self.department.type
            else:
                # department_id로 입력된 경우
                dep_type = db.session.scalars(
                    select(Department)
                    .where(Department.id == self.department_id)
                ).first().type

            if dep_type != DepartmentType.부장:
                return False
            # (부/장급 부서인 경우) => 미리 데이터가 나오면 탈락
            is_full = db.session.scalars(
                select(EmployeeDepartment)
                .where(EmployeeDepartment.dismissal_date.is_(None))
                .where(
                    EmployeeDepartment.department_id == (self.department.id if self.department else self.department_id))
            ).first()
            return is_full
```

```python
    부장급_부서에_추가_가입시_안됨 = EmployeeDepartment(
        department=병원장,
        employee=chiefstaffs[0],
        employment_date=datetime.date.today(),
        # is_leader=True # 부서장이든 말든 부장급부서는 1명이 이미 존재하면 -> 1명만 부임가능 부서라고 뜬다.
    ).save()
```

![image-20221228220620287](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221228220620287.png)



##### save() 로직에 부장급 부서면 무조건 1명인데, 팀장으로 부임하게 하기

```python
with DBConnectionHandler() as db:
    #### flush나 commit을 하지 않으면 => fk_id 입력 vs fk관계객체입력이 따로 논다.
    #### => 한번 갔다오면, 관계객체 입력 <-> fk_id 입력이 동일시되며, fk_id입력으로도 내부에서 관계객체를 쓸 수 있게 된다.
    #### => 즉 외부에서 department_id=로 입력해도, 내부에서 self.department객체를 쓸 수 있게 된다.
    db.session.add(self)
    db.session.flush()  # fk_id 입력과 fk관계객체입력 둘중에 뭘 해도 관계객체를 사용할 수 있게 DB한번 갔다오기

    self.position = self.department.type.find_position(is_leader=self.is_leader,
                                                       dep_name=self.department.name)  # joined를 삭제하면 fk만 넣어줘도 이게 돌아갈까?

    #### 부장급 부서의 취임이라면, is_leader를 무조건 True로 넣어준다.
    if self.department.type == DepartmentType.부장:
        self.is_leader = True

        #### 한번만 session에 add해놓으면, 또 add할 필요는 없다.
        # db.session.add(self)
        db.session.commit()

return self
```





### save()외 기능들 개발하기

#### 참고) 부서 사용을 위해  Department.get_by_name() 정의하기

```python
@classmethod
def get_by_name(cls, name: str):
    with DBConnectionHandler() as db:
        dep = db.session.scalars(
            select(Department).where(Department.status == 1).where(Department.name == name)).first()
        return dep

```

#### 00 특정 부서정보 -> employee_id -> 뽑아서 가상 current_user로 만드는 코드

- User를 뽑는데, **필터링 entity로 Employee를 One에 속하는 User가  any()에 사용**

```python
#### 진료부장을 current_user로 생각해서, 부서+자식부서들 선택 / 나보다 하위직원 뽑기
current_employee_id = 진료부장_취임.employee_id
stmt = (
    select(User)
    .where(User.employee.any(Employee.id == current_employee_id))
)
current_user = session.scalars(stmt).first()
```



#### 01 [부서장의 직원추가]시  내가 팀장으로 소속된 부서정보 -> 모든 자식 부서들 정보

#####  01-01[내가 속한 부서정보 구하기] EmployeeDepartment -> has: 필터링entity Employee -> 추가조건에 관계필드: 2번재필터링entity 까지 연결

- 관계Entity는 `join 후 where필터링`도 있지만, **`select에 추가객체.칼럼을 안쓸거면 필요없을 것 같다`**
- **기본적으로 관계Entity필터링은 `where( 관계속성.any/has(  관계Entity. 추가조건))`을 이용하여**
  - **`필터링에 필요한 관계entity에 대해,  관계가 연결된 정보만`를 join처럼 .any, .has로 만들고**
  - **`관계entity.필터링 필드 == `로 추가조건을 걸어서 필터링한다 **

1. **`EmployeeDepartment` -> 필터링용  관계entity `Employee` 를 우선 연결한다**
2. **Employee.필드로 필터링시 `Employee.관계2entity필드 == 관계2필터링값`으로 `추가조건에서 2번째관계entity필드를 활용`하면 `2단계 건너띈 관계 필터링`이 가능하다**

3. 추가로 내가 팀장인 부서정보를 가져와야한다.

   ```python
   ## (1) 내가 팀장으로 속한 부서정보들 구하기
   print('*' * 50)
   # 1-1.  부서정보를 뽑되, 필터링 entity를 Employee -> .user_id or user로 User까지 사용하면 된다.
   # 1) 최종적으로 구할 객체의 entity -> select에
   # 2) Ed -> .any()/.has()로 Employee로 먼저 1차 필터링 entity 연결 (기본조건)
   # 3) Employee.관계피륻(fk_id)로 2차 필터링 entity 연결
   # 4) 그정보들 중에 내가 팀장으로 있는 부서정보
   stmt = (
       select(EmployeeDepartment)
       .where(EmployeeDepartment.dismissal_date.is_(None))
       .where(EmployeeDepartment.employee.has(Employee.user == current_user))
       .where(EmployeeDepartment.is_leader == True)
   )
   
   emp_dep_leader_all = session.scalars(
       stmt
   ).all()
   
   print(stmt)
   
   print(emp_dep_leader_all)
   # SELECT employee_departments *
   # FROM employee_departments
   # WHERE employee_departments.dismissal_date IS NULL
   #   AND (EXISTS (SELECT 1
   #       FROM employees
   #       WHERE employees.id = employee_departments.employee_id
   #           AND :param_1 = employees.user_id))
   #  AND employee_departments.is_leader = true
   
   # [EmployeeDepartment[id=1, title='123', parent_id='병원장'], EmployeeDepartment[id=2, title='123', parent_id='진료부'], EmployeeDepartment[id=3, title='123', parent_id='한방진료실']]
   ```

   



##### 01-02 [ level이 가장 낮은 부서 필터링 ] EmployeeDepartment -> Department쪽으로 필터링용 관계entity any()/has()를 걸고 + Scalar_subquery를 통해 Deparmtent의 level  최소값으로 필터링하기

- **집계값을 이용하려면, 기본적으로 where 필드 == ( SELECT  집계1개 subquery )를 걸어야한다**
  - **sqlahcmey에서는 `.scalar_subquery()`를 만들어서 where에 걸어주면 된다.**
- 현재까지는 `내가 팀장으로 소속된 부서정보들`인 상태인데 **`내가 팀장으로 소속된 부서정보들`에 `가장 상위(Department.level 최소값) 부서`를 골라내야한다**
  - **`필터링용 관계entity를 걸고 .department.has()`로 걸고 `추가 조건에 Department.level == scalar_subquery`를 걸어주면 된다.**
    - **이 때, cls메서드에서 서브커리걸땐 `.correlate(cls)`로 걸어줬어야했는데, 여기선 `관계속성.has()로 이미 연결되어있어서` 안걸어줘도 된다.**
- min_level 으로 필터링해도 **같은 level의 부서가 2개일 수 도 있으니 .all()로 list로 반환됨을 생각**한다

```python
    subq_scalar_min_level = (
        select(func.min(Department.level))
    ).correlate(EmployeeDepartment) \
        .scalar_subquery()

    stmt = (
        select(EmployeeDepartment)
        .where(EmployeeDepartment.dismissal_date.is_(None))
        .where(EmployeeDepartment.employee.has(Employee.user == current_user))
        .where(EmployeeDepartment.is_leader == True)
        # 내가 팀장 인 부서정보들 중, level이 가장 낮은 것으로 필터링 => 여러개일 수 있다.
        .where(EmployeeDepartment.department.has(Department.level == subq_scalar_min_level))
    )

    emp_dep_leader_min_level = session.scalars(
        stmt
    ).all()


    # print(stmt)
    # SELECT employee_departments.add_date, employee_departments.pub_date, employee_departments.id, employee_departments.employee_id, employee_departments.department_id, employee_departments.employment_date, employee_departments.dismissal_date, employee_departments.position, employee_departments.is_leader
    # FROM employee_departments
    # WHERE employee_departments.dismissal_date IS NULL AND (EXISTS (SELECT 1
    # FROM employees
    # WHERE employees.id = employee_departments.employee_id AND :param_1 = employees.user_id)) AND employee_departments.is_leader = true AND (EXISTS (SELECT 1
    # FROM departments
    # WHERE departments.id = employee_departments.department_id AND length(departments.path) / :length_1 - :param_2 = (SELECT max(length(departments.path) / :length_2 - :param_3) AS max_1
    # FROM departments)))

    print(emp_dep_leader_min_level)
    # [EmployeeDepartment[id=1, title='123', parent_id='병원장']]

```



##### 01-03 [ 부서정보 -> 부서로 변환] 부서정보의 id만 select한 stmt를 scalar_subquery로 만든 뒤, Department에서 .id.in_()

```python
    ## (3) 팀장인  min level 부서정보들 => 부서객체로 변환하기?
    subq = (
        select(EmployeeDepartment.department_id)
        .where(EmployeeDepartment.dismissal_date.is_(None))
        .where(EmployeeDepartment.employee.has(Employee.user == current_user))
        .where(EmployeeDepartment.is_leader == True)
        # 내가 팀장 인 부서정보들 중, level이 가장 낮은 것으로 필터링 => 여러개일 수 있다.
        .where(EmployeeDepartment.department.has(Department.level == subq_scalar_min_level))
    ).scalar_subquery()

    stmt = (
        select(Department)
        .where(Department.id.in_(subq))
    )

    print(stmt)
    print(session.scalars(stmt).all())
    # SELECT departments.add_date, departments.pub_date, departments.id, departments.name, departments.parent_id, departments.status, departments.sort, departments.path, departments.type
    # FROM departments
    # WHERE departments.id IN (SELECT employee_departments.department_id
    # FROM employee_departments
    # WHERE employee_departments.dismissal_date IS NULL AND (EXISTS (SELECT 1
    # FROM employees
    # WHERE employees.id = employee_departments.employee_id AND :param_1 = employees.user_id)) AND employee_departments.is_leader = true AND (EXISTS (SELECT 1
    # FROM departments
    # WHERE departments.id = employee_departments.department_id AND length(departments.path) / :length_1 - :param_2 = (SELECT min(length(departments.path) / :length_2 - :param_3) AS min_1
    # FROM departments))))
    # [Department[id=1, title='병원장', parent_id=None]]
```



- 혹은 id scalar_subquery없이 부서정보 객체를 id만 뽑아서 필터링

  ```python
      stmt = (
          select(Department)
          .where(Department.id.in_([x.department_id for x in user_leader_min_level_deps]))
      )
  
      print(stmt)
      print(session.scalars(stmt).all())
  ```

  



##### 01-04 [개선]  부서정보가 아니라 부서필요하므로, ids scalar_subquery로 부서로 먼저 변환후, min_level 필터링

```python
    ## (4) 개선 -> 부서로 먼저 변환후 minlevel필터링
    user_leader_dep_ids = (
        select(EmployeeDepartment.department_id)
        .where(EmployeeDepartment.dismissal_date.is_(None))
        .where(EmployeeDepartment.employee.has(Employee.user == current_user))
        .where(EmployeeDepartment.is_leader == True)
    ).scalar_subquery()

    min_level = (
        select(func.min(Department.level))
    ).scalar_subquery()

    stmt = (
        select(Department)
        .where(Department.id.in_(user_leader_dep_ids))
        .where(Department.level == min_level)
    )

    print(stmt)
    print(session.scalars(stmt).all())
    # SELECT departments 
    # FROM departments 
    # WHERE departments.id IN (SELECT employee_departments.department_id 
    #       FROM employee_departments 
    #       WHERE employee_departments.dismissal_date IS NULL AND (EXISTS (SELECT 1 
    #           FROM employees 
    #           WHERE employees.id = employee_departments.employee_id AND :param_1 = employees.user_id)) 
    #       AND employee_departments.is_leader = true) 
    # AND length(departments.path) / :length_1 - :param_2 = (SELECT min(length(departments.path) / :length_2 - :param_3) AS min_1 
    #       FROM departments)
    # [Department[id=1, title='병원장', parent_id=None]]
```







	#### 여기까지 메서드화

##### 01 User -> get_departments(as_leader=, min_level=) 

```python
    def get_departments(self, as_leader=False, min_level=False):
        with DBConnectionHandler() as db:
            # 부서정보 -> Employee -> User 관계필터링
            subq_stmt = (
                select(EmployeeDepartment.department_id)
                .where(EmployeeDepartment.dismissal_date.is_(None))
                .where(EmployeeDepartment.employee.has(Employee.user == self))
            )
            # 부서 중에 내가 팀장인 부서정보만
            if as_leader:
                subq_stmt = subq_stmt.where(EmployeeDepartment.is_leader == 1)

            dep_ids = (
                subq_stmt
            ).scalar_subquery()
            
            # 내가 (팀장으로) 소속중인 부서 추출 
            stmt = (
                select(Department)
                .where(Department.id.in_(dep_ids))
            )

            # 내가 (팀장으로) 소속중인 부서 중에 가장 높은 부서 (level 낮은 부서) 필터링 -> 여러개 or [] 일 수 있음.
            if min_level:
                min_level = (
                    select(func.min(Department.level))
                ).scalar_subquery()

                stmt = stmt.where(Department.level == min_level)
            return db.session.scalars(stmt).all()
```

```python
current_user.get_departments() >> [Department[id=1, title='병원장', parent_id=None], Department[id=2, title='진료부', parent_id=1], Department[id=5, title='한방진료실', parent_id=2]]
current_user.get_departments(as_leader=True) >> [Department[id=1, title='병원장', parent_id=None], Department[id=2, title='진료부', parent_id=1], Department[id=5, title='한방진료실', parent_id=2]]
current_user.get_departments(as_leader=True, min_level=True) >> [Department[id=1, title='병원장', parent_id=None]]
```

![image-20221229034633688](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221229034633688.png)





#### 0 [부서조회후 순서변경시] 모든부서 조회 + (같은level내) sort 교환로직 처리

##### 00 부서 조회를 위한 get_by_name + .path정렬한 조회 get_all   정의하기

```python
    @classmethod
    def get_by_name(cls, name: str):
        with DBConnectionHandler() as db:
            dep = db.session.scalars(
                select(Department)
                .where(Department.status == 1)
                .where(Department.name == name)
            ).first()
            return dep

    @classmethod
    def get_all(cls):
        with DBConnectionHandler() as db:
            dep = db.session.scalars(
                select(cls)
                .where(cls.status == 1)
                .order_by(cls.path)
            ).all()
            return dep
```





##### 01 모든 부서 조회는 .path정렬로 조회하고, 개별객체마다 .level로 패딩을 넣어서 출력한다

- **`path`에는 `나의 자식들`을 다 뿌려주고 +  각 level에 대해서`sort`가 반영된다.**
  - **`sort`는 특정level의 부서들 대해서만 정렬에 의미 있다.**
  - **`level`은 특정level의 부서들을 뽑을 일은 거의 없고 `출력시 padding`으로 사용될 예정이다.**

```python
stmt = (
    select(Department)
    .order_by(Department.path)
)

for it in session.scalars(stmt):
    print(it.level * '    ', it)
print('*' * 30)

# 부서조회 ******************************
#  Department(id=1, title='병원장', parent_id=None) path='001',
#      Department(id=2, title='진료부', parent_id=1) path='001001',
#          Department(id=5, title='한방진료실', parent_id=2) path='001001001',
#          Department(id=6, title='탕전실', parent_id=2) path='001001002',
#      Department(id=3, title='간호부', parent_id=1) path='001002',
#          Department(id=7, title='외래', parent_id=3) path='001002001',
#          Department(id=8, title='병동', parent_id=3) path='001002002',
#      Department(id=4, title='행정부', parent_id=1) path='001003',
#          Department(id=9, title='원무', parent_id=4) path='001003001',
#          Department(id=10, title='총무', parent_id=4) path='001003002',
# ******************************
```



##### 02 sort를 바꾸면 -> 나포함 자식들(path.like( 내path + '%'))의 path도 같이 일괄변경하기

1. 부서객체의 `.sort를 먼저 변경`하고
2. `.parent` 관계객체 in session로 `부모 부서의 path`를 `prefix`로 그대로 살리고 (부모없으면 빈문자열)
3. `새sort`로 `새path`를 새로 만든다.
4. **path는 객체에 미리 변경하지 않아야한다. 왜냐면 `변경 전 path + like`로 자신+자식들 모두를 골라내야하기 때문 **
   - **path는 `자신을 포함`하여 자식들과 함께 일괄  path변경을 할 것이다.**
5. update를 할 땐 
   1. `.where(Department.path.like(진료부.path + '%'))`를 통해 **현재path + %로 `나를 포함한 자식들`이 다 나오게 된다.**
   2. **자식들의 기존path는  `부모path` + `나의sort에 의한path`인데, `나의 sort-path`는 안변하고 부모만 바꿔줘야한다**
   3. `부모의 새path` + `func.substr(Department.path, len(after_진료부_path) + 1)`를 통해 
      - **func.substr( , )를, 기존full_path에서 부모의새path만 빼고, `나의 sort-path만큼믄 substring`한다**
   4. **python변수를 사용한 execute + update문을 수행할 땐 `.execution_options(synchronize_session='fetch')`를 필수로 달아줘야 SQL과 python이 융합된다.**

```python
session.commit()  # 같은 데이터를 다시 불러와서 쓰기 위해. 세션 정리하기

#### 일단 자신의 path부터 바꾸기 => parent의 path에서 덧칠
진료부 = Department.get_by_name('진료부')
간호부 = Department.get_by_name('간호부')

## 다른 세션에서 가져온 객체의 관계객체를 쓰려면 현재session에서 add해놓고 써야한다.
session.add_all(
    [진료부, 간호부]
)

# .save()없이 일괄적으로 path를 자식포함 바꾸더라도, 내 sort는 먼저 바꿔놔야한다.
진료부.sort = 1  # 1 -> 2
간호부.sort = 2  # 2 -> 1
session.commit()

prefix = 진료부.parent.path if 진료부.parent else ''
after_진료부_path = prefix + f"{진료부.sort:0{진료부._N}d}"
#      Department(id=3, title='간호부', parent_id=1) sort=1) path='001001',
#          Department(id=5, title='한방진료실', parent_id=2) sort=1) path='001001001',
#          Department(id=6, title='탕전실', parent_id=2) sort=2) path='001001002',
#      Department(id=2, title='진료부', parent_id=1) sort=2) path='001002',
#          Department(id=7, title='외래', parent_id=3) sort=1) path='001002001',
#          Department(id=8, title='병동', parent_id=3) sort=2) path='001002002',


stmt = (
    update(Department)
    .where(Department.path.like(진료부.path + '%'))
    .values({Department.path: after_진료부_path + func.substr(Department.path, len(after_진료부_path) + 1)})
    .execution_options(synchronize_session='fetch') # execute만 하는 update expression에 python메서드를 사용해서 업데이트하려면 필수옵션이다(안그럼 sql식에 이진수가 들어간 꼴)
)
session.execute(stmt)
session.commit()
```



##### 04 메서드화 sort변경 + 나포함자식들 path일괄변경  with exchange

###### sort를 혼자서 변경하다가 겹치면 참사이므로 sort변경은 서로 한다. view를 고려해 2개의 id를 받아서 서로 교환한다.



###### Department -> change_sort_by_id( id1, id2) + 주의점

- **혼자변경할 때와 달리 교환시 주의점**은 **1개를 `먼저 다른놈의 path로 변경해버리면, 남은 놈의 바꿀path검색시 앞에놈들이 검색되버리는 참사`가 일어나니, `순차적 update문이 아닌 select 2개 다 -> update 2개다`로 먼저 골라내야한다.**

```python
    @classmethod
    def change_sort_by_id(cls, id_a, id_b):
        with DBConnectionHandler() as db:
            dep_a = db.session.get(cls, id_a)  # get으로 찾앗으면 이미 add된 상태라서 commit만 하면 바뀐다? => execute때문에 자동 커밋 되는 듯.
            dep_b = db.session.get(cls, id_b)

            dep_a.sort, dep_b.sort = dep_b.sort, dep_a.sort

            # path는 기존path로 필터링해야하니 변수로 만들어놓는다.
            a_prefix = dep_a.parent.path if dep_a.parent else ''  # 부모는 안바뀌고
            new_a_path = a_prefix + f"{dep_a.sort:0{cls._N}d}"  # 자신은 바뀐sort로 바뀐apth를 만든다

            b_prefix = dep_b.parent.path if dep_b.parent else ''
            new_b_path = b_prefix + f"{dep_b.sort:0{cls._N}d}"

            #### 각각 update를 떼리면, 뒤에것의 바뀐path로 검색시  바뀐a들이 걸려버린다.
            #### => 업뎃하기 전에 둘다 미리 select해놓고, 이후 update한다.
            a_and_subs = db.session.scalars(select(cls).where(cls.path.like(dep_a.path + '%'))).all()
            b_and_subs = db.session.scalars(select(cls).where(cls.path.like(dep_b.path + '%'))).all()

            for a_or_sub in a_and_subs:
                a_or_sub.path = new_a_path + a_or_sub.path[len(new_a_path):]

            for b_or_sub in b_and_subs:
                b_or_sub.path = new_b_path + b_or_sub.path[len(new_b_path):]
                
            db.session.commit()
```



##### 같은level내에서만 가능하도록 예외처리 추가

```python
@classmethod
def change_sort_by_id(cls, id_a, id_b):
    with DBConnectionHandler() as db:
        dep_a = db.session.get(cls, id_a)  # get으로 찾앗으면 이미 add된 상태라서 commit만 하면 바뀐다? => execute때문에 자동 커밋 되는 듯.
        dep_b = db.session.get(cls, id_b)

        #### 같은 레벨 내의 sort 교환이어햐만 한다 => 아닐시 에러 추가
        if dep_a.leve != dep_b.level:
            raise ValueError('같은 level의 부서만 순서변경이 가능합니다.')
```





#### 04 [부서 수정시] 부모로 선택가능한 부서 = 전체 - (나와, 내자식들 제외)

