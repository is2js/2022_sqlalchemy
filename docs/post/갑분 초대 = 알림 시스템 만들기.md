### 갑분 초대 => 알림 시스템 만들기



#### Invite 분석정리하기



1. employee(current_user)는 특정User에 대해 `[직원전환] -> employee가 입력` 대신 `[직원초대]`를 누르면

   - `employee/invites` route에서
     - current_user -> ~~employee_id~~(`inviter_id`) - > **user_id** 항상 직원->User초대만 있는 것이 아니기 때문에 공용적인 user_id를 넣는다
     - 상대user -> user_id(`invitee_id`)
       - ~~employee~~는 user는 Invite.inviter_id에 대한 one으로서 `.inviters`를 통해, `내가 보낸 초대들`을 볼 수 있다.
       - users는 invite.invitee_id에 대한 one으로서 `.invitees`를 통해, `내가 받은 초대들`을 볼 수 있다.
     - **초대의 주제type  or  상위 주제entity의 id(fk)**
       - ~~ex> employee관련 이므로, employee_id를 넣고 하위의 초대로 만들게 한다~~
       - 검색이나 조회를 위해 `초대들마다 상위주제`가 정해져있어야한다.
         - 특정 예약entity에 대한 초대가 아니므로, 상위entity 없다
     - 까지만 넣고, 내부 deafult값으로 status, answered False로 Invite객체를 만든다

   ```python
   class Inivite
   #class PlayerInvite(db.Model):
       playerinvite_id = db.Column(db.Integer, primary_key=True)
       # invitees
       guest_id = db.Column(db.Integer, db.ForeignKey('player.player_id'))
       # inviters
       host_id = db.Column(db.Integer, db.ForeignKey('player.player_id'))
       # 상위주제entitye대신 초대 Category Type으로
       #booking_id = db.Column(db.Integer, db.ForeignKey('booking.booking_id'))
   
       status = db.Column(db.Boolean, default=False)
       answered = db.Column(db.Boolean, default=False)
   
   ```

   

   ```python
   guests = db.relationship("PlayerInvite", foreign_keys='PlayerInvite.guest_id')
   
   hosts = db.relationship("PlayerInvite", foreign_keys='PlayerInvite.host_id')
   ```

   

   

   ```python
   @player.route('/players/invite/add', methods=['POST'])
   @token_required
   def invite_player(current_user):
       data = request.get_json()
       invite = PlayerInvite(guest_id=data['guest_id'],
                             host_id=data['host_id'],
                             booking_id=data['booking_id'])
       db.session.add(invite)
       db.session.flush()
       db.session.commit()
       return {'message': 'Success!'}
   ```

   



2. employee가 `[직원초대]`를 누르면  초대 뿐만 아니라 **notification이 해당 user에게 가야할 것**이다.



3. 초대받은 user는 notification을받아 -> `메세지`상의 `[직원 초대 수락]` 를 클릭할 것이다



4. 아직, notification이 없으면, 바로 `[내가 받은 초대]`를 클릭하여 초대 목록을 확인한다

   - /auth/userinfo(내 정보) 다음 칸의 `/auth/invite/invitee`(내가 **받은(invitee)** 초대)에서 확인한다
     - 내가 받은 초대 tab은   user.invitees로서, 데이터가 잇을때만 나타나게 해야, 일반회원들한테 혼란을 줄일 수 있을 것이다?

   ```python
   def my_invites(user_id):
       player = Player.query.filter_by(user_id=user_id).first()
       invites = PlayerInvite.query.filter_by(guest_id=player.player_id)
   ```

   ```python
   @player.route('/players/invites/guest', methods=['GET'])
   @token_required
   def get_my_invites(current_user):  # Return invites sent to the logged player.
   
       output = []
   
       for invite in my_invites(current_user.id):
   
           invite_data = {'booking_id': invite.booking_id,
                          'spot_name': invite.spot_name,
                          'spot_id': invite.spot_id,
                          'status': invite.status,
                          'invite_id': invite.playerinvite_id,
                          'guest_id': invite.guest_id,
                          'host_name': f'{invite.host_name} {invite.host_surname}'
                          }
           output.append(invite_data)
   
       return {'invites': output}
   ```

   

5. 받은 초대목록 중에 `[초대거부/초대승락]`을 선택해서 누른다

   - 초대 수락

     - 초대는 employee/invite/add지만 
     - 초대수락은 `auth/invite/accept`로 받는다.
       - 초대id로 해당 초대객체를 가져와서 default False였던 **status(수락여부)와 answered(응답여부)를  True**로 놓는다.
     - **초대수락시, 상위entity에 하위entity로서 구성원들을 LineUp entity 모을 수 있지만, 여기선 해당 초대에 대한 상위entity (X), 주제Type에 수락자들을 모을 필요가 없다**
     - **초대 수락시, `employee/add form으로 rediect`해야할 것 같다**

     ```python
     @player.route('/players/invites/accept', methods=['POST'])
     @token_required
     def accept_invite(current_user):
         data = request.get_json()
         invite = PlayerInvite.query.filter_by(playerinvite_id=data['playerinvite_id']).first()
         invite.status = True
         invite.answered = True
         
         db.session.add(invite)
         
         #lineup = Lineup(player_id=data['player_id'],
                    #     booking_id=data['booking_id'])
         
         #db.session.add(lineup)
         db.session.commit()
         return {'message': 'Success!'}
     ```

   - **초대 거부는 invite에서 데이터를 삭제**한다

   - 그렇다면

     - 초대수락 route가 아니라 초대 answer_invite route로 만들고
       - `초대 수락`시 ->  Employeeform + **초대자의 role미만으로 선role선택가능하도록 동적필드choices** 로 `초대Type에 맞는 redirect `-> 초대 삭제 -> **render_tempalte(새로 route파서)**
       - `초대 거부`시 -> 초대 삭제
     - **그렇다면, 초대Type은 value로 초대수락시 `redirect될 url or render될 form과 template?`을 가져야한다? **
       - 초대Type에 다른 redirect_url을 어디다가 기입할까? IntEnum은 int만 저장하는데?
       - route에서 if 초대Type -> redirect_url을 배정해줘야하나?
         - 초대Type + form에 들어갈 정보도 redirect_url에 같이 줘야한다 (furl)
         - 그렇다면, invite에는 복잡한 고유key칼럼을 url대신 소유하고 있다가 **초대Type에 맞는, url을 만들어내는 함수를 소유한다**
     - 현재의 employee/add는 
       - employeeform에는 user_id, g.user( current_employee_id)가
       - route자체적으로는 role.chiefstaff이상이 필요한 상태다
       - 일반 유저도 접속할 수 있는 /auth/invite/employee/add가 필요할 듯하다?

     ```python
         def save(self, **kwargs):
             if not self.pk:
                 self.key = self.generate_key()
     
             return super().save(**kwargs)
     
         @staticmethod
         def generate_key():
             return get_random_string(64).lower()
     
         def send(self, request=None):
             url = self.get_absolute_url()
             if request:
                 url = request.build_absolute_uri(url)
     
             template = find_template("invite")
             context = {
                 "inviter_name": self.inviter.get_full_name(),
                 "email": self.invitee_email,
                 "invite_link": url,
             }
     
             return template.send_email([self.invitee_email], context)
     
         def get_absolute_url(self) -> str:
             return reverse("accounts:invite_accept", kwargs={"key": self.key})
     
         def expired(self) -> bool:
             expiration_date = self.created_on + timedelta(days=settings.INVITE_EXPIRY)
             return expiration_date <= timezone.now()
     ```

6. invite에는 **`create_on`을 넣고, 만료기간도 계산해서, `내가 받은 초대 조회`시 `is_expired도 where`로 걸어야할 것 같다**

7. 직원이라면, 내가 보낸 초대 목록도 확인할 수 있게 하여

   - answered로 응답됬는지
   - status(is_accpeted)로 수락/거부 여부도 볼 수 있게 하면 될 것 같다





### Invite 개발하기

#### model 정의후 db생성



1. 사람대 사람의 초대니까 auth/uesrs.py 패키지에 그대로 개발한다

   - user에 필드추가 전에는 dump하는데, relationship이라 안하고 가능할 듯.

   - Invite

     ```python
     class InviteType(enum.IntEnum):
         직원_초대 = 0
         모임_초대 = 1
     
         예약_초대 = 5
         리뷰_초대 = 6
         결제_초대 = 7
         환불_초대 = 8
     
         # form을 위한 choices에는, 선택권한을 안준다? -> 없음 0을 제외시킴
         @classmethod
         def choices(cls):
             return [(choice.value, choice.name) for choice in cls if choice.value]
     
     
     class Invite(Base):
         __tablename__ = 'invites'
     
         id = Column(BigInteger().with_variant(Integer, "sqlite"), primary_key=True)
     
         # 상위주제entitye대신 초대Type으로
         type = Column(IntEnum(InviteType), nullable=False, index=True)
     
         # user -> inviter / invitee
         inviter_id = Column(Integer, ForeignKey('users.id'))
         invitee_id = Column(Integer, ForeignKey('users.id'))
         # booking_id = db.Column(db.Integer, db.ForeignKey('booking.booking_id'))
     
         is_answered = Column(Boolean, default=False)
         is_accepted = Column(Boolean, default=False)
     
         # expired계산을 위한 생성날짜
         create_on = Column(DateTime, default=datetime.datetime.now, nullable=False)
         
         # url을 만들기 위한 key생성(외부용?)
         key = Column(String(80), max_length=64, unique=True)
     
     
         def __repr__(self):
             return '<Invite %r=>%r >' % (self.inviter_id, self.invitee_id)
     
         def __init__(self, **kwargs):
             super().__init__(**kwargs)
             # 내가 직접key를 넣어줄수도 있어서, 안넣어줄때만 랜덤 생성
             if not self.key:
                 self.key = self.generate_key()
     
         @staticmethod
         def generate_key():
             return str(uuid.uuid4()).replace('-', '')
         # def my_random_string(string_length=10):
         #     """Returns a random string of length string_length."""
         #     random = str(uuid.uuid4()) # Convert UUID format to a Python string.
         #     random = random.upper() # Make all characters uppercase.
         #     random = random.replace("-","") # Remove the UUID '-'.
         #     return random[0:string_length] # Return the random string.
         #
         # print(my_random_string(6)) # For example, D9E50C
     
         def send(self, request=None):
             url = self.get_absolute_url()
             if request:
                 url = request.build_absolute_uri(url)
     
             # template = find_template("invite")
             # context = {
             #     "inviter_name": self.inviter.get_full_name(),
             #     "email": self.invitee_email,
             #     "invite_link": url,
             # }
     
             # return template.send_email([self.invitee_email], context)
             return url
     
         def get_absolute_url(self) -> str:
             # return reverse("accounts:invite_accept", kwargs={"key": self.key})
             return url_for("auth.invite", kwargs={"key": self.key})
     
         def expired(self) -> bool:
             expiration_datetime = self.created_on + datetime.timedelta(days=3)
             return expiration_datetime.date() <= datetime.date.today()
     
     ```

   - user

     ```python
     ## invite에 user_id 2개 추가에 대한 2개의 one으로서 relationship
     inviters = relationship('Invite', backref=backref('inviter', lazy='subquery'), lazy='dynamic')
     invitees = relationship('Invite', backref=backref('invitee', lazy='subquery'), lazy='dynamic')
     
     ```

   - init_script로 db초기화 해서 테이블 생성하기

     ```powershell
     (venv) PS C:\Users\is2js\pythonProject\2022_sqlalchemy> .\run.ps1
     (venv) PS C:\Users\is2js\pythonProject\2022_sqlalchemy> flask createdb
     
     
     Truncate [False]: n
     Drop table [False]: n
     Load fake data [False]: n
     
     ```



##### 중요1) 같은 Entity(User)를 서로 다른역할(inviter_id, invitee_id)로 끌어쓰는 Entity(Invite)는 모호한FK를 피하기 위해 One의 relationship에 foregin_keys를 명시

2. fk는 같은 테이블의 `user.id`로 줘도 되는데 **one에서 relationship을 같은 테이블에 2개를** 주니, **모호한FK에러**가 난다

   ```
   sqlalchemy.exc.AmbiguousForeignKeysError
   sqlalchemy.exc.AmbiguousForeignKeysError: Could not determine join condition between parent/child tables on relationship User.inviters - there are multiple foreign key paths linking the tables.  Specify the 'foreign_keys' argument, providing a list of those columns which should be counted as containing a foreign key reference to the parent table.
   ```

   - 답변:https://stackoverflow.com/questions/48330727/how-to-solve-a-sqlalchemy-exc-ambiguousforeignkeyserror-in-sqlalchemy

     - 축구의 해결법: **relatinship에 `foreign_keys=`로 해당테이블의 필드명을 직접 명시**

       ```python
               guests = db.relationship("PlayerInvite", foreign_keys='PlayerInvite.guest_id')
               hosts = db.relationship("PlayerInvite", foreign_keys='PlayerInvite.host_id')
       ```

       

   ```
   Repair has 2 foreign keys referencing Contact, and so the relationships cannot know which one to use, so indicate that with the foreign_keys= argument. Both relationship attributes are trying to create a backref called "repairs", so that's also going to be problematic. – 
   Ilja Everilä
   
    Jan 18, 2018 at 22:14
   Where should I put the foreign_keys argument? Actually I still don’t understand very well the backref thing. I am trying to keep a way to get the repairs that are related to a given contact. Should I split the contact table in two separate tables? – 
   Victor Domingos
    Jan 18, 2018 at 22:18
   Related: stackoverflow.com/questions/22355890/…, stackoverflow.com/questions/18807322/… – 
   
   Ilja Everilä
    Jan 18, 2018 at 22:20
   Pass foreign_keys=... to the relationship() constructs. For example supplier = relationship("Contact", foreign_keys=[supplier_id], ...). Related part from the docs: "Handling Multiple Join Paths" – 
   Ilja Everilä
    Jan 18, 2018 at 22:24 
   ```

3. User model의 relatinioship 수정

   ```python
       ## invite에 user_id 2개 추가에 대한 2개의 one으로서 relationship
       # -> 같은 테이블 2개에 대한 relaionship은 brackref만 다르게 주지말고, foreign_keys를 다른 필드로서 명시해줘야한다
       inviters = relationship('Invite', backref=backref('inviter', lazy='subquery'), lazy='dynamic',
                               foreign_keys='Invite.inviter_id'
                               )
       invitees = relationship('Invite', backref=backref('invitee', lazy='subquery'), lazy='dynamic',
                               foreign_keys='Invite.inviter_id'
                               )
   ```

   

4. employee 목록에서 [직원전환] by emp가 아니라 `[직원초대]`버튼 추가하기

   - 직원전환: 현재유저를 g.user로 쓰고,  대상user를 user_id로 보내줬음
   - 직원초대도 현재유저 g.user를 **inviter로 쓰고, 대상만 보내주면 될 듯.**

   - admin/user.html

     ```python
     <a href="{{url_for('auth.invite', user_id=user.id)}}" class="tag is-warning is-light">
             <span class="icon">
                  <i class="mdi mdi-graph-outline"></i>
             </span>
         직원 초대
     </a>
     
     <a href="{{url_for('admin.employee_add', user_id=user.id)}}" class="tag is-warning is-light">
             <span class="icon">
                  <i class="mdi mdi-graph-outline"></i>
             </span>
         직원 전환
     </a>
     ```

     ![image-20221217180214448](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221217180214448.png)



##### 중요2) User(One) -> Employee(Many FK)가 1:1관계인 경우, Many-Fk-subqueryBackref말고, One의 relationship에 [subquery + uselist=False]를 주면, FK를 가진 Many역할의 entity관계객체에 바로 접근할 수 있다

- invite와 inviter(User)는 Many-One의 subquery로 바로 접근할 수 있고

  - inviter(User), employee는  One-Many로 subquery를 주지도 않고, many는 list라 필드접근도 못하지만, **1:1관계면, uselist=False로, 1:1Many객체에 바로 접근하여 데이터를 추출할 수 있다.**

  ![image-20221219035228613](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219035228613.png)

  - one에서 uselist=False를 주면, lazy='dynamic'은 주지도 못한다

    ![image-20221219035340789](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219035340789.png)

  - one에서 uselist=False를 주고, lazy옵션을 안주면, detached로 연결안됬다고 나온다

    ![image-20221219035444417](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219035444417.png)

```python
class User(BaseModel):
    __tablename__ = 'users'
    #...
    
    ## 직원(M)에 대해 1로서 relationship
    #### User(invite.inviter)로부터 직원(1:1)의 1로서 바로 접근가능하게 subquery+uselist=False
    employee = relationship('Employee', backref=backref('user', lazy='subquery'), lazy='subquery', uselist=False)
```



##### 축구 pickup-api에서 uselist=False 참고 / 스택오버플로우 링크 참고

- https://github.com/pickupappufrpe/pickup-api/blob/4c8e305b85717f82213c52b136f630fa6880c132/models.py
- https://stackoverflow.com/questions/3464443/how-to-create-one-to-one-relationships-with-declarative

- `uselist=False` : One(User).Many같은One(employee)형태로 접근함.
- `lazy='subquery'` : User.employee`.name`으로 **접근한 entity의 필드에 접근가능.**
  - api형태가 아니라  entity를 내려보낼거면 이렇게 유지하는 중...





##### 중요3) 초대마다 초대Type(상위)외에 추가정보가 필요하다..

- 직원초대
  - **어떤 Role**로 초대할건지 **`초대보내는 사람이 정보를 선택`**해서 담아 정해줘야한다
- 리뷰초대
  - 어떤 Doctor를 골랐는지?

- **Invite는 InviteType별로... 서로다른 정보를  가진다?**
  - 필요한 정보의 타입이 완전 다름. 
    - 직원초대 - role칼럼
    - 리뷰초대 - doctor칼럼



#### model  갈아엎기 - InviteBaseModel + 개별Invite

##### common/base.py - InviteBaseModel

- pk나 fk까지 다 포함한시킨 Mixin을 만들고 싶다면, 또따른 처리를 해줘야하는데 생략한다

```python
class InviteBaseModel(Base):
    __abstract__ = True

    # fk들도 다 상속시키고 싶다면, @declared_attr + method
    # https://stackoverflow.com/questions/9183012/sqlalchemy-mixin-foreignkey-and-relation

    is_answered = Column(Boolean, default=False)
    is_accepted = Column(Boolean, default=False)

    # expired계산을 위한 생성날짜
    create_on = Column(DateTime, default=datetime.datetime.now, nullable=False)

    # url을 만들기 위한 key생성(외부용?)
    key = Column(String(80),  unique=True)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        ## 일단 주어진 keyword는 다 집어넣고도, -> 이후 self.key를  내가 직접 key=로 넣어주지 않을때만 랜덤 생성한다.
        if not self.key:
            self.key = self.generate_key()

```



##### EmployeeInvite

```python
class EmployeeInvite(InviteBaseModel):
    __tablename__ = 'employee_invites'

    id = Column(BigInteger().with_variant(Integer, "sqlite"), primary_key=True)
    # user -> inviter / invitee
    inviter_id = Column(Integer, ForeignKey('users.id'))
    invitee_id = Column(Integer, ForeignKey('users.id'))

    # 직원초대에서는, 초대마다 바뀔 수 있는 role정보를 가져 따로 엔터티를 만들었다.
    role_id = Column(Integer, ForeignKey('roles.id'), nullable=False)


    def __repr__(self):
        return '<EmployeeInvite %r=>%r >' % (self.inviter_id, self.invitee_id)
```



###### 차후 각 초대모델마다, 상속 Entity + 필요한 정보field를 만들어서 진행하면 된다

###### 초대 inviter는 직원이상만 보내니까, inviter를 User가 아닌 Employee로 처리해도 될 것이다?? (나중에 하기) 현재유저g.user에서 또 Employee 객체를 찾아서 보내야하므로, 마찬가지로 불편할 듯.



##### User(one)에 relationship 2개 각각 붙이기

```python
class User(BaseModel):
    __tablename__ = 'users'
    #...
    ## invite에 user_id 2개 추가에 대한 2개의 one으로서 relationship
    # -> 같은 테이블 2개에 대한 relaionship은 brackref만 다르게 주지말고,
    # -> foreign_keys를  ManyEntity.필드_id를 각각 다른 필드로서 명시해줘야한다
    inviters = relationship('EmployeeInvite', backref=backref('inviter', lazy='subquery'), lazy='dynamic',
                            foreign_keys='EmployeeInvite.inviter_id'
                            )
    invitees = relationship('EmployeeInvite', backref=backref('invitee', lazy='subquery'), lazy='dynamic',
                            foreign_keys='EmployeeInvite.invitee_id'
                            )

```







### (직원) 초대보내기 Routes  in admin

#### 직원초대 는 admin의 route  / 초대 확인 및 응답은 auth route로 나누기



#### 직원 초대는 admin에서 ChiefStaff이상만 - employee_invite( /invite/add/ )

- 현재는 고정적으로 STAFF role으로만 초대한다.

```python
@admin_bp.route('/invite/add/<int:user_id>', methods=['GET', 'POST'])
@login_required
@role_required(allowed_roles=[Roles.CHIEFSTAFF])
def employee_invite(user_id):
    #### 초대 존재 여부는
    with DBConnectionHandler() as db:
        inviter = g.user
        invitee = db.session.get(User, user_id)
        stmt = (
            ### 관계칼럼으로 검사하기 전에, EmployeeInvite를 주entity로 만들어줄 걸어줄 조건 or 없다면 select_from()으로 잡아주기
            # exists()
            # .where(Invite.type == InviteType.직원_초대)
            ### 없다면, select =? exists()로 가자?
            exists()
            .select_from(EmployeeInvite) # exists()조건들을 WHERE에 담을 주 entity(left)
            .where(EmployeeInvite.inviter.has(User.id == inviter.id))
            .where(EmployeeInvite.invitee.has(User.id == invitee.id))
            .select()
        )
        is_invite_exists = db.session.scalar(stmt)

        if is_invite_exists:
            flash(f"{invitee.username}에게 이미 직원초대를 보냈습니다.", category="is-danger")
        else:
            role_staff = db.session.scalars(select(Role).where(Role.name == 'STAFF')).first()

            invite = EmployeeInvite(
                inviter=inviter,
                invitee=invitee,
                role=role_staff,
            )

            db.session.add(invite)
            db.session.commit()

            flash(f"{invitee.username}에게 직원초대({role_staff.name})를 보냈습니다.", category='is-success')

    return redirect(url_for('admin.user'))

```

![image-20221219172838915](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219172838915.png)

![image-20221219172858945](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219172858945.png)



#### 초대exists 검사 시, is_not_expired만 검사하기 (추후 select시에도 is_not_expired만 보여주기)

##### InviteBaseModel에   만료일 및 is_not_expired (hybrid) 만들기

- **DateTime 필드는 `datetime`과 비교가능하다.**
  - 대신 **expression에서는** `필드` vs  `datetime  +- timedelta`로 한쪽에 몰아놓고만 비교 가능하다.

```python
class InviteBaseModel(Base):
    __abstract__ = True
    
    #...

    @property
    def expire_datetime(self):
        return self.create_on + datetime.timedelta(days=self._INVITE_EXPIRE_DAYS)

    @hybrid_property
    def is_not_expired(self) -> bool:
        return datetime.datetime.now() <= self.expire_datetime

    # todays_datetime = datetime(datetime.today().year, datetime.today().month, datetime.today().day)
    #
    # payments = Payment.query.filter(Payment.due_date >= todays_datetime).all()
    @is_not_expired.expression
    def is_not_expired(cls):
        #### DateTime필드 vs dateTime obj비교는 되는데,
        #### DateTime필드에 timedelta를 섞을 순 없다. => datetime 관련을 한쪽에 몰아서 비교한다.
        #### 각각을 비교하고 싶다면. 속성.month  extract('month)를 hybrid로 만들어서 할 수도 있다.
        # https://stackoverflow.com/questions/51451768/sqlalchemy-querying-with-datetime-columns-to-filter-by-month-day-year
        #### 나느 date로만 비교시 func.date( DateTime필드 )  vs  int (date.month)로 비교했었다.
        return cls.create_on >= datetime.datetime.now() - datetime.timedelta(days=cls._INVITE_EXPIRE_DAYS)
```





- 만료일을 넘긴 초대를 만든다. (추후 select에서 미리 만든 것)

  ![image-20221219211555117](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219211555117.png)

##### 초대 exists검사에 where( 초대.is_not_expired ) 를 추가한다

```python
        stmt = (
            ### 관계칼럼으로 검사하기 전에, EmployeeInvite를 주entity로 만들어줄 걸어줄 조건 or 없다면 select_from()으로 잡아주기
            # exists()
            exists()
            .select_from(EmployeeInvite) # exists()조건들을 WHERE에 담을 주 entity(left)
            .where(EmployeeInvite.inviter.has(User.id == inviter.id))
            .where(EmployeeInvite.invitee.has(User.id == invitee.id))
            # 만료안된 것들만 존재 검사
            .where(EmployeeInvite.is_not_expired)

            .select()
        )
```



- 직원 123 ->  user test에게 **이미 만료된 초대를 보냈지만, 제외하고 보낼 수 있는지 확인한다**

  ![image-20221219212206761](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219212206761.png)

- user test는 만료지난 것을 제외하고 초대를 또 받을 수 있다

  ![image-20221219212254841](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219212254841.png)

![image-20221217185725742](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221217185725742.png)





### (모든)초대받기 Routes   in auth

#### (모든) 초대받기 auth에서 user라면 다 받을 수 있게- employee_invite( /invite/add/ )

#### User 받은 초대 확인하기 auth, invite_invitee( /invite/invitee/ )



![image-20221219212924766](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219212924766.png)



##### 초대를 조회할 때도, is_not_expired (like not is_delete)를 항상 건다

```python
.where(EmployeeInvite.is_not_expired)
```

![image-20221219213118035](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219213118035.png)

##### 조회시 항상 걸리는 조건이 있다면,  Model의 classmethod로 빼서 조회하자

```python
	@classmethod
    def get_by_user(cls, user):
        with DBConnectionHandler() as db:
            stmt = (
                select(cls)
                .where(cls.invitee == user)
                .where(cls.is_not_expired)
            )

            invite_list = db.session.scalars(stmt).all()
        return invite_list
```

```python
@auth_bp.route('/invite/invitee/')
@login_required
def invite_invitee():
    invite_list = EmployeeInvite.get_by_user(g.user)

    return render_template('auth/userinfo_invitee.html', invite_list=invite_list)
```



### auth (/) 의 userinfo.html with g.user 안에 tab의 subpage로 초대정보 통합하기

#### 기존 userinfo

```python
@auth_bp.route('/')
@login_required
def userinfo():
    # db정보가 아니라 g.user  객체에서 정보를 꺼내서 jinja로 표기하여
    # db조회가 없다.
    return render_template('auth/userinfo.html')
```



##### userinfo.html의 sidemenu들 + tab들을 한번에 처리하기

- side

  ```html
  <aside class="menu">
      <p class="menu-label">
          User 설정
      </p>
      <ul class="menu-list">
          <li><a class="{% if  '/auth/' == request.path %}is-active{% endif %}"
                 href="{{ url_for('auth.userinfo') }}">
              내 정보</a>
          </li>
          <li>
              <a class="{% if  '/auth/invite/invitee' == request.path %}is-active{% endif %}"
                 href="{{ url_for('auth.invite_invitee') }}">받은 초대</a>
          </li>
          <li>
              <a class="" href="">내 댓글</a>
          </li>
      </ul>
  </aside>
  ```

- b-tabs

  ```html
          <!-- 탭2 받은 초대 -->
          <b-tab-item label="받은 초대" icon="account-outline">
          </b-tab-item>
      </b-tabs>
  ```

  ![image-20221217194025575](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221217194025575.png)



- **side메뉴는 클릭으로 바뀌는 상태고, tab은 클릭으로 index가 바뀌는 상태다**
  - **그냥 클릭으로 바뀌게 route를 따로 구성하고, tab은 1번째 tab을 상속한 html로 모양만 tab을 유지한다?** 





### Pampa를 참고해서  Tab loadSubPage 구현하기

- 어차피 메인에서 해야할 일라서 심도있게 해보자.

#### [pampa]분석

##### 각 a태그에 href는 javascript:; +  onclick ="load_page('끝url명')" + id="끝url명"를 주고, render html이 박힐  div태그에 id주기

![image-20221217195753263](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221217195753263.png)

##### extra_foot_script에 load_page구현 -> 끝url(tab1)앞에 route 고정url(/admin/setting/)을 붙여서 get요청하여,  GET요청 + id에 있는 끝url로 a태그 찾아서 active

```html
{% block  extra_foot_script %}

    <script type="text/javascript" src=" {{ url_for('admin.static', filename='js/jquery-3.6.1.min.js') }}"></script>
    <script>
    function  loadPage(url){

        //alert(url)
        new_url='/admin/setting/'+url
        //alert(new_url)
        // $('#'+url).text("一个有梦想的咸鸭蛋");
        {#$('#'+url).addClass("active").siblings().removeClass("active");#}
         $.ajax({
              type:"GET",
              url:new_url,
              async:true,
              dataType:'html',
              contentType:'application/json;charset=utf-8',
              success:function (html){
                  $('#loadpage_right').html(html);
                  alert(html);

              }
          })
    }
    </script>
{% endblock extra_foot_script %}


```

##### route에서는 시작tab의  route가 따로 이미 1개 있고 + 각 끝url갯수만큼  고정url + 끝url로 구성된route들 구현하여, 내부공간을 채울 html을 render_template( html) 으로 html을 넘김

```python
@bp.route('/setting/preferences',methods=["GET"])
# @login_required
def settingpreferences():
    form = SettingForm()
    settings = Setting.query.all()
    setting_dict = {}
    for s in settings:
        setting_dict[s.skey] = s
    for name in form._fields:
        s = setting_dict.get(name, None)
        if s :
            if name in ['pampa_comment','pampa_register_invitecode']:
                form._fields[name].data = True if s.svalue == '1' else False
            else:
                form._fields[name].data = s.svalue
    return render_template('admin/setting/preferences.html',form = form)

@bp.route('/setting/tab1',methods=["GET","POST"])
# @login_required
def setting_tab1():
    return render_template('admin/setting/quansetting.html')
    
@bp.route('/setting/tab2',methods=["GET","POST"])
# @login_required
def setting_tab2():
    return render_template('admin/setting/pagesetting.html')
```





### userinfo tab  적용하기

####  00 기존 1 route + 1 page ->  (1 통합page  + N tab정보 + N subpage를 ) 1통합처리 route + 1 subpage랜더링 route로 분리해서 설계하기

##### auth. userinfo : 통합route(/auth) 에서는 tab_list 정보를 미리 담고 있어서 뿌려줄 준비

```python
@auth_bp.route('/')
@login_required
def userinfo():
    tab_list = [
        {
        },
        {
        }
    ]

    return render_template('auth/userinfo.html',
                           tab_list=tab_list)
```



##### auth.userinfo_subpage(sub_path) : 통합page 내부에 찍힐 subpage html을 처리해줄 axios용 route

- 같은 subpage들을 render할 때도, **서로 다른 data들이 내려가므로 context data dict에 넣어놓고 `\*\*data`를 통해, subpage에 필요한 key별로 내려가게 한다**

```python
@auth_bp.route('/userinfo/<path:sub_path>')
@login_required
def userinfo_subpages(sub_path):
    # 정적페이지면 바로 sub_path로 템플릿만 넘기면 되는데... sub_path들이 각각의 data를 필요로 할 것이다.
    data = {}
    if sub_path == 'userinfo_invitee':
        pass
                
    return render_template(f'auth/{sub_path}.html', **data)
```





#### 01 b-tabs와 subpage들을 소유한 route를 작성한다

1. 첫 화면 route 작성하기

   - tab_list에는 `b-tabs`태그를 `v-for`로 돌릴 재료들을 담고 있어야한다

     - `key`: `:key`에 매핑되는 각 list item의 식별자를 넣어줘야한다

       - user.id 같은 것으로요. v-bind:key의 대상은 **객체가 아니라 문자열, 숫자** 같은 식별할 수 있는 값이어야 합니다 :)
       - 추가로 vue 2.2.0 버전 이상부터 필수로 key를 입력하게 되어 있습니다.

     - `label`: b-tabs하위 `b-tab-item`태그에 채워 실제 `span`의 글자로 들어가는 탭 라벨이다

       - b-tabs + b-tab-item으로 구성되는 html

         ![image-20221218214033262](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221218214033262.png)

     - `url`: **각 tab클릭시 subpage들을 띄워줄 route를 url_for로 `view에서 axios로 호출하여 subpage html을 받을 url`을 입력해준다**

     - `icon`: 각 b-tab-item마다 들어갈 **`mdi mdi-`형식으로 들어갈 mdi아이콘명**을 지정해준다

     - **`tabItemId`:  b-tabs아래 `:id`로 채워서, 실제 html로는 b-tabs  내부 tab들에 매칭되는 애들인 `tab-item의 id`를 명시하여, axios로 받은 subpage html들을 id를 통해 찾아서, innerHTML로 넣어주는 역할을 한다 **

       ![image-20221218215242560](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221218215242560.png)

   ```python
   @auth_bp.route('/')
   @login_required
   def userinfo():
       tab_list = [
           {
               'key': 1,
               'label': '내 정보',
               'url': url_for('auth.userinfo_subpages', sub_path='userinfo_main'),
               'icon': 'account-outline',
               'tabItemId': 'userinfo_main',
           },
           {
               'key': 2,
               'label': '받은 초대',
               'url': url_for('auth.userinfo_subpages', sub_path='userinfo_invitee'),
               'icon': 'account-outline',
               'tabItemId': 'userinfo_invitee',
           },
       ]
   
   
       return render_template('auth/userinfo.html',
                              tab_list=tab_list)
   ```

   ```python
   @auth_bp.route('/userinfo/<path:sub_path>')
   @login_required
   def userinfo_tabs(sub_path):
       data = {}
       if sub_path == 'userinfo_invitee':
           pass
       return render_template(f'auth/{sub_path}.html')
   ```

   

2. **통합 html에서 vue_script에서 python tab_list를 jinja(tojson)  ->  JSON.parse한다**

   ```html
   {% block vue_script %}
   <script>
       app._data.tab_list = JSON.parse('{{ tab_list | tojson}}')
       console.log(app._data.tab_list)
   </script>
   {% endblock vue_script %}
   ```

   ![image-20221218000851380](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221218000851380.png)



3. **기존 첫tab내용이 포함된  userinfo.html를 백업**해두고

   - **tab별 내용을 `통합페이지_subpath.html`로 tab갯수만큼 만든다**

     ![image-20221218001545393](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221218001545393.png)



4. userinfo.html의 **b-tabs의 내용을 tab_list + v-for**로 돌려 만든다

   - base.html에서 변수 초기화

   ```js
   tab_list: [],
   ```

   - userinfo.html의 b-tab-item을 v-for로 구성하기

   ```html
   <!-- userinfo_form에서 달라질 부분 block개설  -->
   {% block tab_content %}
   <b-tabs>
       <b-tab-item
                   v-for="tab in tab_list"
                   :key="tab.key"
                   :label="tab.label">
           탭
       </b-tab-item>
   </b-tabs>
   {% endblock tab_content %}
   ```

   ![image-20221218001722835](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221218001722835.png)



#### 02 b-tabs에 클릭 설정하기

- b-xxx 컴포넌트들은 **@click, on:click 등을 개별 b-tab-item에 걸어도 안먹힌다**

- **b-tabs에서 `v-model + watch + method`조합이나 `v-model + @input="method"` 조합을 스면 된다.**

- **b-tabs는 렌더링되자마 click 및 tabindex 초기화가 걸려있기 때문에 `v-if = "tab_list.length"`를 통해, `개별변수인 v-model은 탭정보가 내려오고나서 작동하여 b-tabs자체 초기화설정과 안겹치도록` 따로 조건을 준다**

  - v-if => 돌아가는 v-for의 정보가 있을 때, v-model세팅되어 렌더링 초기에는 작동으 막는다.

    - v-if를 안주고, v-model을 쓰는 경우 (v-model의 activeTab과 b-tabs자체 작동과 엉킴)

      ![image-20221219223210952](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219223210952.png)

    - v-if와 v-model 모두 삭제한 경우 (v-model로 인한 오류 제거됨)

      ![image-20221219223247943](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219223247943.png)

  - **기존 page의 tab내용은 백업한 상태이므로, 삭제하고 v-for만 돌려준다.**

  ```html
  <!-- userinfo_form에서 달라질 부분 block개설  -->
  {% block tab_content %}
  <b-tabs v-if="tab_list.length" v-model="activeTab" @input="tabClicked(activeTab)">
      <b-tab-item
                  v-for="tab in tab_list"
                  :label="tab.label"
                  :key="tab.key"
                  :icon="tab.icon"
                  :id="tab.tabItemId"
                  >
  
          {% endif %}
      </b-tab-item>
  </b-tabs>
  {% endblock tab_content %}
  ```

  

#### 03  v-model 및 v-model이 b-tabs로부터 받는 index변수 activeTab으로 작동하는 tabClicked() 메서드 base.html에 정의

- tab이 클릭되면 **`activeTab`(v-model)은 `tab의 index`를 넘겨주며**

  - 그 index로 `tab_list`에 저장된 tab정보들을 받아온다

- **잘보면, `<b-tab-item>`의 `id:`로 넣어준 값은**

  - **`section.tab-content` 내부의 `.tab-item`의 `id`로 넘어가는 것을 확인할 수 있다**

    ![image-20221219224359790](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219224359790.png)

- **그렇다면, 컨텐츠를 넣어줄 자리를 `.tab-item#id`로 잡을 수 있다.**

  - 현재 탭 정보인 `this.tab_list[index]`에서 tabItemId로 넣어준 값으로 html 요소를 잡으면 된다.

```html
<script>
    var app = new Vue({
        el: '#app',
        delimiters: ['{$', '$}'],  // jinja와 같이 쓸 vue 변수
        data: {
            //userinfo.html에서 tab 및 a태그
            tab_list: [],
            activeTab: 0,
        },
        //...
        methods: {
            tabClicked(index) {
                let tab_item = document.querySelector(".tab-item#" + this.tab_list[index].tabItemId);
                // console.log(tab_item)

            },

```





#### 04 각 tab클릭 -> tabClicked(index) -> tab_list[index]  - url -> userinfo_subpages route로 가서 html을 받아올 axios 구현 load_subpage method 생성 구현

- 만약 subpage를 못받아왔으면, "임시로 페이지를 찾을 수 없습니다."를 넣어주도록 한다
- route에서는 **render_template( page , data) 로 페이지를 미리 만들어준다**
- **받아온 html은 `바깥 .tab-item#id`에다가 `.innerHTML`로 넣어주면 된다.**

```js
tabClicked(index) {
    let tab_item = document.querySelector(".tab-item#" + this.tab_list[index].tabItemId);
    // console.log(tab_item)

    axios({
        url: this.tab_list[index].url,
        method: 'get',
        dataType: 'html',
        headers: {'content-type': 'application/json;charset=utf-8'},
    }).then(res => {
        // alert(res.data)
        tab_item.innerHTML = res.data
    }).catch(err => {
        console.log(err)
        tab_item.innerHTML = ('페이지를 찾을 수 없습니다.');
    });
```



##### 기존 b-tab-item 내부 코드들을 첫페이지로서, 통합페이지_main.html로 작성하기

![image-20221219233909779](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219233909779.png)

##### tab 통합 route에서 첫번째 페이지만  tab_list 정보에서 가져와, subpage route 호출하여 얻은 html을 직접 내려서, jinja로 미리 채워넣기

- 첫번째 페이지는 **html로 구성되어있기 때문에 `| safe` 필터를 적용**해야한다

```python
@auth_bp.route('/')
@login_required
def userinfo():
    tab_list = [
        {
            'key': 1,
            'label': '내 정보',
            'url': url_for('auth.userinfo_subpages', sub_path='userinfo_main'),
            'tabItemId': 'userinfo_main',
            'icon': 'account-outline',
        },
        {
            'key': 2,
            'label': '받은 초대',
            'url': url_for('auth.userinfo_subpages', sub_path='userinfo_invitee'),
            'tabItemId': 'userinfo_invitee',
            'icon': 'account-outline',
        },
    ]
    

    init_html = userinfo_subpages(sub_path=tab_list[0].get('tabItemId'))
    return render_template('auth/userinfo.html',
                           tab_list=tab_list,
                           # init_html=render_template('auth/userinfo_main.html'),
                           init_html=init_html,
                           )

```



```html
<b-tabs v-if="tab_list.length" v-model="activeTab" @input="tabClicked(activeTab)">
    <b-tab-item
                v-for="tab in tab_list"
                :label="tab.label"
                :key="tab.key"
                :icon="tab.icon"
                :id="tab.tabItemId"
                >
        {% if init_html %}
	        {{init_html |safe}}
        {% endif %}
    </b-tab-item>
</b-tabs>
```



#### 05 2번재 tab 페이지 구성하기

- `통합페이지_invitee.html`로 작성하고 **b-tab-item**태그 **내부에 들어갈 html 코드**만 작성

  ![image-20221219234217247](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219234217247.png)



- **실제 개발한다면, `통합페이지 내부에서 hmtl코드를 개발한 뒤, 내부 내용 + data만 빼주기`로 하면 될 것 같다**

  - 통합페이지에서 코드를 개발

    ![image-20221219234412797](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219234412797.png)

    ![image-20221219234430179](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219234430179.png)

  - **통합route에서 필요한 데이터 임시로 넘겨주기**

    ![image-20221219234507338](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219234507338.png)





#### 06 각 sub_page들을 _subpages(sub_path)에서 내려보내주되, [각 page에 필요한 data를 if sub_page로 확인후 dict에 넣어 같이 render시 같이 넘겨주기]

- `user_invitee.html`에는 **invite_list**데이터를 조회하여 -> **render_template시 같이 넘겨줘야한다.**

  ```python
  @auth_bp.route('/userinfo/<path:sub_path>')
  @login_required
  def userinfo_subpages(sub_path):
      # 정적페이지면 바로 sub_path로 템플릿만 넘기면 되는데... sub_path들이 각각의 data를 필요로 할 것이다.
      data = {}
      if sub_path == 'userinfo_invitee':
          data['invite_list'] = EmployeeInvite.get_by_user(g.user)
      return render_template(f'auth/{sub_path}.html', **data)
  ```

  ![image-20221219235636844](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221219235636844.png)



#### 07 통합페이지의 tabindex(v-model: activeTab)과  ul-li-속 active 연동되는 A태그 만들기

- b-tabs는 자동으로 active표시가 된다.
- **하지만, 내가 만드는 tab과 동일 a태그들은 클릭된 activeTab번호를 받아서 -> a태그의 class에 is-active 가 동적으로 찍혀야한다**
- a태그들도 통합route에서 내려오는 tab_list정보로 구성하면 된다.





```html
{% block menus %}
<template>
    <aside class="menu">
        <p class="menu-label">
            마이페이지
        </p>
        <ul class="menu-list"
            v-for="(tab, index) in tab_list"
            @click="anchorClicked($event, index)"
        >
            <li>
                <a
                        href="javascript:;"
                        :key = "index"
                        class=""
                        :class="getActiveClass(index)"
                >
<!--                        :class="{'is-active': activeAnchor === index}"-->
                    {$ tab.label $}
                </a>
            </li>
        </ul>
    </aside>
</template>
{% endblock menus %}
```



##### 항상 v-for는 상위태그에서 돌린다. b-컴포넌트가 아니면 @click="method"가 작동한다

- ul태그에서 tab_list 정보로 `v-for`를 돌린다.

- **각 a태그마다 @click을 걸수도 있지만, `v-for 태그에 @click을 걸면 클릭된 태그에 method를 일괄 적용시킬 수 있다.`**

- **일반적으로 @click="method"**를 **`함수객체`로  넘기면 `event`가 자동으로 들어온다**

  - e.currentTarget은 **v-for돌리는 ul태그가 들어오지만**

  - e.target은 **클릭된 a태그가 들어온다**

    ```js
    // const ul = e.currentTarget; // FYI
    // const a = e.target;
    // console.log(ul);
    // console.log(a);
    ```

- **하지만, `e를 통한 target`이 아니라, `현재 클릭된 index를 알아야 해당tab도 활성화 => 해당tab클릭`까지 시킬 수 있으므로**

  - `:click="method"` 함수객체만 넣는대신 대신 **`:click="method($event, index)"` 로 함수객체대신 `$event`와 함께 인자 직접 작성**하고

- **v-for는 `tab in tab_list`로 데이터객체만 받을 수도 있지만**

  - **`for (tab, index) in tab_list`로 튜플형태로 나눠서 받으면 index도 공짜로 받을 수 있다.**

- a태그는 **기존 href를 막고 a태그 클릭시 `javascript:; `만 명시해놓고 @click 메서드에서 tab만 클릭되도록 변경해준다**

- **v-for의 index만 있으면, 기본class 설정 이후 `:class=""`에 조건문으로 `is-active`클래스를 넣어줄 수 있게 한다**

  - **`{ '문자열' : boolean판단 변수식 }`을 vue조건문으로 걸어줄 수 있다.**

- 현재index와 **activeAnchor(vue변수)**가 같을 때 `is-acitve`가 들어가게 하면 되므로

  - **data변수로서 activeAnchor:0으로 초기화한 뒤,**
  - activeAnchor === index가 같을시 class를 추가하도록 작성한다

  ```js
  var app = new Vue({
      el: '#app',
      delimiters: ['{$', '$}'],  
      data: {
          tab_list: [],
          activeTab: 0,
          activeAnchor: 0,
          
          //...
          
          getActiveClass(current_index) {
  
              return {
                  'is-active' : this.activeAnchor === current_index
              }
          }
  ```

  

##### a태그 클릭시 achorClicked는 자신anchor Active  =>  tab Active화 + tab클릭 역할만하고, 클릭기능은 안가져간다

```js
anchorClicked(e, index) {
    // console.log(e, index)
    this.activeAnchor = index;
	// 자신클릭시, active만 활성화시킨 뒤, tab활성화 + tab클릭만 한다.
    this.activeTab = index;
    this.tabClicked(index);
}
```





### Modal 적용

#### 01 route: 직원초대 modal에 넘겨줄 역할 Role_list 추가로  내려주기

##### admin.user route: admin/user.html에 modal에 채울 role_list 도 이미 같이 건네줘야한다?

```python
@admin_bp.route('/user')
@login_required
def user():
    page = request.args.get('page', 1, type=int)

    # stmt = select(User).order_by(User.add_date.desc())
    # ~User.is_staff => only user
    stmt = select(User) \
        .where(~User.is_staff) \
        .order_by(User.add_date.desc())

    # print(stmt)

    pagination = paginate(stmt, page=page, per_page=10)
    user_list = pagination.items

    #### 직원초대시 modal에 띄울 role_list를 건네주기
    with DBConnectionHandler() as db:
        role_list = db.session.scalars(
            select(Role)
            .where(Role.is_(Roles.STAFF)) # 상수 STAFF이상이면서
            .where(Role.is_under(g.user.role)) # Role객체의 permissions가 현재 직원의 Roles보다는 적게
        ).all()

    # print(role_list) # [<Role 'STAFF'>, <Role 'DOCTOR'>, <Role 'CHIEFSTAFF'>, <Role 'EXECUTIVE'>]

    return render_template('admin/user.html',
                           user_list=user_list, pagination=pagination,
                           role_list=role_list
                           )
```



#### 02 buefy modal 띄우기

##### 01 [직원 초대]a태그버튼을 바로 route로 보내지 않고, @click=""를 통해 v-bind변수 isModalActive = true;를 할당하는 로직을 넣어 modal띄우는 버튼으로 만든다. 

- modal을 띄움과 동시에 해당 user의 id도 넘기기 위해  **@click에 `isRoleModalActive` + `user_id`변수에 할당**한다 

```html
<!-- 모달클릭처리 참고 -->
<!-- https://stackoverflow.com/questions/58963250/how-to-pass-selected-id-to-modal-in-vue-js -->
<!-- <a href="{{url_for('admin.employee_invite', user_id=user.id)}}"-->
<a href="javascript:;"
   class="tag is-info is-light"
   @click="isRoleModalActive = true; user_id = {{user.id}}"
   >
    <span class="icon">
        <i class="mdi mdi-graph-outline"></i>
    </span>
    직원 초대
</a>
```



##### 02 사용변수들을 base.html의 data에 초기화한다

```js
//user.html 일반 modal로 변경하여 필요한 변수
isRoleModalActive: false,
user_id: null,
```



##### 03 v-model="is Active" 변수에 반응하여 모달을 띄우는 b-modal을 html맨 아래 추가한다

- b-modal의 v-model="is Active"는 true/false에 반응하여 모달을 띄우고, 닫고 한다
- **속성 중에 `has-modal-card`를 필수로 넣어줘야, buefy의 form을 내부 담는 card-modal이 예쁘게 나온다**
- 

```html
<b-modal
        v-model="isRoleModalActive"
        has-modal-card
        trap-focus
        close-button-aria-label="Close"
        aria-role="dialog"
        aria-label="Role Select Modal"
        aria-modal
        >
</b-modal>
```



##### 04 b-modal태그내부에는 form을 품고 있는 card를 정의한다

- method = "post"를 던져서 **route는 더이상 path를 받지 않고, `form에 모든 파라미터들을 담아간다`**
  - **해당route는 user_id = {{user.id}}를 받는 getter route였다면, `앞으로는 POST로 form데이터처리후 redirect`해주는 route로 변경할 것이다.**
- 닫기 버튼은 @cllck = " is Active= false;"를 넣어주면 된다.
  - 클릭시 담는 user_id도 null로 빼준다?!
- **클릭시 data변수(user_id)에 담은 값을 =>  `hidden input태그`에 담기 위해 `:value= user_id`로 채우면 된다.**
- b-select로 드랍다운 사용시
  - **`b-select태그의 name="role_id"`로  bakend에 보낼 role의 id값을 보낸다**
  - **각 role_id의 값의 후보들을 `option태그의 value="{{role.id}}"`에 jinja로 for를 돌려 넣어준다**
- 버튼조합은 b-button 1개 이후 사라져서 **`a.button` + `input(submit).button`의 조합으로 구성하기**

```html
<b-modal
        v-model="isRoleModalActive"
        has-modal-card
        trap-focus
        close-button-aria-label="Close"
        aria-role="dialog"
        aria-label="Role Select Modal"
        aria-modal
        >

    <form action="{{url_for('admin.employee_invite')}}" method="post">
        <div class="modal-card is-" style="width: auto">
            <header class="modal-card-head">
                <p class="modal-card-title is-size-5">
                    직원 초대
                </p>
                <button
                        type="button"
                        class="delete"
                        @click="isRoleModalActive = false; user_id = null;"/>
            </header>
            <section class="modal-card-body">
                <!-- INPUT1: 모달클릭시 v-bind변수에 담아놨던 변수로, form에 포함될 변수로서 id를 반영 -->
                <input type="hidden" name="user_id" :value="user_id">

                <!-- INPUT2:  -->
                <b-field label="역할 선택">
                    <!-- option이 아니라 상위 b-select에  name=도 같이붙으며  form으로 간다 -->
                    <b-select
                            name="role_id"
                            placeholder="직위 선택"
                            rounded required
                    >
                        {% for role in role_list %}
                        <option value="{{role.id}}" selected>{{role.name}}</option>
                        {% endfor %}
                    </b-select>
                </b-field>

            </section>
            <footer class="modal-card-foot">
                <!-- b-button이 1줄이후에 사라지는 상황 => a태그 + input태그submit으로 조합으로 변경-->
                <a class="button is-primary is-light mr-2"
                   @click="isRoleModalActive = false; user_id = null;"
                >
                    닫기
                </a>
                <input type="submit"
                       class="button is-primary"
                       value="완료" >
            </footer>
        </div>
    </form>
</b-modal>
```



#### 03 route를 POST만! 처리후 form보낸 곳으로 redirect하는 것으로 변경

```python
@admin_bp.route('/invite/employee/', methods=['POST'])
@login_required
@role_required(allowed_roles=[Roles.CHIEFSTAFF])
def employee_invite():
    role_id = request.form.get('role_id', type=int)
    user_id = request.form.get('user_id', default=None, type=int)
    #### 초대 존재 여부는
    # 1) 현재 초대Type(상위 주제entity)에 대해서만 검색해야한다,(초대 Type이 다르면 또 보낼 수 있음)
    # 2) *응답(수락/거절)되서 삭제된 것외에 만료된 것을 제외하고 검색해야한다.(만료되면 또 보낼 수 있음)
    # 3) 검색시에는, 보내는사람과 받는사람을 필터링하면 된다. 관계테이블이므로, 관계객체.has()/any() - 데이터존재검사 + 추가조건을 건다
    # 4) 만료되지 않는 것에 대해서만 존재검사를 한다.
    # 5) *추후 answer안된 것들만 검사한다
    with DBConnectionHandler() as db:
        inviter = g.user
        invitee = db.session.get(User, user_id)

        stmt = (

            exists()
            .select_from(EmployeeInvite)  # exists()조건들을 WHERE에 담을 주 entity(left)
            .where(EmployeeInvite.inviter.has(User.id == inviter.id))
            .where(EmployeeInvite.invitee.has(User.id == invitee.id))
            .where(EmployeeInvite.is_not_expired)
            .select()
        )

        is_invite_exists = db.session.scalar(stmt)

        if is_invite_exists:
            flash(f"{invitee.username}에게 이미 직원초대를 보냈습니다.", category="is-danger")
        else:
            role = db.session.scalars(select(Role).where(Role.id == role_id)).first()

            invite = EmployeeInvite(
                inviter=inviter,
                invitee=invitee,
                role=role,
            )

            db.session.add(invite)
            db.session.commit()

            flash(f"{invitee.username}에게 직원초대({role.name})를 보냈습니다.", category='is-success')

    return redirect(url_for('admin.user'))

```



#### 04 요청한 request.referrer or querystring or default endpoint로 redirect_url을 반환해주는 유틸 작성하여 반영하기

- https://stackoverflow.com/questions/14277067/redirect-back-in-flask

  ```python
  def redirect_url(default='index'):
      return request.args.get('next') or \
             request.referrer or \
             url_for(default)
  #Use it in in the view
  
  def some_view():
      # some action
      return redirect(redirect_url())
  Without any parameters it will redirect the user back to where he came from (request.referrer). You can add the get parameter next to specify a url. This is useful for oauth for example.
  
  instagram.authorize(callback=url_for(".oauth_authorized",
                                                  next=redirect_url(),
                                                  _external=True))
  ```



##### utils.py redirect_url 함수 정의해주기

```python
from flask import request, url_for


def redirect_url(endpoint='main.index'):
    """
    querystring에 next= or redirect_to=를 가졋거나
    (없다면) 요청 full url (request.referrer http://localhost:5000/admin/user)
    (없다면) url_for(bp.index)
    :param default:
    :return:
    """
    return request.args.get('next') or \
           request.args.get('redirect_to') or \
           request.referrer or \
           url_for(endpoint)

```



##### post요청 처리후 redirect시키는 route에 그냥 호출만해주면, 알아서 처리됨

```python
# return redirect(url_for('admin.user'))
    return redirect(redirect_url())
```



![image-20221221010203006](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221221010203006.png)

![image-20221221010210006](https://raw.githubusercontent.com/is3js/screenshots/main/image-20221221010210006.png)








#### 응답기능 구현후, exists검사/my_invitee조회시  응답안된 것들 조건 추가

