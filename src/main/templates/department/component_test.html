{% extends 'admin/index.html' %}


{% block extra_head_style %}
<!--<script src="https://unpkg.com/vue-draggable-nested-tree@latest/dist/vue-draggable-nested-tree.js"></script>-->
<!--<script src="https://unpkg.com/tree-helper@latest/dist/tree-helper.js"></script>-->
<script src="{{url_for('static', filename='js/department/vue-draggable-nested-tree.js')}}"></script>
<script src="{{url_for('static', filename='js/department/tree-helper.js')}}"></script>

<!-- axios js-->
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>


<style>
    /* tree 공간 */
    .he-tree {
        /*border: 1px solid #ccc;*/
        border-radius: 3%;
        padding: 20px;
        /*width: 300px;*/

        /*is-light*/
        background: #f5f5f5;
    }

    /* 개별 node */
    .tree-node-inner {
        border: 1px solid #ccc;
        border-radius: 5px;
        cursor: pointer;

        background: white;
    }

    /* 선택된 node에 표시 */
    .tree-node-inner > .active {
        border-color: transparent;
        border-radius: 5px;
        background-color: #7957d5;
        color: #fff !important;
    }

    /* drag시 item */
    .draggable-placeholder-inner {
        border: 1px dashed #0088F8;
        box-sizing: border-box;
        background: rgba(0, 136, 249, 0.09);
        color: #0088f9;
        text-align: center;
        padding: 0;
        display: flex;
        align-items: center;
    }

</style>
{% endblock extra_head_style %}

{% block member %}
<!-- 위쪽 제목 공간 -->
<div class="is-block">
    <!-- left 제목 -->
    <div class="is-pulled-left">
        <h1 class="is-size-4">
            <span class="icon"><i class="mdi mdi-receipt-outline"></i></span>
            부서 관리
        </h1>
    </div>

    {% block button %}
    <!--    <div class="is-pulled-right">-->
    <!--        <a href="{{url_for('admin.employee')}}" class="button is-primary is-light">-->
    <!--            <span class="icon"><i class="mdi mdi-plus-thick"></i></span>-->
    <!--            <span>직원 추가</span>-->
    <!--        </a>-->
    <!--    </div>-->

    {% endblock button %}

    <div class="is-clearfix"></div>
    <div class="dropdown-divider"></div>

    <!-- 아래쪽 table의 처리에 대한 flash 메세지를 위쪽에서   -->
    {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
    {% for category, message in messages %}
    <b-message type="{{category}}">
        <ul class="flashes">
            <li class="{{category}}">{{ message }}</li>
        </ul>
    </b-message>
    {% endfor %}
    {% endif %}
    {% endwith %}

    <!-- form validation -->
    {% if form and form.errors %}
    <b-message type="is-danger">
        <ul class="errors">
            {% for error, v in form.errors.items() %}
            <li>{{ error }}：{{ v[0] }}</li>
            {% endfor %}
        </ul>
    </b-message>
    {% endif %}
</div>

<!-- 위쪽 아래쪽 table or form 공간 -->
{% block table_content %}


{% endblock table_content %}

<div class="box">
    <!-- 모두 접기 모두 열기 버튼   -->
    <div class="columns ">

    </div>
    <!-- tree 공간   -->
    <div class="columns">

        <div class="column is-half">
            <div class="buttons is-block m-0">
                <a class="is-size-7 has-text-grey"
                   size="is-small"
                   @click="collapseAll">
                    <span class="icon">
                         <i class="mdi mdi-collapse-all-outline"> </i>
                    </span>
                    <small>모두접기</small>
                </a>
                <a class="is-size-7 has-text-dark"
                   size="is-small"
                   @click="expandAll">
                    <span class="icon">
                         <i class="mdi mdi-expand-all-outline"> </i>
                    </span>
                    <small>모두열기</small>
                </a>

                <!-- 부서 추가-->
                <b-button class=" is-primary is-rounded is-pulled-right mr-2"
                          size="is-small"
                          @click="isDepartmentModalActive = true;">
                    <span class="icon">
                         <i class="mdi mdi-plus-thick mr-1"> </i>
                    </span>
                    {$ selectedDept ? '하위 부서 추가' : '최상위 부서 추가' $}
                </b-button>
                <!-- 부서 삭제-->
                <b-button v-if="selectedDept"
                          class="is-danger is-light is-rounded is-pulled-right mr-2"
                          size="is-small"
                          @click="validateDelete"
                >
                    <span class="icon">
                         <i class="mdi mdi-trash-can-outline mr-1"> </i>
                    </span>
                    삭제
                </b-button>


            </div>

            <div class="is-clearfix"></div>
            <div class="dropdown-divider"></div>

            <div v-if="!treeData || (treeData && !treeData.length) "
                 class="container"
            >
                <span class="is-size-6 has-text-primary has-text-weight-bold">
                    부서가 없습니다. 최상위 부서를 생성해주세요.
                </span>
            </div>


            <tree
                    draggable
                    :class="'is-size-7'"
                    :style="{visibility: (treeData && treeData.length) ? 'visible' : 'hidden'}"
                    ref="tree"
                    :data="treeData"
                    @change="treeChanged"

                    :ondragstart="onDragStart"

                    @drag="nodeDragged"

                    :ondragend="onDragEnd"


                    @change-dept="changeDept"

                    @edit-page="editDept"
            >

                <!-- tree-branch -->
                <!--  <template>에는 @click이 안먹어서 따로 한번 더 감싸줌.-->
                <!--                @click="dept.active = !dept.active;"-->
                <!--                :class="{'active': dept.active}"-->
                <div class="p-2"
                     slot-scope="{data: dept, store, vm}"
                     ref="node"
                     @click="selectNode(dept)"
                     :class="{'active': dept.id === idOfSelectedDept}"


                     @drag="emitDrag( dept, vm.level, store, $event)"

                     @edit="$emit('edit-dept', dept, vm, store, $event)"
                     @removed="deptRemoved"
                     @dblclick="showNameInput(dept.id)"
                >

                    <template v-if="!dept.isDragPlaceHolder">
                        <div>

                            <!-- display:none; 이후 공간차지 없으려면  inline-block으로 바깥에 한번 씌워서 (name or input)2개를 한꺼번에 집어넣어준다 -->
                            <span class="pl-2 is-inline-block">
                                <!-- Name or Input-->
                                <span :id="'node-' + dept.id"
                                      :class=" dept.id !== idOfSelectedDept ? getTextColorToLevelAndSort(dept.level, dept.parent_sort, dept.sort) : 'abc' "
                                >
                                    <!-- name -->
                                    {$ dept.name $}
                                    <span class="has-text-weight-light ml-1"
                                          :class="dept.id !== idOfSelectedDept ? 'has-text-grey' : 'has-text-white'"
                                    >

                                        <!-- 부서장 외 (부서장 제외 직원 + 하위부서장 + 하위직원 수) : all_employee_count-->
                                        <small v-if="dept.has_direct_leader"> {$ dept.leader.name $}</small>
                                        <small v-else>(부서장 공석) </small>
                                        <small v-show="dept.all_employee_count">외 직원 {$ dept.all_employee_count $}명</small>


                                    </span>
                                </span>
                                <!-- 더블클릭시 나타나는 이름변경 input -->
                                <input class="is-size-7"
                                       type="text"
                                       :id="'name-' + dept.id"
                                       :value="dept.name"
                                       :size="dept.name.length + 3"
                                       style="display: none;"

                                       @blur="hideNameInput(dept.id)"
                                       @keydown.esc="hideNameInput(dept.id)"
                                       @click.stop

                                       @keypress.enter="validateName(dept)"
                                >
                            </span>


                            <!-- 활성/비활성 -->
                            <!--                                    @input="onSelectedDeptIdOrSwitchChange"-->
                            <!--                                    v-model="isSwitchedCustom"-->
                            <div class="is-pulled-right pr-2"
                            >
                                <b-switch
                                        size="is-small"
                                        type="is-success"
                                        v-model="dept.status"
                                        @click.native.prevent.stop="validateStatusChange(dept)"
                                        @dblclick.native.prevent.stop
                                >
                                </b-switch>
                            </div>

                            <!-- 열기 접기 -->
                            <div class="is-pulled-right pr-4"
                                 v-if="dept.children && dept.children.length"
                                 @click.prevent.stop="store.toggleOpen(dept)"
                                 @dblclick.prevent.stop
                            >
                                <small :class="dept.id !== idOfSelectedDept ? 'has-text-grey' : 'has-text-white'">
                                    {$ dept.open ? '접기 ▶' : '열기(' + dept.only_children_count+ ') ▼' $}
                                </small>
                            </div>
                        </div>
                    </template>
                </div>
            </tree>
        </div>
    </div>

    <small>
        this.depts
        <pre>{$ depts $}</pre>
    </small>
</div>

<!-- 부서추가 모달 -->
<b-modal
        v-model="isDepartmentModalActive"
        has-modal-card
        trap-focus
        aria-role="dialog"
        aria-label="Department Add Modal"
        aria-modal
>
    <form method="post" @submit.prevent="submitDeptAddForm">
        <div class="modal-card is-" style="width: auto">
            <header class="modal-card-head">
                <p class="modal-card-title is-size-5">
                    부서 추가
                </p>
                <!-- 닫기버튼시 사용된 변수 다 초기화 -->
                <button
                        type="button"
                        class="delete"
                        @click="isDepartmentModalActive = false; initObject(form);"/>
            </header>
            <section class="modal-card-body">
                <!-- INPUT1: hidden에 부모부서를 넣어줘야하는데, v-model과 연동시키려면 :value가 불가능 => v-model에 할당문으로 넣어준다.-->
                <input type="hidden" v-model="form.parent_id = idOfSelectedDept">

                <!-- INPUT2: 부서 타입 고르기 -->
                <div class="columns">
                    <div class="column is-mobile">
                        <b-field
                                label="부서 타입"
                                label-position="on-border"
                        >
                            <b-select
                                    size="is-small"
                                    :placeholder="!form.type ? '부서타입 선택': ''"
                                    v-model="form.type"
                                    required
                            >
                                <optgroup label="1인 부서">
                                    <option value=0>~부/~장(ex> 병원장, 진료부, 간호부, 수련부)</option>
                                </optgroup>
                                <optgroup label="행정관련 부서">
                                    <option value=1>~실(ex> 탕제실, 홍보실, 적정진료관리실)</option>
                                    <option value=2>~팀(ex> 교육팀, 홍보팀, 총무팀, 기획홍보팀)</option>
                                    <option value=3>~과(ex> 원무과, 행정과)</option>
                                </optgroup>
                                <optgroup label="의료관련 부서">
                                    <option value=4>~치료실(ex> 병동, 외래, 집중간호실)</option>
                                    <option value=5>~원장단(ex> 한방원장단, 양방원장단)</option>
                                    <option value=6>~과(ex> 재활의학과, 피부미용과, 안면마비과)</option>
                                    <option value=7>의료센터(ex> 재활센터, 피부미용센터, 암센터)</option>
                                </optgroup>
                                <optgroup label="연구/관리 부서">
                                    <option value=8>~연구소(ex> 의학연구소, 교육연구소, 중앙연구소)</option>
                                    <option value=9>~센터(ex> 임상연구윤리센터, 임상시험센터)</option>
                                    <option value=10>~위원회(ex> 임상시험윤리위원회 등)</option>
                                </optgroup>
                            </b-select>
                        </b-field>
                    </div>
                </div>

                <!-- INPUT3: 부서명  -->
                <div class="columns">
                    <div class="column is-mobile">
                        <b-field label="부서 이름"
                                 label-position="on-border"
                        >
                            <b-input type="text"
                                     size="is-small"
                                     minlength="2"
                                     maxlength="10"
                                     placeholder="이름을 2~10자로 입력해주세요."
                                     v-model="form.name"
                                     required
                            >
                            </b-input>
                        </b-field>
                    </div>
                </div>

            </section>
            <!-- 일반적인 태그 가운데 정렬은 is-justify-content-center 을 쓰면 된다.-->
            <footer class="modal-card-foot is-justify-content-center">
                <!-- b-button들을 넣으면 1개 이후 사라지는 버그 => a태그 + input(submit) 조합으로 변경-->
                <a class="button is-primary is-light mr-2 is-size-7"
                   @click="isDepartmentModalActive = false;  initObject(form);"
                >
                    닫기
                </a>
                <input type="submit"
                       class="button is-primary is-size-7"
                       value="생성"
                       :disabled="isLoading"
                >
            </footer>
        </div>

    </form>
</b-modal>

{% endblock member %}


{% block extra_foot_script %}
<script>
</script>
{% endblock extra_foot_script %}

{% block vue_mixins %}
<script>
    const th = window.treeHelper
    const {DraggableTree} = window.vueDraggableNestedTree;

    // Vue.component('tree', DraggableTree);
    const myMixin = {
            components: {
                'tree': DraggableTree
            },

            data() {
                return {

                    depts: [], // 외부 => treeData에 공급할 변수
                    treeData: [], // tree 자체 변수
                    initialDepts: [], // 외부공급 depts를 받을 때 백업 변수
                    isLoading: false, // getDepts요청시 로딩처리 flag

                    selectedDept: null, // 선택된 부서

                    isDepartmentModalActive: false, // 부서추가시 띄울 모달
                    // form에 입력되는 input을 v-model로 받아줄 form object
                    form: {
                        parent_id: null,
                        type: null,
                        name: '',
                    },


                    deptIds: [],

                    //input관련
                    deptName: "",


                };
            },

            created() {
                console.log('created()--------')
                // this.getDepts()
                //     .then(() => {
                //         this.initialDepts = this.depts;
                //     });
                this.getDepts();
                this.initialDepts = this.depts;

                console.log('created()========')
            },


            methods: {
                getDepts() {
                    console.log('getDepts')
                    // this.loading = true;
                    // const url = `${this.getDeptsUrl}?page=${this.page}`;
                    //
                    // return this.$axios.get(url).then(response => {
                    //     this.depts = response.data.depts;
                    //     this.updateTreeData();
                    //     this.loading = false;
                    // })
                    this.depts = JSON.parse('{{ tree.data | tojson }}')
                    // console.log('this.depts >> ', this.depts);
                    this.updateTreeData();
                    // 초기화데이터에 넣는 것은 밖에서 따로 함.
                },
                getUpdatedDepts() {
                    console.log('getUpdatedDepts')

                    axios({
                        url: '{{ url_for("department.all") }}',
                        method: 'get',
                        headers: {'Content-type': 'application/json;charset=utf-8'},
                    }).then(res => {
                        // 통신성공 but 로직 실패(200대 외) -> tree되돌려야함 by this.updateTreeData();
                        if (res.status >= 300) {
                            this.toast(res.data.message)
                            // [cancel 2] 통신성공 BUT 로직실패  => tree변경 취소(기존 this.depts -> this.treeData)
                            this.updateTreeData(); // 변경된 tree 롤백
                            return;
                        }
                        this.depts = res.data.tree.data;
                        this.updateTreeData(); //  this.depts -> depts
                        this.initialDepts = this.depts; // this.depts -------> this.initialDepts

                        // this.toast(res.data.message)

                    }).catch(err => {
                        // TODO: 부서 순서 변경실패(통신은 됬는데 DB실패) => 이미 tree가 바뀌었다면, cancel해야함.
                        console.log(err)
                        this.toast(err.response ? err.response.data.message : '서버와 연결이 올바르지 않습니다.');
                        // [cancel 3] 통신실패  => tree변경 취소(기존 this.depts -> this.treeData)
                        this.updateTreeData();
                    }).finally(() => {
                    });
                },
                updateTreeData() {
                    console.log("updateTreeData(this.depts --th.clone--> this.treeData)")
                    this.treeData = th.clone(this.depts);
                },
                treeChanged(node, tree) {
                    console.log('treeChanged----') // 제자리에 둘 땐 호출되지 않는다.

                    // // 유효하지 않으면, 유효X내부 tree데이터를 <- 기존 공급된 depts데이터로 덮어써서 없앰
                    // if (!this.validateSameParent(node)) {
                    //     this.toast('동일한 부모 부서아래 순서이동만 가능합니다.', 'is-danger')
                    //     // [cancel 1] 검증 실패 => tree변경 취소 (기존 this.depts -> this.treeData 덮어쓰기)
                    //     this.updateTreeData();
                    //     return;
                    // }

                    //node._vm.level에는, 바뀐후의 level이 안찍히는 버그 -> node.parent.level로, 바뀐부모의 level필드로 +1을 시켜 현재 level을 알아내자.


                    // 유효한 경우 => DB에서변경 => 성공시 바뀐 tree데이터를 -> 외부공급 this.depts로 가져옮
                    // (1) 유효한 순서변경 => 변경할 route에 가서 순서를 변경하고 온다.
                    // console.log(this.treeData)


                    let payload = {
                        dept_id: node.id,
                        after_sort: node.parent.children.indexOf(node) + 1,

                        is_cross_level: false, // cross_level인지 아닌지 구분하는 flag 생성
                        after_parent_id: null,
                    }

                    // 동일부모가 아닌 경우 => cross level chang sort로서, 추가필드르 채워준다.
                    if (!this.validateSameParent(node)) {
                        payload.is_cross_level = true;
                        if (!node.parent.isRoot) {
                            payload.after_parent_id = node.parent._vm.data.id;
                        } else {
                            payload.after_parent_id = null;
                        }
                    }


                    axios({
                        url: '{{ url_for("department.change_sort") }}',
                        method: 'put',
                        data: payload,
                        headers: {'Content-type': 'application/json;charset=utf-8'},
                    }).then(res => {
                        // 통신성공 but 로직 실패(200대 외) -> tree되돌려야함 by this.updateTreeData();
                        // TODO: 부서 순서 변경실패(통신은 됬는데 DB실패) => 이미 tree가 바뀌었다면, cancel해야함.
                        if (res.status >= 300) {
                            this.toast(res.data.message)
                            // [cancel 2] 통신성공 BUT 로직실패  => tree변경 취소(기존 this.depts -> this.treeData)
                            this.updateTreeData(); // 변경된 tree 롤백
                            return;
                        }

                        // 통신 성공 + (DB 순서변경)로직 성공 -> 그제서야 실제 tree도 변해야함.  =
                        // 서버 -> db에 변경된 내용을 받아와, depts -> updateTreeData(this.treeData) -> initialDepts 다 업뎃이트
                        // 아니다. tree는 이미 changed되었으니, 새로 this.treeData받지말고, this.depts와 this.initial만 수정하자. 실패시 롤백만
                        // this.getUpdatedDepts();
                        this.treeUpdated(tree); // tree 자체 ----getPureData------> this.depts
                        this.initialDepts = this.depts; // this.depts -------> this.initialDepts


                        this.toast(res.data.message);


                        // TODO: 부서 순서 변경되었음 => 이미 tree가 바뀌었다면, (1) 관련된 모든 놈들의 .sort값 변경 (2) this.depts 변경 + this.initialDepts 변경)
                        // node.sort = payload.afterSort;
                        // // 자식들 색을 위해 자식들의 .parent_sort도 다 바꿔주기
                        // for (let child of node.children) {
                        //     child.parent_sort = node.sort;
                        // }

                        // TODO: 관련 node들도 DB에서 받아서 다 sort바꿔주기 -> 어차피 같은 부모(level)에서만 달라지기 때문에, BFS말고 해당부모의 node만 바꿔주면 된다?!
                        // th.breadthFirstSearch(this.treeData, node => {
                        //     let myParentChildren = node.parent ? node.parent.children : this.treeData;
                        //     let mySort = myParentChildren.indexOf(node) + 1;
                        //     if (mySort !== node.sort) {
                        //         console.log(`원래sort(${node.sort})와 현재sort${mySort}가 달라요.`)
                        //         node.sort =  mySort;
                        //     }
                        // });
                        // let myParentChildren = node.parent ? node.parent.children : this.treeData;
                        // for (const [index, node] of myParentChildren.entries()) {
                        //     const mySort = index + 1;
                        //     // 순서가 달라 바뀌는 놈들
                        //     if (mySort !== node.sort) {
                        //         // console.log(`원래sort(${node.sort})와 현재sort${mySort}가 달라요.`)
                        //         node.sort = mySort;
                        //         // 바뀌는 놈들은 그놈의 자식들의 .parent_sort도 같이 바꿔주기
                        //         for (let child of node.children) {
                        //             child.parent_sort = node.sort;
                        //         }
                        //     }
                        // }


                        // console.log('this.treeData, payload.afterSort >> ', this.treeData, payload.afterSort);

                        // this.treeUpdated(tree); // tree 자체 ----getPureData------> this.depts
                        // this.initialDepts = this.depts; // this.depts -------> this.initialDepts


                        // this.toast('순서변경에 성공하였습니다.')


                    }).catch(err => {
                        console.log(err)
                        this.toast(err.response ? err.response.data.message : '서버와 연결이 올바르지 않습니다.');
                        // [cancel 3] 통신실패  => tree변경 취소(기존 this.depts -> this.treeData)
                        this.updateTreeData();

                    }).finally(() => {
                    });


                    console.log('treeChanged====')
                },

                validateFirstNotParent() {
                    console.log('validateFirstNotParent----')
                    let isValid = true;

                    th.depthFirstSearch(this.treeData, (childNode) => {
                        const index = childNode.parent.children.indexOf(childNode);

                        const level = childNode._vm.level;

                        // 최상레벨이 첫시작인 1개의 root인데, 자식이 있다면, 유효하지 않다.
                        // const isRoot = this.expectsRoot && level === 1 && index === 0;
                        const isRoot = level === 1 && index === 0;
                        if (isRoot && childNode.children && childNode.children.length > 0) {
                            isValid = false;
                            this.toast('첫번째는 root는 자식이 있을 경우 유효하지 않습니다.', 'is-danger');
                        }
                    });

                    // console.log('validateFirstNotParent====')
                    return isValid;
                },
                validateNotSamePosition(node) {
                    console.log('validateNotSamePosition----')

                    let beforeLevel = node.level - 1;
                    let beforeSort = node.sort;

                    let currentLevel = node._vm.level;
                    let currentSort = node.parent.children.indexOf(node) + 1;
                    // console.log(beforeLevel, beforeSort, currentLevel, currentSort,)
                    console.log('validateNotSamePosition====')
                    return (beforeLevel === currentLevel) && (beforeSort === currentSort);

                },
                validateSameParent(node) {
                    console.log('validateSameParent----')
                    let isValid = true;

                    // 원래 root는 null로 들어오는데, 자식이 있는 root는 undefine으로 뜬다.
                    let beforeParentId = null;
                    if (node.parent_id) {
                        beforeParentId = node.parent_id;
                    }
                    // console.log('node, node.parent_id >> ', node, node.parent_id);


                    let afterParentId = null; // db에 root의 parentId는 null;이라고 기본값으로 줌.
                    // node.parent로만 검사하면 level0에서도 parent는 존재하는 것으로 검사됨.
                    if (node.parent.id) {
                        afterParentId = node.parent.id;
                    }

                    if (beforeParentId !== afterParentId) {
                        isValid = false;
                    }
                    console.log('beforeParentId, afterParentId', beforeParentId, afterParentId)
                    console.log('validateSameParent====')

                    return isValid;
                },
                treeUpdated(tree) {
                    console.log('treeUpdated(tree -> this.depts)----')

                    tree = tree || this.$refs.tree;

                    this.depts = tree.getPureData();

                    // console.log('this.depts >> ', this.depts);
                    console.log('treeUpdated======================')
                },

                // node관련
                selectNode(dept) {
                    // 선택되지 않은 dept라면, 할당 -> 선택됬다면 null로 선택 풀기
                    if (this.idOfSelectedDept !== dept.id) {
                        this.selectedDept = dept;
                        return;
                    }
                    this.selectedDept = null;
                },
                getNodeElement(deptId) {
                    return document.querySelector("#node-" + deptId);
                },
                getNameInput(deptId) {
                    return document.querySelector("#name-" + deptId);
                },
                showNameInput(deptId) {
                    let nodeElement = this.getNodeElement(deptId);
                    nodeElement.style.display = 'none';

                    let nameInput = this.getNameInput(deptId);
                    nameInput.style.display = 'block';

                    this.$nextTick(() => nameInput.focus());
                },
                hideNameInput(deptId) {
                    let nodeElement = this.getNodeElement(deptId);
                    nodeElement.style.display = 'block';

                    let nameInput = this.getNameInput(deptId);
                    nameInput.style.display = 'none';
                    // 수정 취소이므로 안보이게 되는 input에 원본 값으로 재할당해주기
                    nameInput.value = nodeElement.innerText;
                },
                checkInvalidNameLength: function (targetName) {
                    return targetName.length > 10 || targetName.length < 2;
                },
                checkNotSameName: function (targetName, dept) {
                    return targetName !== dept.name;
                },
                existNameInTree: function (targetName) {
                    let isValid = false;
                    th.breadthFirstSearch(this.treeData, node => {
                        if (targetName === node.text) {
                            isValid = true;
                            // bfs handler(익명함수)에, return false하면 멈춘다.
                            return false;
                        }
                    });
                    return isValid;
                },

                // dept의 필드를 변경해야하기 때문에, 연동(객체 및 tree까지)되는 객체를 인자로받는다.
                validateName(dept) {
                    console.log('validateName----')

                    // console.log('event.target.value >> ', event.target.value);
                    let nameInput = this.getNameInput(dept.id);
                    let targetName = nameInput.value.trim();

                    // 글자수 체크
                    if (this.checkInvalidNameLength(targetName)) {
                        this.toast('이름은 2~10자로 입력해주세요.', 'is-danger');
                        this.hideNameInput(dept.id);
                        return;
                    }

                    // 같은 값으로 변경
                    if (!this.checkNotSameName(targetName, dept)) {
                        this.toast('같은 이름으로 변경할 수 없습니다.', 'is-danger');
                        this.hideNameInput(dept.id);
                        return;
                    }

                    // 이미 존재하는 명칭으로 변경 => bfs로 하나씩 돌면서 찾아본다.
                    if (this.existNameInTree(targetName)) {
                        this.toast('이미 존재하는 이름으로 변경할 수 없습니다.', 'is-danger');
                        this.hideNameInput(dept.id);
                        return;
                    }

                    this.changeName(dept, targetName);


                    console.log('validateName====')
                },

                changeName(dept, targetName) {
                    console.log('changeName----')

                    const payload = {
                        dept_id: dept.id,
                        target_name: targetName
                    }
                    axios({
                        url: '{{ url_for("department.change_name") }}',
                        method: 'put',
                        data: payload,
                        headers: {'Content-type': 'application/json;charset=utf-8'},
                    }).then(res => {
                        // 통신성공 but 로직 실패(200대 외)
                        if (res.status >= 300) {
                            this.toast(res.data.message)

                            return;
                        }

                        // 통신 성공 + (name변경)로직 성공
                        dept.name = targetName;
                        // 성공시 해당 input을 안보이게 + view는 보이게 다시 변경
                        this.hideNameInput(dept.id);

                        this.treeUpdated(dept._vm.store); // tree(vm) 자체 ----getPureData------> this.depts
                        this.initialDepts = this.depts; // this.depts -------> this.initialDepts

                        this.toast(res.data.message)

                    }).catch(err => {
                        console.log(err)
                        // 특별히 err에 response가 내려온다면. 거기서 메세지를 꺼내서
                        this.toast(err.response ? err.response.data.message : '서버와 연결이 올바르지 않습니다.');
                        this.updateTreeData(); // 변경된 tree 롤백

                    }).finally(() => {

                    });

                    console.log('changeName====')
                },

                // modal용 form변수(Object들 모두) 초기화 메서드
                initObject(obj) {
                    console.log('initObject----')
                    for (const key in obj) {
                        if (typeof obj[key] === "number") {
                            obj[key] = null;
                        } else if (typeof obj[key] === "string") {
                            obj[key] = null; // :placeholder때문에 ""는 삼항연자에서 true로 먹음
                        } else if (typeof obj[key] === "boolean") {
                            obj[key] = false;
                        } else if (Array.isArray(obj[key])) {
                            obj[key] = [];
                        } else {
                            obj[key] = {};
                        }
                    }
                    console.log('initObject====')
                },

                // modal용 submit메서드
                submitDeptAddForm(e) {
                    //1. 로딩을 띄워서 send버튼 비활성화
                    this.isLoading = true;
                    // console.log("this.form", this.form) // 부서type option을 int로 넣어줬어도, b-select가 문자열로 보냄.

                    //2.
                    axios({
                        url: '{{ url_for("department.add") }}',
                        method: 'post',
                        data: this.form,
                        headers: {'Content-type': 'application/json;charset=utf-8'},
                    }).then(res => {
                        // 통신성공 but 로직 실패(200대 외)
                        if (res.status >= 300) {
                            this.toast(res.data.message, 'is-danger')
                            return;
                        }

                        // 통신 성공 + (DB생성)로직 성공 -> tree에 생성된 자식 push -> 공급/초기데이터도 업뎃
                        // TODO: 부서생성되었으니, tree도 업뎃?!
                        // (1) 생성된 데이터를 받는다.
                        let newDept = res.data.new_dept;

                        // (2) 연동데이터인 해당부모 or root에 push한다.
                        const parentChildren = this.selectedDept
                            ? this.selectedDept._vm.data.children
                            : this.treeData;
                        parentChildren.push(newDept);

                        // (3) tree를 업뎃한다.
                        this.treeUpdated(); // tree(vm) 자체 ----getPureData------> this.depts
                        this.initialDepts = this.depts; // this.depts -------> this.initialDepts


                        // 성공시에만 (1) 모달끄기 (2) form데이터 초기화
                        this.isDepartmentModalActive = false; // 로직 성공시에만 모달창 닫기
                        this.initObject(this.form); // 로직 성송시에만 form속 데이터 초기화


                        this.toast(res.data.message)

                    }).catch(err => {
                        console.log(err)
                        // 특별히 err에 response가 내려온다면. 거기서 메세지를 꺼내서
                        this.toast(err.response ? err.response.data.message : '서버와 연결이 올바르지 않습니다.');

                    }).finally(() => {
                        this.isLoading = false; // 로딩 끄기
                    });

                },

                // node 삭제
                validateDelete() {
                    // 삭제 진행 전 검증하기
                    const targetDept = this.selectedDept;
                    // [검증1] 하위 부서 존재여부
                    // 일단 자식없는 node라도 .children는 빈 어레이로 가지고 있음.
                    if (targetDept.children && targetDept.children.length) {
                        this.toast('하위 부서가 존재할 경우 삭제할 수 없습니다.', 'is-danger')
                        return;
                    }

                    // [검증2] (하위부서X)부서의 직원이 존재할 경우, [있다면 해임시키게 될 건데] confirm받기
                    // console.log('targetDept.has_direct_leader >> ', targetDept.has_direct_leader);
                    if (targetDept.has_direct_leader) {
                        this.toast('부서장이 존재할 경우 삭제할 수 없습니다.', 'is-danger')
                        return;
                    }
                    if (targetDept.employees && targetDept.employees.length > 0) {
                        this.toast('재직 중인 직원이 존재할 경우 삭제할 수 없습니다.', 'is-danger')
                        return;
                    }
                    // this.confirm('삭제할 경우, 해당 부서원들은 금일부 해임됩니다. 진행하시겠습니까?', async () => await this.deleteSelectedNode() );

                    // [검증3] 정말 삭제할 것인지 confirm 받기
                    this.confirm('정말 삭제하시겠습니까?', () => this.deleteSelectedNode());
                },

                deleteSelectedNode() {
                    //1. tree VM으로 선택node 삭제
                    const targetDept = this.selectedDept;

                    // TODO: 서버에 삭제요청 보내기
                    const payload = {
                        dept_id: targetDept.id
                    }
                    axios({
                        url: '{{ url_for("department.delete") }}',
                        method: 'delete',
                        data: payload,
                        headers: {'Content-type': 'application/json;charset=utf-8'},
                    }).then(res => {
                        // 통신성공 but 로직 실패(200대 외)
                        if (res.status >= 300) {
                            this.toast(res.data.message, 'is-danger');
                            return;
                        }

                        // 통신 성공 + (status변경)로직 성공
                        //tree에서 해당 node 삭제
                        let tree = targetDept._vm.store; // node로부터 전체 tree얻기
                        tree.deleteNode(targetDept);

                        // console.log('this.treeData >> ', this.treeData); // 연동되어, 해당node만 삭제
                        // console.log('this.selectedDept >> ', this.selectedDept);// 유지 + .parent에선 사라진 현재 tree연동됨.

                        //2. 선택node보다 더 뒤에 sort를 1칸씩 당긴다.
                        const standardSort = targetDept.sort;
                        let myParentChildren = targetDept.parent ? targetDept.parent.children : this.treeData;
                        // for (const node in myParentChildren) {
                        // [조심!] 일반 for in 으로 돌면 -> key값만 도는 것이다.
                        for (const node of myParentChildren) {
                            // 여기서는 index로 sort를 만들면 안된다. 이미 트리에서 1개가 빠진 상태에서 순회하기 때문
                            if (node.sort > standardSort) {
                                // console.log(`현재sort${node.sort}를 한칸씩 -1 합니다.`)
                                node.sort = node.sort - 1;
                            }
                        }
                        // 3. selected된거 없으니 비워주기
                        this.selectedDept = null;

                        //4. 변경된 tree를 -> this.depts -> this.initialDepts에 반영
                        this.treeUpdated(tree);
                        this.initialDepts = this.depts;

                        this.toast(res.data.message);

                    }).catch(err => {
                        console.log(err)
                        // 특별히 err에 response가 내려온다면. 거기서 메세지를 꺼내서
                        this.toast(err.response ? err.response.data.message : '서버와 연결이 올바르지 않습니다.');

                    }).finally(() => {

                    });


                },

                // status 변화
                validateStatusChange(dept) {
                    // TODO: [검증1] (하위부서X)부서의 직원이 존재할 경우, [있다면 해임시키게 될 건데] confirm받기
                    // this.confirm('비활성화할 경우, 해당 부서원들은 금일부 해임됩니다. 진행하시겠습니까?', async () => await this.deleteSelectedNode() );
                    // => delete와 같은 로직이라 복붙함.
                    if (dept.has_direct_leader) {
                        this.toast('부서장이 존재할 경우 비활성화 할 수 없습니다.', 'is-danger')
                        return;
                    }
                    if (dept.employees && dept.employees.length > 0) {
                        this.toast('재직 중인 직원이 존재할 경우 비활성화 할 수 없습니다.', 'is-danger')
                        return;
                    }

                    // 비활성 -> 활성 경우, 그냥 토글한다.
                    if (!dept.status) {
                        this.changeStatus(dept);
                        return;
                    }
                    // [검증2] 활성상태일때만, 정말 비할성화 것인지 confirm 받기
                    this.confirm('정말 비활성화하시겠습니까??', () => this.changeStatus(dept));
                },

                changeStatus(dept) {
                    const payload = {
                        dept_id: dept.id
                    }
                    axios({
                        url: '{{ url_for("department.change_status") }}',
                        method: 'put',
                        data: payload,
                        headers: {'Content-type': 'application/json;charset=utf-8'},
                    }).then(res => {
                        // 통신성공 but 로직 실패(200대 외)
                        if (res.status >= 300) {
                            this.toast(res.data.message, 'is-danger')
                            return;
                        }

                        // 통신 성공 + (status변경)로직 성공 -> tree에 생성된 자식 push -> 공급/초기데이터도 업뎃
                        dept.status = !dept.status

                        this.treeUpdated(dept._vm.store); // tree(vm) 자체 form node._vm.store ----getPureData------> this.depts
                        this.initialDepts = this.depts; // this.depts -------> this.initialDepts

                        this.toast(res.data.message)

                    }).catch(err => {
                        console.log(err)
                        // 특별히 err에 response가 내려온다면. 거기서 메세지를 꺼내서
                        this.toast(err.response ? err.response.data.message : '서버와 연결이 올바르지 않습니다.');

                    }).finally(() => {

                    });
                },


                emitClick(dep, level, store, $event) {
                    console.log('emitClick');
                    console.log('depthdepthdepthdepthdepth', level.level);
                    this.$emit('change-dept', dept, level, store, $event);
                    console.log("dept, level, store, $event")
                    console.log(dept, level, store, $event)
                },
                emitChange(dept, level, store, $event) {
                    console.log('emitChange');
                    console.log('depthdepthdepthdepthdepth', level.level);
                    this.$emit('change-dept', dept, level, store, $event);
                    console.log("dept, level, store, $event")
                    console.log(dept, level, store, $event)
                },
                emitDrag(dept, level, store, $event) {
                    console.log('emitDrag');
                    console.log('depthdepthdepthdepthdepth', level.level);
                    this.$emit('drag-dept', dept, level, store, $event);
                    console.log("dept, level, store, $event")
                    console.log(dept, level, store, $event)
                },

                onDragStart(node, draggableHelperInfo) {
                    // console.log(' onDragStart');
                    // console.log(draggableHelperInfo)
                    // console.log('node, draggableHelperInfo =>', node, draggableHelperInfo)
                    //
                    // return false;

                },
                onDragEnd(beforeNode, draggableHelperInfo) {
                    console.log(' onDragEnd----');


                    // (1) Drag 하는 원래 node
                    // let current_parentId = node.parent.id;
                    // console.log('node.parent.id', current_parent_id)

                    // console.log(' draggableHelperInfo.store', draggableHelperInfo.store);

                    // (2) tree정보인데, 인자에는 안넘어와서
                    //     => 컴포넌트 내부에 ref="tree" 설정하여 전역변수 this.$ref로 해당 객체에 접근하게 한다.
                    // console.log('this.$refs.tree', this.$refs.tree)

                    // (3) tree가 필요한게 아니라 drag된 node의 정보를 알고 어디 위치했는지 알아야하는데
                    //     tree.dplh로  [drag도착하는 placeholder node]를 얻을 수 있다.
                    // console.log('this.$refs.tree.dplh', this.$refs.tree.dplh)
                    // active: false // parent: children:(...) isRoot:true // class: "draggable-placeholder"

                    // console.log('this.$refs.tree.dplh.parent', this.$refs.tree.dplh.parent)
                    // active:(...) children:Array(1) class:(...) id: 2 level:0
                    // => root에 위치할 경우, .parent node객체는 children: Array(4) isRoot :true
                    //    isRoot여부와 자식들에게 접근할 수 있따.
                    // console.log('this.$refs.tree.dplh.parent.isRoot', this.$refs.tree.dplh.parent.isRoot)
                    // => true  or   undefine => 부모가 tree의 root가 아닐 경우 isRoot 정보가 안들어가있다.

                    // let after_parent_id = this.$refs.tree.dplh.parent.id;
                    // console.log('this.$refs.tree.dplh.parent', after_parent_id)

                    // (4) 이동끝난 node정보를 못받는다. => ref="node"를 걸어 받는다.
                    // console.log('this.$refs.node', this.$refs.node)
                    // console.log('인자 node', node)
                    //<div dept="[object Object]" depth="1" vm="[object Object]"></div>
                    // console.log('this.$refs.node.getAttribute(\'depth\')', this.$refs.node.getAttribute('depth'))
                    // this.$refs.node.getAttribute('depth') 1
                    // console.log('this.$refs.node.getAttribute(\'dept\')', this.$refs.node.getAttribute('dept'))
                    // this.$refs.node.getAttribute('dept') [object Object] => 사용X
                    // console.log('this.$refs.node.getAttribute(\'vm\')', this.$refs.node.getAttribute('vm'))
                    // this.$refs.node.getAttribute('vm') [object Object] => 사용X


                    // let before_parent = node.parent;
                    // let after_parent = this.$refs.tree.dplh.parent;
                    // // console.log('before_parent', before_parent)
                    // // console.log('after_parent', after_parent)
                    //
                    // // (6) 부모.id를 비교할 때, undefined로 서로 같다고 떠서, 따로 처리 안해줘도 될 것 같다.
                    // if (before_parent.id === after_parent.id) {
                    //
                    //     this.toast('같은 부모' + after_parent.id + '에요!')
                    // } else {
                    //     // this.$refs.tree.dplh.innerClass += ' has-background-danger-light'
                    //     this.toast('다른 부모' + before_parent.id + '<->' + after_parent.id + '에요!', 'is-danger')
                    //     // return false;
                    // }
                    //

                    // // 둘다 isRoot가 true로 존재하면 부모가 없다면 같은 부모다.
                    // if (before_parent.isRoot && after_parent.isRoot) {
                    //     this.toast('같은 부모(ROOT) 에요!')
                    // } else {
                    //     // 둘 중에 하나라도 root가 아닌 경우 다른 부모이다. 둘다 null일 경우 비교해야한다.
                    //     // 자바스크립트 자료형에서 false로 반환되는 값은 "", null, undefined, 0, NaN
                    //     // => !value로 true일때를 비교해준다. 비교해준다.
                    //     if (before_parent.id === after_parent.id ) {
                    //         this.toast('같은 부모' + after_parent.id + '에요!')
                    //     } else {
                    //         this.toast('다른 부모' + before_parent.id + '<->' +after_parent.id + '에요!')
                    //
                    //     }
                    // }

                    // let currentLevel = node.level;
                    // console.log('node.level', currentLevel);
                    // let afterLevel = node._vm.level - 1 ;
                    // console.log('node._vm.level - 1', afterLevel);
                    // if (currentLevel !== afterLevel) {
                    //     this.toast('같은 선상의 순서만 변경가능 합니다.', 'is-danger');
                    //
                    //     return false;
                    // }
                    //
                    // else {
                    //     console.log('같은 선상이라 drag완료')
                    // }

                    console.log(' onDragEnd====');
                },
                nodeChanged(dept, vm, store, $event) {
                    console.log('level을 가진 nodeChanged');
                    console.log('id, name, level =>', dept.id, dept.name, vm.level)
                    console.log('$event =>', $event)
                },

                changeDept(dept, vm, store, $event) {
                    console.log('changeDept')
                    console.log(dept)
                    console.log(vm)
                    console.log(store)
                },
                editDept(dept, vm, store, $event) {
                    console.log(dept)
                    console.log(vm)
                    console.log(store)
                },


                getDeptIds(depts) {
                    let ids = [];
                    depts.forEach(dept => {
                        ids.push(dept.id);
                        if (dept.children && dept.children.length) {
                            ids = [...ids, ...this.getDeptIds(dept.children)];
                        }
                    })
                    return ids;
                },

                getDeptLevels(depts) {
                    let levels = [];
                    depts.forEach(dept => {
                        levels.push(dept.level);
                        if (dept.children && dept.children.length) {
                            levels = [...levels, ...this.getDeptLevels(dept.children)];
                        }
                    })
                    return levels;
                },

                nodeDragged(node) {
                    // console.log('nodeDragged')
                    // console.log(this.$refs.tree.dplh);
                    // this.$refs.tree.dplh.innerBackClass = 'has-background-danger-light';
                    // this.$refs.tree.dplh.innerClass += ' has-background-danger-light'

                    // console.log('기존level', node.level)
                    // console.log('현재level', node._vm.level - 1)
                    // if (node.level !== node._vm.level - 1) {
                    //     console.log('레벨이 달라 this.isSameLevel = false;!')
                    //     // node.droppable = false;
                    //     this.isSameLevel = false;
                    //     return
                    // }
                    // console.log('레벨이 같아 this.isSameLevel = true;!')
                    // this.isSameLevel = true;


                },
                //
                //
                // save() {
                //     this.saving = true;
                //     // const payload = {
                //     //     pages: this.pages,
                //     //     site: this.site,
                //     //     expectsRoot: this.expectsRoot, ...this.submitParameters
                //     // };
                //     // return this.$axios.post(this.submitUrl, payload).then(response => {
                //     this.$emit('saved');
                //     // this.$toast.success(__('Saved'));
                //     console.log('save()')
                //     this.initialDepts = JSON.parse(JSON.stringify(this.depts));
                //
                //     // return response;
                //     // }).catch(e => {
                //     //     this.$toast.error(e.response ? e.response.data.message : __('Something went wrong'));
                //     //     return Promise.reject(e);
                //     // }).finally(() => this.saving = false);
                // },

                addPages(depts, targetParent) {
                    const parent = targetParent
                        ? targetParent.data.children
                        : this.treeData;
                    depts.forEach(selection => {
                        parent.push({
                            id: selection.id,
                            title: selection.title,
                            slug: selection.slug,
                            url: selection.url,
                            edit_url: selection.edit_url,
                            children: []
                        });
                    });
                    this.treeUpdated();
                },

                clone(source) {
                    var target = [];
                    for (let i in source) {
                        if (source[i] != null && typeof source[i] === "object") {
                            target[i] = clone(source[i]); // recursion
                        } else {
                            target[i] = source[i];
                        }
                    }
                    return target;
                },

                // updateTreeData() {
                //     console.log("updateTreeData")
                //     console.log('this.depts', this.depts);
                //     this.treeData = this.clone(this.depts);
                //     console.log('updateTreeData', this.treeData);
                // },

                deptRemoved(tree) {
                    this.depts = tree.getPureData();
                    this.$emit('changed');
                },
                cancel() {
                    if (!confirm(__('Are you sure?'))) return;
                    this.depts = this.initialDepts;
                    this.updateTreeData();
                    this.$emit('canceled');
                },
                treeDragstart(node) {
                    console.log("treeDragstart")
                    console.log("node.level", node.level)
                    // Support for maxDepth.
                    // Adapted from https://github.com/phphe/vue-draggable-nested-tree/blob/a5bcf2ccdb4c2da5a699bf2ddf3443f4e1dba8f9/src/examples/MaxLevel.vue#L56-L75
                    // let nodeLevels = 1;
                    // th.depthFirstSearch(node, (childNode) => {
                    //     if (childNode._vm.level > nodeLevels) {
                    //         nodeLevels = childNode._vm.level;
                    //     }
                    // });
                    // nodeLevels = nodeLevels - node._vm.level + 1;
                    // const childNodeMaxLevel = this.maxDepth - nodeLevels;
                    // th.depthFirstSearch(this.treeData, (childNode) => {
                    //     if (childNode === node) return;
                    //     const index = childNode.parent.children.indexOf(childNode);
                    //     const level = childNode._vm.level;
                    //     const isRoot = this.expectsRoot && level === 1 && index === 0;
                    //     const isBeyondMaxDepth = level > childNodeMaxLevel;
                    //     let droppable = true;
                    //     if (isRoot || isBeyondMaxDepth) droppable = false;
                    //     this.$set(childNode, 'droppable', droppable);
                    // });
                },
                deptUpdated(tree) {
                    this.depts = tree.getPureData();
                    this.$emit('changed');
                },

                curNodeClicked(data) {
                    console.log(data);
                    // active
                    // children
                    // class
                    // innerBackClass
                    // innerBackStyle
                    // innerClass
                    // innerStyle
                    // open
                    // parent
                    // style
                    // text
                    // _id
                    // _treeNodePropertiesCompleted
                }
                ,
                collapseAll: function () {
                    console.log('collapseAll');

                    th.breadthFirstSearch(this.treeData, node => {
                        if (node.children && node.children.length) {
                            node.open = false;
                        }
                    });

                }
                ,
                expandAll: function () {
                    // th의 내부에 hp.isArray => Array.isArray로 모두 수정
                    console.log('expandAll');

                    th.breadthFirstSearch(this.treeData, node => {
                        if (node.children && node.children.length) {
                            node.open = true;
                        }
                    });
                },
            },

            computed: {
                idOfSelectedDept() {
                    return this.selectedDept ? this.selectedDept.id : null
                },
                currentDplhParentId() {
                    return this.$refs.tree.dplh.parent.id ? this.$refs.tree.dplh.parent.id : null
                },
                currentDplhParent() {
                    return this.$refs.tree.dplh.parent
                }
            },

        }
    ;
</script>
{% endblock vue_mixins %}

{% block vue_script %}
<script>


    // app._data.draggableTree = [
    //     {text: 'node 1'},
    //     {text: 'node 2'},
    //     {text: 'node 3 undraggable', draggable: false},
    //     {text: 'node 4 undroppable', droppable: false},
    //     {
    //         text: 'node 5', children: [
    //             {text: 'node 6'},
    //             {text: 'node 7'},
    //         ]
    //     },
    // ];


    // tree1data: [
    //     {text: 'node 1'},
    //     {text: 'node 2'},
    //     {text: 'node 3 undraggable', draggable: false},
    //     {text: 'node 4 undroppable', droppable: false},
    //     {
    //         text: 'node 5', children: [
    //             {text: 'node 6'},
    //             {text: 'node 7'},
    //         ]
    //     },
    // ],
    // tree2data: [
    //     {
    //         text: 'node 8', children: [
    //             {text: 'node 9'},
    //             {
    //                 text: 'node 10 undroppable', droppable: false, children: [
    //                     {text: 'node 11'},
    //                     {text: 'node 12'},
    //                 ]
    //             },
    //             {
    //                 text: 'node 13', children: [
    //                     {text: 'node 14'},
    //                     {text: 'node 15 undroppable', droppable: false},
    //                 ]
    //             },
    //             {text: 'node 16'},
    //             {text: 'node 17'},
    //             {text: 'node 18'},
    //         ]
    //     },
    // ]
    // }
    // console.log(app._data.treeData)
</script>
{% endblock vue_script %}